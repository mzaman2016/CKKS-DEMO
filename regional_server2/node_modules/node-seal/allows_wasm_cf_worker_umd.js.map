{"version":3,"file":"allows_wasm_cf_worker_umd.js","sources":["../src/bin/seal_allows_wasm_cf_worker.js","../src/implementation/constants.ts","../src/implementation/finalizer.ts","../src/implementation/batch-encoder.ts","../src/implementation/cipher-text.ts","../src/implementation/ckks-encoder.ts","../src/implementation/coeff-modulus.ts","../src/implementation/compr-mode-type.ts","../src/implementation/context.ts","../src/implementation/context-data.ts","../src/implementation/decryptor.ts","../src/implementation/encryption-parameter-qualifiers.ts","../src/implementation/encryption-parameters.ts","../src/implementation/encryptor.ts","../src/implementation/evaluator.ts","../src/implementation/exception.ts","../src/implementation/galois-keys.ts","../src/implementation/key-generator.ts","../src/implementation/memory-pool-handle.ts","../src/implementation/modulus.ts","../src/implementation/parms-id-type.ts","../src/implementation/plain-modulus.ts","../src/implementation/plain-text.ts","../src/implementation/public-key.ts","../src/implementation/relin-keys.ts","../src/implementation/scheme-type.ts","../src/implementation/seal.ts","../src/implementation/secret-key.ts","../src/implementation/security-level.ts","../src/implementation/serializable.ts","../src/implementation/vector.ts","../src/allows_wasm_cf_worker_umd.ts","../src/main/seal.ts"],"sourcesContent":["async function Module(moduleArg={}){var moduleRtn;var l=moduleArg,aa=\"./this.program\",ba=import.meta.url,ca=\"\",da,ea;try{ca=(new URL(\".\",ba)).href}catch{}ea=b=>{var a=new XMLHttpRequest;a.open(\"GET\",b,!1);a.responseType=\"arraybuffer\";a.send(null);return new Uint8Array(a.response)};da=async b=>{b=await fetch(b,{credentials:\"same-origin\"});if(b.ok)return b.arrayBuffer();throw Error(b.status+\" : \"+b.url);};var n=console.error.bind(console),v,x=!1,y,fa,ha,ia,ja,z,A,C,D,F,ka,la,ma,na,oa=!1;\nfunction pa(){var b=ia.buffer;ja=new Int8Array(b);A=new Int16Array(b);z=new Uint8Array(b);C=new Uint16Array(b);D=new Int32Array(b);F=new Uint32Array(b);ka=new Float32Array(b);la=new Float64Array(b);ma=new BigInt64Array(b);na=new BigUint64Array(b)}var G=0,I=null;function qa(b){l.onAbort?.(b);b=\"Aborted(\"+b+\")\";n(b);x=!0;b=new WebAssembly.RuntimeError(b+\". Build with -sASSERTIONS for more info.\");ha?.(b);throw b;}var ra;\nasync function sa(b){if(!v)try{var a=await da(b);return new Uint8Array(a)}catch{}if(b==ra&&v)b=new Uint8Array(v);else if(ea)b=ea(b);else throw\"both async and sync fetching of the wasm failed\";return b}async function ta(b,a){try{var c=await sa(b);return await WebAssembly.instantiate(c,a)}catch(d){n(`failed to asynchronously prepare wasm: ${d}`),qa(d)}}\nasync function ua(b){var a=ra;if(!v)try{var c=fetch(a,{credentials:\"same-origin\"});return await WebAssembly.instantiateStreaming(c,b)}catch(d){n(`wasm streaming compile failed: ${d}`),n(\"falling back to ArrayBuffer instantiation\")}return ta(a,b)}class va{name=\"ExitStatus\";constructor(b){this.message=`Program terminated with exit(${b})`;this.status=b}}var wa=b=>{for(;0<b.length;)b.shift()(l)},xa=[],ya=[],za=()=>{var b=l.preRun.shift();ya.push(b)},Aa=!0;class Ba{constructor(b){this.V=b-24}}\nvar Ca=0,Da=0,J=b=>{b>>>=0;for(var a=\"\";;){var c=z[b++>>>0];if(!c)return a;a+=String.fromCharCode(c)}},K={},L={},Ea={},N=class extends Error{constructor(b){super(b);this.name=\"BindingError\"}};function Fa(b,a,c={}){var d=a.name;if(!b)throw new N(`type \"${d}\" must have a positive integer typeid pointer`);if(L.hasOwnProperty(b)){if(c.va)return;throw new N(`Cannot register type '${d}' twice`);}L[b]=a;delete Ea[b];K.hasOwnProperty(b)&&(a=K[b],delete K[b],a.forEach(e=>e()))}\nfunction O(b,a,c={}){return Fa(b,a,c)}\nvar Ha=(b,a,c)=>{switch(a){case 1:return c?d=>ja[d>>>0]:d=>z[d>>>0];case 2:return c?d=>A[d>>>1>>>0]:d=>C[d>>>1>>>0];case 4:return c?d=>D[d>>>2>>>0]:d=>F[d>>>2>>>0];case 8:return c?d=>ma[d>>>3>>>0]:d=>na[d>>>3>>>0];default:throw new TypeError(`invalid integer width (${a}): ${b}`);}},Ia=b=>{throw new N(b.T.X.U.name+\" instance already deleted\");},Ja=!1,Ka=()=>{},P=b=>{if(\"undefined\"===typeof FinalizationRegistry)return P=a=>a,b;Ja=new FinalizationRegistry(a=>{a=a.T;--a.count.value;0===a.count.value&&\n(a.Z?a.ba.fa(a.Z):a.X.U.fa(a.V))});P=a=>{var c=a.T;c.Z&&Ja.register(a,{T:c},a);return a};Ka=a=>{Ja.unregister(a)};return P(b)},La=[];function Ma(){}\nvar Na=(b,a)=>Object.defineProperty(a,\"name\",{value:b}),Oa={},Pa=(b,a,c)=>{if(void 0===b[a].Y){var d=b[a];b[a]=function(...e){if(!b[a].Y.hasOwnProperty(e.length))throw new N(`Function '${c}' called with an invalid number of arguments (${e.length}) - expects one of (${b[a].Y})!`);return b[a].Y[e.length].apply(this,e)};b[a].Y=[];b[a].Y[d.ga]=d}},Qa=(b,a,c)=>{if(l.hasOwnProperty(b)){if(void 0===c||void 0!==l[b].Y&&void 0!==l[b].Y[c])throw new N(`Cannot register public name '${b}' twice`);Pa(l,b,b);if(l[b].Y.hasOwnProperty(c))throw new N(`Cannot register multiple overloads of a function with the same number of arguments (${c})!`);\nl[b].Y[c]=a}else l[b]=a,l[b].ga=c},Ra=b=>{b=b.replace(/[^a-zA-Z0-9_]/g,\"$\");var a=b.charCodeAt(0);return 48<=a&&57>=a?`_${b}`:b};function Sa(b,a,c,d,e,f,g,h){this.name=b;this.constructor=a;this.ea=c;this.fa=d;this.aa=e;this.ta=f;this.ka=g;this.sa=h;this.ya=[]}\nvar Ta=(b,a,c)=>{for(;a!==c;){if(!a.ka)throw new N(`Expected null or instance of ${c.name}, got an instance of ${a.name}`);b=a.ka(b);a=a.aa}return b},Ua=b=>{if(null===b)return\"null\";var a=typeof b;return\"object\"===a||\"array\"===a||\"function\"===a?b.toString():\"\"+b};\nfunction Va(b,a){if(null===a){if(this.oa)throw new N(`null is not a valid ${this.name}`);return 0}if(!a.T)throw new N(`Cannot pass \"${Ua(a)}\" as a ${this.name}`);if(!a.T.V)throw new N(`Cannot pass deleted object as a pointer of type ${this.name}`);return Ta(a.T.V,a.T.X.U,this.U)}\nfunction Wa(b,a){if(null===a){if(this.oa)throw new N(`null is not a valid ${this.name}`);if(this.na){var c=this.za();null!==b&&b.push(this.fa,c);return c}return 0}if(!a||!a.T)throw new N(`Cannot pass \"${Ua(a)}\" as a ${this.name}`);if(!a.T.V)throw new N(`Cannot pass deleted object as a pointer of type ${this.name}`);if(!this.ma&&a.T.X.ma)throw new N(`Cannot convert argument of type ${a.T.ba?a.T.ba.name:a.T.X.name} to parameter type ${this.name}`);c=Ta(a.T.V,a.T.X.U,this.U);if(this.na){if(void 0===\na.T.Z)throw new N(\"Passing raw pointer to smart pointer is illegal\");switch(this.Ba){case 0:if(a.T.ba===this)c=a.T.Z;else throw new N(`Cannot convert argument of type ${a.T.ba?a.T.ba.name:a.T.X.name} to parameter type ${this.name}`);break;case 1:c=a.T.Z;break;case 2:if(a.T.ba===this)c=a.T.Z;else{var d=a.clone();c=this.Aa(c,Q(()=>d[\"delete\"]()));null!==b&&b.push(this.fa,c)}break;default:throw new N(\"Unsupporting sharing policy\");}}return c}\nfunction Xa(b,a){if(null===a){if(this.oa)throw new N(`null is not a valid ${this.name}`);return 0}if(!a.T)throw new N(`Cannot pass \"${Ua(a)}\" as a ${this.name}`);if(!a.T.V)throw new N(`Cannot pass deleted object as a pointer of type ${this.name}`);if(a.T.X.ma)throw new N(`Cannot convert argument of type ${a.T.X.name} to parameter type ${this.name}`);return Ta(a.T.V,a.T.X.U,this.U)}function Ya(b){return this.W(F[b>>>2>>>0])}\nvar Za=(b,a,c)=>{if(a===c)return b;if(void 0===c.aa)return null;b=Za(b,a,c.aa);return null===b?null:c.sa(b)},$a={},ab=(b,a)=>{if(void 0===a)throw new N(\"ptr should not be undefined\");for(;b.aa;)a=b.ka(a),b=b.aa;return $a[a]},bb=class extends Error{constructor(b){super(b);this.name=\"InternalError\"}},cb=(b,a)=>{if(!a.X||!a.V)throw new bb(\"makeClassHandle requires ptr and ptrType\");if(!!a.ba!==!!a.Z)throw new bb(\"Both smartPtrType and smartPtr must be specified\");a.count={value:1};return P(Object.create(b,\n{T:{value:a,writable:!0}}))};function db(b,a,c,d,e,f,g,h,k,p,m){this.name=b;this.U=a;this.oa=c;this.ma=d;this.na=e;this.xa=f;this.Ba=g;this.qa=h;this.za=k;this.Aa=p;this.fa=m;e||void 0!==a.aa?this.$=Wa:(this.$=d?Va:Xa,this.ca=null)}\nvar eb=(b,a,c)=>{if(!l.hasOwnProperty(b))throw new bb(\"Replacing nonexistent public symbol\");void 0!==l[b].Y&&void 0!==c?l[b].Y[c]=a:(l[b]=a,l[b].ga=c)},fb=[],gb,hb=b=>{var a=fb[b];a||(fb[b]=a=gb.get(b));return a},ib=(b,a,c=[])=>{a=hb(a)(...c);return\"p\"==b[0]?a>>>0:a},jb=(b,a)=>(...c)=>ib(b,a,c),R=(b,a)=>{b=J(b);var c=b.includes(\"p\")?jb(b,a):hb(a);if(\"function\"!=typeof c)throw new N(`unknown function pointer with signature ${b}: ${a}`);return c};class kb extends Error{}\nvar mb=b=>{b=lb(b);var a=J(b);S(b);return a},T=(b,a)=>{function c(f){e[f]||L[f]||(Ea[f]?Ea[f].forEach(c):(d.push(f),e[f]=!0))}var d=[],e={};a.forEach(c);throw new kb(`${b}: `+d.map(mb).join([\", \"]));},U=(b,a,c)=>{function d(h){h=c(h);if(h.length!==b.length)throw new bb(\"Mismatched type converter count\");for(var k=0;k<b.length;++k)O(b[k],h[k])}b.forEach(h=>Ea[h]=a);var e=Array(a.length),f=[],g=0;a.forEach((h,k)=>{L.hasOwnProperty(h)?e[k]=L[h]:(f.push(h),K.hasOwnProperty(h)||(K[h]=[]),K[h].push(()=>\n{e[k]=L[h];++g;g===f.length&&d(e)}))});0===f.length&&d(e)},nb=b=>{for(;b.length;){var a=b.pop();b.pop()(a)}};function ob(b){for(var a=1;a<b.length;++a)if(null!==b[a]&&void 0===b[a].ca)return!0;return!1}\nfunction pb(b,a,c,d,e){var f=a.length;if(2>f)throw new N(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");var g=null!==a[1]&&null!==c,h=ob(a),k=!a[0].wa,p=f-2,m=Array(p),r=[],q=[];return Na(b,function(...u){q.length=0;r.length=g?2:1;r[0]=e;if(g){var t=a[1].$(q,this);r[1]=t}for(var w=0;w<p;++w)m[w]=a[w+2].$(q,u[w]),r.push(m[w]);u=d(...r);if(h)nb(q);else for(w=g?1:2;w<a.length;w++){var E=1===w?t:m[w-2];null!==a[w].ca&&a[w].ca(E)}t=k?a[0].W(u):void 0;return t})}\nvar qb=(b,a)=>{for(var c=[],d=0;d<b;d++)c.push(F[a+4*d>>>2>>>0]);return c},rb=b=>{b=b.trim();const a=b.indexOf(\"(\");return-1===a?b:b.slice(0,a)},sb=(b,a,c)=>{if(!(b instanceof Object))throw new N(`${c} with invalid \"this\": ${b}`);if(!(b instanceof a.U.constructor))throw new N(`${c} incompatible with \"this\" of type ${b.constructor.name}`);if(!b.T.V)throw new N(`cannot call emscripten binding method ${c} on deleted object`);return Ta(b.T.V,b.T.X.U,a.U)},tb=[],V=[0,1,,1,null,1,!0,1,!1,1];\nfunction vb(b){b>>>=0;9<b&&0===--V[b+1]&&(V[b]=void 0,tb.push(b))}\nvar W=b=>{if(!b)throw new N(`Cannot use deleted val. handle = ${b}`);return V[b]},Q=b=>{switch(b){case void 0:return 2;case null:return 4;case !0:return 6;case !1:return 8;default:const a=tb.pop()||V.length;V[a]=b;V[a+1]=1;return a}},wb={name:\"emscripten::val\",W:b=>{var a=W(b);vb(b);return a},$:(b,a)=>Q(a),da:Ya,ca:null},xb=(b,a,c)=>{switch(a){case 1:return c?function(d){return this.W(ja[d>>>0])}:function(d){return this.W(z[d>>>0])};case 2:return c?function(d){return this.W(A[d>>>1>>>0])}:function(d){return this.W(C[d>>>\n1>>>0])};case 4:return c?function(d){return this.W(D[d>>>2>>>0])}:function(d){return this.W(F[d>>>2>>>0])};default:throw new TypeError(`invalid integer width (${a}): ${b}`);}},yb=(b,a)=>{var c=L[b];if(void 0===c)throw b=`${a} has unknown type ${mb(b)}`,new N(b);return c},zb=(b,a)=>{switch(a){case 4:return function(c){return this.W(ka[c>>>2>>>0])};case 8:return function(c){return this.W(la[c>>>3>>>0])};default:throw new TypeError(`invalid float width (${a}): ${b}`);}},Ab=Object.assign({optional:!0},\nwb),X=(b,a,c)=>{var d=z;a>>>=0;if(!(0<c))return 0;var e=a;c=a+c-1;for(var f=0;f<b.length;++f){var g=b.codePointAt(f);if(127>=g){if(a>=c)break;d[a++>>>0]=g}else if(2047>=g){if(a+1>=c)break;d[a++>>>0]=192|g>>6;d[a++>>>0]=128|g&63}else if(65535>=g){if(a+2>=c)break;d[a++>>>0]=224|g>>12;d[a++>>>0]=128|g>>6&63;d[a++>>>0]=128|g&63}else{if(a+3>=c)break;d[a++>>>0]=240|g>>18;d[a++>>>0]=128|g>>12&63;d[a++>>>0]=128|g>>6&63;d[a++>>>0]=128|g&63;f++}}d[a>>>0]=0;return a-e},Bb=b=>{for(var a=0,c=0;c<b.length;++c){var d=\nb.charCodeAt(c);127>=d?a++:2047>=d?a+=2:55296<=d&&57343>=d?(a+=4,++c):a+=3}return a},Cb=\"undefined\"!=typeof TextDecoder?new TextDecoder:void 0,Db=(b,a,c,d)=>{c=a+c;if(d)return c;for(;b[a]&&!(a>=c);)++a;return a},Eb=(b=0,a)=>{var c=z;b>>>=0;a=Db(c,b,a,!0);if(16<a-b&&c.buffer&&Cb)return Cb.decode(c.subarray(b,a));for(var d=\"\";b<a;){var e=c[b++];if(e&128){var f=c[b++]&63;if(192==(e&224))d+=String.fromCharCode((e&31)<<6|f);else{var g=c[b++]&63;e=224==(e&240)?(e&15)<<12|f<<6|g:(e&7)<<18|f<<12|g<<6|c[b++]&\n63;65536>e?d+=String.fromCharCode(e):(e-=65536,d+=String.fromCharCode(55296|e>>10,56320|e&1023))}}else d+=String.fromCharCode(e)}return d},Fb=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf-16le\"):void 0,Gb=(b,a,c)=>{b>>>=1;a=Db(C,b,a/2,c);if(16<a-b&&Fb)return Fb.decode(C.subarray(b>>>0,a>>>0));for(c=\"\";b<a;++b)c+=String.fromCharCode(C[b>>>0]);return c},Hb=(b,a,c)=>{c??=2147483647;if(2>c)return 0;c-=2;var d=a;c=c<2*b.length?c/2:b.length;for(var e=0;e<c;++e)A[a>>>1>>>0]=b.charCodeAt(e),a+=2;A[a>>>\n1>>>0]=0;return a-d},Ib=b=>2*b.length,Jb=(b,a,c)=>{var d=\"\";b>>>=2;for(var e=0;!(e>=a/4);e++){var f=F[b+e>>>0];if(!f&&!c)break;d+=String.fromCodePoint(f)}return d},Kb=(b,a,c)=>{a>>>=0;c??=2147483647;if(4>c)return 0;var d=a;c=d+c-4;for(var e=0;e<b.length;++e){var f=b.codePointAt(e);65535<f&&e++;D[a>>>2>>>0]=f;a+=4;if(a+4>c)break}D[a>>>2>>>0]=0;return a-d},Lb=b=>{for(var a=0,c=0;c<b.length;++c)65535<b.codePointAt(c)&&c++,a+=4;return a},Mb=0,Nb=[],Ob=b=>{var a=Nb.length;Nb.push(b);return a},Pb=(b,a)=>\n{for(var c=Array(b),d=0;d<b;++d)c[d]=yb(F[a+4*d>>>2>>>0],`parameter ${d}`);return c},Qb={},Rb=b=>{var a=Qb[b];return void 0===a?J(b):a},Y={},Sb=b=>{if(!(b instanceof va||\"unwind\"==b))throw b;},Tb=b=>{y=b;Aa||0<Mb||(l.onExit?.(b),x=!0);throw new va(b);},Ub=b=>{if(!x)try{if(b(),!(Aa||0<Mb))try{y=b=y,Tb(b)}catch(a){Sb(a)}}catch(a){Sb(a)}},Vb={},Xb=()=>{if(!Wb){var b={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.language||\"C\").replace(\"-\",\n\"_\")+\".UTF-8\",_:aa||\"./this.program\"},a;for(a in Vb)void 0===Vb[a]?delete b[a]:b[a]=Vb[a];var c=[];for(a in b)c.push(`${a}=${b[a]}`);Wb=c}return Wb},Wb,Yb=()=>b=>crypto.getRandomValues(b),Zb=b=>{(Zb=Yb())(b)};\n(()=>{let b=Ma.prototype;Object.assign(b,{isAliasOf:function(c){if(!(this instanceof Ma&&c instanceof Ma))return!1;var d=this.T.X.U,e=this.T.V;c.T=c.T;var f=c.T.X.U;for(c=c.T.V;d.aa;)e=d.ka(e),d=d.aa;for(;f.aa;)c=f.ka(c),f=f.aa;return d===f&&e===c},clone:function(){this.T.V||Ia(this);if(this.T.ja)return this.T.count.value+=1,this;var c=P,d=Object,e=d.create,f=Object.getPrototypeOf(this),g=this.T;c=c(e.call(d,f,{T:{value:{count:g.count,ia:g.ia,ja:g.ja,V:g.V,X:g.X,Z:g.Z,ba:g.ba}}}));c.T.count.value+=\n1;c.T.ia=!1;return c},[\"delete\"](){this.T.V||Ia(this);if(this.T.ia&&!this.T.ja)throw new N(\"Object already scheduled for deletion\");Ka(this);var c=this.T;--c.count.value;0===c.count.value&&(c.Z?c.ba.fa(c.Z):c.X.U.fa(c.V));this.T.ja||(this.T.Z=void 0,this.T.V=void 0)},isDeleted:function(){return!this.T.V},deleteLater:function(){this.T.V||Ia(this);if(this.T.ia&&!this.T.ja)throw new N(\"Object already scheduled for deletion\");La.push(this);this.T.ia=!0;return this}});const a=Symbol.dispose;a&&(b[a]=b[\"delete\"])})();\nObject.assign(db.prototype,{ua(b){this.qa&&(b=this.qa(b));return b},pa(b){this.fa?.(b)},da:Ya,W:function(b){function a(){return this.na?cb(this.U.ea,{X:this.xa,V:c,ba:this,Z:b}):cb(this.U.ea,{X:this,V:b})}var c=this.ua(b);if(!c)return this.pa(b),null;var d=ab(this.U,c);if(void 0!==d){if(0===d.T.count.value)return d.T.V=c,d.T.Z=b,d.clone();d=d.clone();this.pa(b);return d}d=this.U.ta(c);d=Oa[d];if(!d)return a.call(this);d=this.ma?d.ra:d.pointerType;var e=Za(c,this.U,d.U);return null===e?a.call(this):\nthis.na?cb(d.U.ea,{X:d,V:e,ba:this,Z:b}):cb(d.U.ea,{X:d,V:e})}});l.noExitRuntime&&(Aa=l.noExitRuntime);l.printErr&&(n=l.printErr);l.wasmBinary&&(v=l.wasmBinary);l.thisProgram&&(aa=l.thisProgram);\nvar $b,lb,ac,bc,S,cc={a:function(b,a,c){b>>>=0;var d=new Ba(b);F[d.V+16>>>2>>>0]=0;F[d.V+4>>>2>>>0]=a>>>0;F[d.V+8>>>2>>>0]=c>>>0;Ca=b;Da++;throw Ca;},K:()=>qa(\"\"),v:function(b,a,c,d,e){b>>>=0;c>>>=0;a=J(a>>>0);d=0n===d;let f=g=>g;if(d){const g=8*c;f=h=>BigInt.asUintN(g,h);e=f(e)}O(b,{name:a,W:f,$:(g,h)=>{\"number\"==typeof h&&(h=BigInt(h));return h},da:Ha(a,c,!d),ca:null})},H:function(b,a,c,d){a=J(a>>>0);O(b>>>0,{name:a,W:function(e){return!!e},$:function(e,f){return f?c:d},da:function(e){return this.W(z[e>>>\n0])},ca:null})},g:function(b,a,c,d,e,f,g,h,k,p,m,r,q){b>>>=0;a>>>=0;c>>>=0;d>>>=0;f>>>=0;g>>>=0;h>>>=0;k>>>=0;p>>>=0;m>>>=0;r>>>=0;q>>>=0;m=J(m);f=R(e>>>0,f);h&&=R(g,h);p&&=R(k,p);q=R(r,q);var u=Ra(m);Qa(u,function(){T(`Cannot construct ${m} due to unbound types`,[d])});U([b,a,c],d?[d]:[],t=>{t=t[0];if(d){var w=t.U;var E=w.ea}else E=Ma.prototype;t=Na(m,function(...Ga){if(Object.getPrototypeOf(this)!==M)throw new N(`Use 'new' to construct ${m}`);if(void 0===B.ha)throw new N(`${m} has no accessible constructor`);\nvar ub=B.ha[Ga.length];if(void 0===ub)throw new N(`Tried to invoke ctor of ${m} with invalid number of parameters (${Ga.length}) - expected (${Object.keys(B.ha).toString()}) parameters instead!`);return ub.apply(this,Ga)});var M=Object.create(E,{constructor:{value:t}});t.prototype=M;var B=new Sa(m,t,M,q,w,f,h,p);if(B.aa){var H;(H=B.aa).la??(H.la=[]);B.aa.la.push(B)}w=new db(m,B,!0,!1,!1);H=new db(m+\"*\",B,!1,!1,!1);E=new db(m+\" const*\",B,!1,!0,!1);Oa[b]={pointerType:H,ra:E};eb(u,t);return[w,H,E]})},\nq:function(b,a,c,d,e,f,g){b>>>=0;a>>>=0;e>>>=0;f>>>=0;g>>>=0;var h=qb(c,d>>>0);a=J(a);a=rb(a);f=R(e,f);U([],[b],k=>{function p(){T(`Cannot call ${m} due to unbound types`,h)}k=k[0];var m=`${k.name}.${a}`;a.startsWith(\"@@\")&&(a=Symbol[a.substring(2)]);var r=k.U.constructor;void 0===r[a]?(p.ga=c-1,r[a]=p):(Pa(r,a,m),r[a].Y[c-1]=p);U([],h,q=>{q=pb(m,[q[0],null].concat(q.slice(1)),null,f,g);void 0===r[a].Y?(q.ga=c-1,r[a]=q):r[a].Y[c-1]=q;if(k.U.la)for(const u of k.U.la)u.constructor.hasOwnProperty(a)||\n(u.constructor[a]=q);return[]});return[]})},w:function(b,a,c,d,e,f,g,h){b>>>=0;a>>>=0;c>>>=0;d>>>=0;f>>>=0;g>>>=0;h>>>=0;a=J(a);f=R(e>>>0,f);U([],[b],k=>{k=k[0];var p=`${k.name}.${a}`,m={get(){T(`Cannot access ${p} due to unbound types`,[c])},enumerable:!0,configurable:!0};m.set=h?()=>{T(`Cannot access ${p} due to unbound types`,[c])}:()=>{throw new N(`${p} is a read-only property`);};Object.defineProperty(k.U.constructor,a,m);U([],[c],r=>{r=r[0];var q={get(){return r.W(f(d))},enumerable:!0};h&&(h=\nR(g,h),q.set=u=>{var t=[];h(d,r.$(t,u));nb(t)});Object.defineProperty(k.U.constructor,a,q);return[]});return[]})},h:function(b,a,c,d,e,f){b>>>=0;d>>>=0;e>>>=0;f>>>=0;var g=qb(a,c>>>0);e=R(d,e);U([],[b],h=>{h=h[0];var k=`constructor ${h.name}`;void 0===h.U.ha&&(h.U.ha=[]);if(void 0!==h.U.ha[a-1])throw new N(`Cannot register multiple constructors with identical number of parameters (${a-1}) for class '${h.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);\nh.U.ha[a-1]=()=>{T(`Cannot construct ${h.name} due to unbound types`,g)};U([],g,p=>{p.splice(1,0,null);h.U.ha[a-1]=pb(k,p,null,e,f);return[]});return[]})},b:function(b,a,c,d,e,f,g,h){b>>>=0;a>>>=0;e>>>=0;f>>>=0;g>>>=0;var k=qb(c,d>>>0);a=J(a);a=rb(a);f=R(e,f);U([],[b],p=>{function m(){T(`Cannot call ${r} due to unbound types`,k)}p=p[0];var r=`${p.name}.${a}`;a.startsWith(\"@@\")&&(a=Symbol[a.substring(2)]);h&&p.U.ya.push(a);var q=p.U.ea,u=q[a];void 0===u||void 0===u.Y&&u.className!==p.name&&u.ga===\nc-2?(m.ga=c-2,m.className=p.name,q[a]=m):(Pa(q,a,r),q[a].Y[c-2]=m);U([],k,t=>{t=pb(r,t,p,f,g);void 0===q[a].Y?(t.ga=c-2,q[a]=t):q[a].Y[c-2]=t;return[]});return[]})},r:function(b,a,c,d,e,f,g,h,k,p){b>>>=0;a>>>=0;c>>>=0;e>>>=0;f>>>=0;g>>>=0;h>>>=0;k>>>=0;p>>>=0;a=J(a);e=R(d>>>0,e);U([],[b],m=>{m=m[0];var r=`${m.name}.${a}`,q={get(){T(`Cannot access ${r} due to unbound types`,[c,g])},enumerable:!0,configurable:!0};q.set=k?()=>T(`Cannot access ${r} due to unbound types`,[c,g]):()=>{throw new N(r+\" is a read-only property\");\n};Object.defineProperty(m.U.ea,a,q);U([],k?[c,g]:[c],u=>{var t=u[0],w={get(){var M=sb(this,m,r+\" getter\");return t.W(e(f,M))},enumerable:!0};if(k){k=R(h,k);var E=u[1];w.set=function(M){var B=sb(this,m,r+\" setter\"),H=[];k(p,B,E.$(H,M));nb(H)}}Object.defineProperty(m.U.ea,a,w);return[]});return[]})},F:function(b){return O(b>>>0,wb)},t:function(b,a,c,d){function e(){}a=J(a>>>0);e.values={};O(b>>>0,{name:a,constructor:e,W:function(f){return this.constructor.values[f]},$:(f,g)=>g.value,da:xb(a,c>>>0,d),\nca:null});Qa(a,e)},n:function(b,a,c){a>>>=0;var d=yb(b>>>0,\"enum\");a=J(a);b=d.constructor;d=Object.create(d.constructor.prototype,{value:{value:c},constructor:{value:Na(`${d.name}_${a}`,function(){})}});b.values[c]=d;b[a]=d},u:function(b,a,c){a=J(a>>>0);O(b>>>0,{name:a,W:d=>d,$:(d,e)=>e,da:zb(a,c>>>0),ca:null})},m:function(b,a,c,d,e,f){b>>>=0;d>>>=0;e>>>=0;f>>>=0;var g=qb(a,c>>>0);b=J(b);b=rb(b);e=R(d,e);Qa(b,function(){T(`Cannot call ${b} due to unbound types`,g)},a-1);U([],g,h=>{eb(b,pb(b,[h[0],\nnull].concat(h.slice(1)),null,e,f),a-1);return[]})},p:function(b,a,c,d,e){b>>>=0;c>>>=0;a=J(a>>>0);let f=h=>h;if(0===d){var g=32-8*c;f=h=>h<<g>>>g;e=f(e)}O(b,{name:a,W:f,$:(h,k)=>k,da:Ha(a,c,0!==d),ca:null})},l:function(b,a,c){function d(f){return new e(ja.buffer,F[f+4>>>2>>>0],F[f>>>2>>>0])}var e=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][a];c=J(c>>>0);O(b>>>0,{name:c,W:d,da:d},{va:!0})},o:function(b){O(b>>>0,Ab)},G:function(b,\na){a=J(a>>>0);O(b>>>0,{name:a,W(c){var d=(d=c+4>>>0)?Eb(d,F[c>>>2>>>0]):\"\";S(c);return d},$(c,d){d instanceof ArrayBuffer&&(d=new Uint8Array(d));var e=\"string\"==typeof d;if(!(e||ArrayBuffer.isView(d)&&1==d.BYTES_PER_ELEMENT))throw new N(\"Cannot pass non-string to std::string\");var f=e?Bb(d):d.length;var g=bc(4+f+1),h=g+4;F[g>>>2>>>0]=f;e?X(d,h,f+1):z.set(d,h>>>0);null!==c&&c.push(S,g);return g},da:Ya,ca(c){S(c)}})},s:function(b,a,c){a>>>=0;c>>>=0;c=J(c);if(2===a){var d=Gb;var e=Hb;var f=Ib}else d=\nJb,e=Kb,f=Lb;O(b>>>0,{name:c,W:g=>{var h=d(g+4,F[g>>>2>>>0]*a,!0);S(g);return h},$:(g,h)=>{if(\"string\"!=typeof h)throw new N(`Cannot pass non-string to C++ string type ${c}`);var k=f(h),p=bc(4+k+a);F[p>>>2>>>0]=k/a;e(h,p+4,k+a);null!==g&&g.push(S,p);return p},da:Ya,ca(g){S(g)}})},I:function(b,a){a=J(a>>>0);O(b>>>0,{wa:!0,name:a,W:()=>{},$:()=>{}})},B:()=>{Aa=!1;Mb=0},c:function(b,a,c){var [d,...e]=Pb(b,a>>>0),f=d.$.bind(d),g=e.map(k=>k.da.bind(k));b--;var h=Array(b);a=`methodCaller<(${e.map(k=>k.name)}) => ${d.name}>`;\nreturn Ob(Na(a,(k,p,m,r)=>{for(var q=0,u=0;u<b;++u)h[u]=g[u](r+q),q+=8;switch(c){case 0:var t=W(k).apply(null,h);break;case 2:t=Reflect.construct(W(k),h);break;case 3:t=h[0];break;case 1:t=W(k)[Rb(p)](...h)}k=[];t=f(k,t);k.length&&(F[m>>>2>>>0]=Q(k));return t}))},f:vb,j:function(b,a){a>>>=0;b=W(b>>>0);a=W(a);return Q(b[a])},i:function(b){b>>>=0;9<b&&(V[b+1]+=1)},e:function(b,a,c,d,e){return Nb[b>>>0](a>>>0,c>>>0,d>>>0,e>>>0)},D:function(){return Q([])},k:function(b){return Q(Rb(b>>>0))},d:function(b){b>>>=\n0;var a=W(b);nb(a);vb(b)},C:(b,a)=>{Y[b]&&(clearTimeout(Y[b].id),delete Y[b]);if(!a)return 0;var c=setTimeout(()=>{delete Y[b];Ub(()=>ac(b,performance.now()))},a);Y[b]={id:c,Ca:a};return 0},y:function(b,a,c,d){c>>>=0;d>>>=0;var e=(new Date).getFullYear(),f=(new Date(e,0,1)).getTimezoneOffset();e=(new Date(e,6,1)).getTimezoneOffset();F[b>>>0>>>2>>>0]=60*Math.max(f,e);D[a>>>0>>>2>>>0]=Number(f!=e);a=g=>{var h=Math.abs(g);return`UTC${0<=g?\"-\":\"+\"}${String(Math.floor(h/60)).padStart(2,\"0\")}${String(h%\n60).padStart(2,\"0\")}`};b=a(f);a=a(e);e<f?(X(b,c,17),X(a,d,17)):(X(b,d,17),X(a,c,17))},J:function(b){b>>>=0;var a=z.length;if(4294901760<b)return!1;for(var c=1;4>=c;c*=2){var d=a*(1+.2/c);d=Math.min(d,b+100663296);a:{d=(Math.min(4294901760,65536*Math.ceil(Math.max(b,d)/65536))-ia.buffer.byteLength+65535)/65536|0;try{ia.grow(d);pa();var e=1;break a}catch(f){}e=void 0}if(e)return!0}return!1},z:function(b,a){b>>>=0;a>>>=0;var c=0,d=0,e;for(e of Xb()){var f=a+c;F[b+d>>>2>>>0]=f;c+=X(e,f,Infinity)+1;d+=\n4}return 0},E:function(b,a){b>>>=0;a>>>=0;var c=Xb();F[b>>>2>>>0]=c.length;b=0;for(var d of c)b+=Bb(d)+1;F[a>>>2>>>0]=b;return 0},A:Tb,x:function(b,a){b>>>=0;Zb(z.subarray(b>>>0,b+(a>>>0)>>>0));return 0}},Z=await (async function(){function b(c){Z=c.exports;Z=dc();ia=Z.L;pa();gb=Z.S;c=Z;l._main=$b=c.N;lb=c.O;ac=c.P;bc=c.Q;S=c.R;G--;l.monitorRunDependencies?.(G);0==G&&I&&(c=I,I=null,c());return Z}G++;l.monitorRunDependencies?.(G);var a={a:cc};if(l.instantiateWasm)return new Promise(c=>{l.instantiateWasm(a,\n(d,e)=>{c(b(d,e))})});ra??=l.locateFile?l.locateFile?l.locateFile(\"seal_allows_wasm_cf_worker.wasm\",ca):ca+\"seal_allows_wasm_cf_worker.wasm\":(new URL(\"seal_allows_wasm_cf_worker.wasm\",import.meta.url)).href;return b((await ua(a)).instance)}());function dc(){var b=Z;b=Object.assign({},b);var a=c=>d=>c(d)>>>0;b.O=a(b.O);b.Q=a(b.Q);b._emscripten_stack_alloc=a(b._emscripten_stack_alloc);b.emscripten_stack_get_current=(c=>()=>c()>>>0)(b.emscripten_stack_get_current);return b}\nfunction ec(){function b(){l.calledRun=!0;if(!x){oa=!0;Z.M();fa?.(l);l.onRuntimeInitialized?.();if(!l.noInitialRun){var a=$b;try{var c=a(0,0);y=c;Tb(c)}catch(d){Sb(d)}}if(l.postRun)for(\"function\"==typeof l.postRun&&(l.postRun=[l.postRun]);l.postRun.length;)a=l.postRun.shift(),xa.push(a);wa(xa)}}if(0<G)I=ec;else{if(l.preRun)for(\"function\"==typeof l.preRun&&(l.preRun=[l.preRun]);l.preRun.length;)za();wa(ya);0<G?I=ec:l.setStatus?(l.setStatus(\"Running...\"),setTimeout(()=>{setTimeout(()=>l.setStatus(\"\"),\n1);b()},1)):b()}}if(l.preInit)for(\"function\"==typeof l.preInit&&(l.preInit=[l.preInit]);0<l.preInit.length;)l.preInit.shift()();ec();oa?moduleRtn=l:moduleRtn=new Promise((b,a)=>{fa=b;ha=a});\n;return moduleRtn}export default Module;\n","export const INSTANCE_DELETED = 'Instance was deleted'\nexport const UNSUPPORTED_VECTOR_TYPE = 'Unsupported vector type'\nexport const UNSUPPORTED_BITSIZES_TYPE =\n  'Unsupported argument type! `bitSizes` must be an Int32Array'\nexport const UNSUPPORTED_BATCH_ENCODE_ARRAY_TYPE =\n  'Unsupported array type! `array` must be of type Int32Array, Uint32Array, BigInt64Array, or BigUint64Array.'\nexport const UNSUPPORTED_CKKS_ENCODE_ARRAY_TYPE =\n  'Unsupported array type! `array` must be of type Float64Array.'\nexport const INVALID_PLAIN_CONSRUCTOR_OPTIONS =\n  'Must specify a (coeffCount), (coeffCount, capacity)'\nexport const INVALID_CIPHER_CONSTRUCTOR_OPTIONS =\n  'Must specify a (context), (context, parmsId), or (context, parmsId, sizeCapacity)'\n","interface DisposableResource {\n  delete: () => void\n}\n\ninterface RegistryEntry<T> {\n  resource: T\n}\n\nclass ResourceRegistry {\n  private registry: FinalizationRegistry<RegistryEntry<any>> | undefined =\n    undefined\n\n  constructor() {\n    if (typeof FinalizationRegistry !== 'undefined') {\n      this.registry = new FinalizationRegistry<RegistryEntry<any>>(entry => {\n        try {\n          entry.resource.delete()\n        } catch (error) {\n          // Ignore duplicate calls (manual delete + finalizer)\n        }\n      })\n    }\n  }\n\n  register<T extends DisposableResource>(target: object, resource: T) {\n    if (!this.registry) {\n      return { unregister: () => {}, reregister: () => {} }\n    }\n\n    const token = target\n    const entry: RegistryEntry<T> = { resource }\n\n    this.registry.register(target, entry, token)\n\n    return {\n      unregister: () => {\n        this.registry?.unregister(token)\n      },\n\n      reregister: (newResource: T) => {\n        this.registry?.unregister(token)\n        const newEntry: RegistryEntry<T> = {\n          resource: newResource\n        }\n        this.registry?.register(target, newEntry, token)\n      }\n    }\n  }\n}\n\nconst globalRegistry = new ResourceRegistry()\n\nexport function autoFinalize<T extends DisposableResource>(\n  target: object,\n  resource: T\n) {\n  return globalRegistry.register(target, resource)\n}\n","import { UNSUPPORTED_BATCH_ENCODE_ARRAY_TYPE } from './constants'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { MemoryPoolHandle } from './memory-pool-handle'\nimport { PlainText, PlainTextConstructorOptions } from './plain-text'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport interface BatchEncoderDependencyOptions {\n  readonly Exception: Exception\n  readonly MemoryPoolHandle: MemoryPoolHandle\n  readonly PlainText: PlainTextConstructorOptions\n  readonly Vector: VectorConstructorOptions\n}\n\nexport interface BatchEncoderDependencies {\n  ({\n    Exception,\n    MemoryPoolHandle,\n    PlainText,\n    Vector\n  }: BatchEncoderDependencyOptions): BatchEncoderConstructorOptions\n}\n\nexport interface BatchEncoderConstructorOptions {\n  (context: Context): BatchEncoder\n}\n\nexport type BatchEncoderTypes =\n  | Int32Array\n  | Uint32Array\n  | BigInt64Array\n  | BigUint64Array\n\nexport interface BatchEncoder {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly encode: (\n    array: BatchEncoderTypes,\n    plainText?: PlainText\n  ) => PlainText | void\n  readonly decode: (\n    plainText: PlainText,\n    signed?: boolean,\n    pool?: MemoryPoolHandle\n  ) => Int32Array | Uint32Array\n  readonly decodeBigInt: (\n    plainText: PlainText,\n    signed?: boolean,\n    pool?: MemoryPoolHandle\n  ) => BigInt64Array | BigUint64Array\n  readonly slotCount: number\n}\n\nconst BatchEncoderConstructor =\n  (library: Library): BatchEncoderDependencies =>\n  ({\n    Exception,\n    MemoryPoolHandle,\n    PlainText,\n    Vector\n  }: BatchEncoderDependencyOptions): BatchEncoderConstructorOptions =>\n  (context): BatchEncoder => {\n    const Constructor = library.BatchEncoder\n    let _instance: Instance\n    try {\n      _instance = new Constructor(context.instance)\n    } catch (e) {\n      throw Exception.safe(e as SealError)\n    }\n    /**\n     * @implements BatchEncoder\n     */\n\n    /**\n     * @interface BatchEncoder\n     */\n    const self: BatchEncoder = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name BatchEncoder#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name BatchEncoder#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        self.delete()\n        _instance = instance\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name BatchEncoder#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Creates a PlainText from a given matrix. This function \"batches\" a given matrix\n       * of either signed or unsigned integers modulo the PlainText modulus into a PlainText element, and stores\n       * the result in the destination parameter. The input array must have size at most equal\n       * to the degree of the polynomial modulus. The first half of the elements represent the\n       * first row of the matrix, and the second half represent the second row. The numbers\n       * in the matrix can be at most equal to the PlainText modulus for it to represent\n       * a valid PlainText.\n       *\n       * If the destination PlainText overlaps the input values in memory, the behavior of\n       * this function is undefined.\n       *\n       * @function\n       * @name BatchEncoder#encode\n       * @param {Int32Array|Uint32Array|BigInt64Array|BigUint64Array} array Data to encode\n       * @param {PlainText} [plainText=null] Destination to store the encoded result\n       * @returns {PlainText|void} A new PlainText holding the encoded data or void if one was provided\n       * @example\n       * import SEAL from 'node-seal'\n       * const seal = await SEAL()\n       * ...\n       * const batchEncoder = seal.BatchEncoder(context)\n       *\n       * const plainText = batchEncoder.encode(Int32Array.from([1, -2, 3]))\n       */\n      encode(\n        array: Int32Array | Uint32Array | BigInt64Array | BigUint64Array,\n        plainText?: PlainText\n      ): PlainText | void {\n        try {\n          if (array.constructor === Int32Array) {\n            if (plainText) {\n              _instance.encode(array, plainText.instance, 'INT32')\n              return\n            }\n            const plain = PlainText()\n            _instance.encode(array, plain.instance, 'INT32')\n            return plain\n          }\n\n          if (array.constructor === Uint32Array) {\n            if (plainText) {\n              _instance.encode(array, plainText.instance, 'UINT32')\n              return\n            }\n            const plain = PlainText()\n            _instance.encode(array, plain.instance, 'UINT32')\n            return plain\n          }\n\n          if (array.constructor === BigInt64Array) {\n            // When embind supports BigInt64Arrays we can remove this hack\n            const stringArray = array.toString().split(',')\n            if (plainText) {\n              _instance.encode(stringArray, plainText.instance, 'INT64')\n              return\n            }\n            const plain = PlainText()\n            _instance.encode(stringArray, plain.instance, 'INT64')\n            return plain\n          }\n\n          if (array.constructor === BigUint64Array) {\n            // When embind supports BigInt64Arrays we can remove this hack\n            const stringArray = array.toString().split(',')\n            if (plainText) {\n              _instance.encode(stringArray, plainText.instance, 'UINT64')\n              return\n            }\n            const plain = PlainText()\n            _instance.encode(stringArray, plain.instance, 'UINT64')\n            return plain\n          }\n\n          throw new Error(UNSUPPORTED_BATCH_ENCODE_ARRAY_TYPE)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Inverse of encode. This function \"unbatches\" a given PlainText into a matrix\n       * of signed or unsigned integers modulo the PlainText modulus, and stores the result in the destination\n       * parameter. The input PlainText must have degrees less than the polynomial modulus,\n       * and coefficients less than the PlainText modulus, i.e. it must be a valid PlainText\n       * for the encryption parameters. Dynamic memory allocations in the process are\n       * allocated from the memory pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name BatchEncoder#decode\n       * @param {PlainText} plainText Data to decode\n       * @param {boolean} [signed=true] By default, decode as an Int32Array. If false, decode as an Uint32Array\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}]\n       * @returns {Int32Array|Uint32Array} TypedArray containing the decoded data\n       * @example\n       * import SEAL from 'node-seal'\n       * const seal = await SEAL()\n       * ...\n       * const batchEncoder = seal.BatchEncoder(context)\n       *\n       * const plainText = batchEncoder.encode(Int32Array.from([1, -2, 3]))\n       * const plainTextU = batchEncoder.encode(Uint32Array.from([1, 2, 3]))\n       *\n       * const result = batchEncoder.decode(plainText)\n       * const resultU = batchEncoder.decode(plainTextU, false) // To decode as an Uint32Array\n       */\n      decode(\n        plainText: PlainText,\n        signed = true,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): Int32Array | Uint32Array {\n        try {\n          if (signed) {\n            const tempVect = Vector()\n            const instance = _instance.decodeInt32(plainText.instance, pool)\n            tempVect.unsafeInject(instance)\n            tempVect.setType('Int32Array')\n            const tempArr = tempVect.toArray() as Int32Array\n            tempVect.delete()\n            return tempArr\n          }\n          const tempVect = Vector()\n          const instance = _instance.decodeUint32(plainText.instance, pool)\n          tempVect.unsafeInject(instance)\n          tempVect.setType('Uint32Array')\n          const tempArr = tempVect.toArray() as Uint32Array\n          tempVect.delete()\n          return tempArr\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Performs the same function as the 32-bit decode, but supports true\n       * 64-bit values encapsulated by a BigInt.\n       *\n       * There's no official support for sending a BigInt64Array/BigUint64Array\n       * from C++ to JS, therefore this function uses string conversion to\n       * marshal data which is noticably slower. Use this function if you\n       * absolutely need to marshal values larger than 32 bits.\n       *\n       * @see {@link BatchEncoder#decode} for more information about decode.\n       * @function\n       * @name BatchEncoder#decodeBigInt\n       * @param {PlainText} plainText Data to decode\n       * @param {boolean} [signed=true] By default, decode as an BigInt64Array. If false, decode as an BigUint64Array\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}]\n       * @returns {BigInt64Array|BigUint64Array} TypedArray containing the decoded data\n       * @example\n       * import SEAL from 'node-seal'\n       * const seal = await SEAL()\n       * ...\n       * const batchEncoder = seal.BatchEncoder(context)\n       *\n       * const plainText = batchEncoder.encode(BigInt64Array.from([1n, -2n, 3n]))\n       * const plainTextU = batchEncoder.encode(BigUint64Array.from([1n, 2n, 3n]))\n       *\n       * const result = batchEncoder.decodeBigInt(plainText)\n       * const resultU = batchEncoder.decodeBigInt(plainTextU, false) // To decode as an BigUint64Array\n       */\n      decodeBigInt(\n        plainText: PlainText,\n        signed = true,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): BigInt64Array | BigUint64Array {\n        try {\n          if (signed) {\n            const instance = _instance.decodeBigInt(\n              plainText.instance,\n              true,\n              pool\n            )\n            return BigInt64Array.from(instance)\n          }\n          const instance = _instance.decodeBigInt(\n            plainText.instance,\n            false,\n            pool\n          )\n          return BigUint64Array.from(instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * The total number of batching slots available to hold data\n       *\n       * @readonly\n       * @name BatchEncoder#slotCount\n       * @type {number}\n       */\n      get slotCount() {\n        return _instance.slotCount()\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const BatchEncoderInit = ({\n  loader\n}: LoaderOptions): BatchEncoderDependencies => {\n  const library: Library = loader.library\n  return BatchEncoderConstructor(library)\n}\n","import { ComprModeType } from './compr-mode-type'\nimport { INVALID_CIPHER_CONSTRUCTOR_OPTIONS } from './constants'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { MemoryPoolHandle } from './memory-pool-handle'\nimport { ParmsIdType, ParmsIdTypeConstructorOptions } from './parms-id-type'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport interface CipherTextDependencyOptions {\n  readonly Exception: Exception\n  readonly ComprModeType: ComprModeType\n  readonly ParmsIdType: ParmsIdTypeConstructorOptions\n  readonly MemoryPoolHandle: MemoryPoolHandle\n  readonly Vector: VectorConstructorOptions\n}\n\nexport interface CipherTextConstructorParams {\n  context?: Context\n  parmsId?: ParmsIdType\n  sizeCapacity?: number\n  pool?: MemoryPoolHandle\n}\n\nexport type CipherTextDependencies = (\n  deps: CipherTextDependencyOptions\n) => CipherTextConstructorOptions\n\nexport type CipherTextConstructorOptions = (\n  params?: CipherTextConstructorParams\n) => CipherText\n\nexport interface CipherText {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly reserve: (context: Context, capacity: number) => void\n  readonly resize: (size: number) => void\n  readonly release: () => void\n  readonly coeffModulusSize: number\n  readonly polyModulusDegree: number\n  readonly size: number\n  readonly sizeCapacity: number\n  readonly isTransparent: boolean\n  readonly isNttForm: boolean\n  readonly parmsId: ParmsIdType\n  readonly scale: number\n  readonly setScale: (scale: number) => void\n  readonly pool: MemoryPoolHandle\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n  readonly load: (context: Context, encoded: string) => void\n  readonly loadArray: (context: Context, array: Uint8Array) => void\n  readonly copy: (cipher: CipherText) => void\n  readonly clone: () => CipherText\n  readonly move: (cipher: CipherText) => void\n}\n\nconst CipherTextConstructor =\n  (library: Library): CipherTextDependencies =>\n  ({\n    Exception,\n    ComprModeType,\n    ParmsIdType,\n    MemoryPoolHandle,\n    Vector\n  }: CipherTextDependencyOptions): CipherTextConstructorOptions =>\n  (params: CipherTextConstructorParams = {}): CipherText => {\n    // Static methods\n    const Constructor = library.Ciphertext\n    let _instance = construct(params)\n\n    function construct(constructParams: CipherTextConstructorParams = {}) {\n      const {\n        context,\n        parmsId,\n        sizeCapacity,\n        pool = MemoryPoolHandle.global\n      } = constructParams\n\n      try {\n        if (!context && !parmsId && sizeCapacity === undefined) {\n          return new Constructor(pool)\n        } else if (context && !parmsId && sizeCapacity === undefined) {\n          return new Constructor(context.instance, pool)\n        } else if (context && parmsId && sizeCapacity === undefined) {\n          return new Constructor(context.instance, parmsId.instance, pool)\n        } else if (context && parmsId && sizeCapacity !== undefined) {\n          return new Constructor(\n            context.instance,\n            parmsId.instance,\n            sizeCapacity,\n            pool\n          )\n        } else {\n          throw new Error(INVALID_CIPHER_CONSTRUCTOR_OPTIONS)\n        }\n      } catch (e) {\n        throw Exception.safe(e as SealError)\n      }\n    }\n    /**\n     * @implements CipherText\n     */\n\n    /**\n     * @interface CipherText\n     */\n    const self: CipherText = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name CipherText#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name CipherText#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        self.delete()\n        _instance = instance\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name CipherText#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Allocates enough memory to accommodate the backing array of a ciphertext\n       * with given capacity. In addition to the capacity, the allocation size is\n       * determined by the current encryption parameters.\n       *\n       * @function\n       * @name CipherText#reserve\n       * @param {Context} context The SEAL Context\n       * @param {number} capacity The capacity to reserve\n       */\n      reserve(context: Context, capacity: number) {\n        try {\n          return _instance.reserve(context.instance, capacity)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Resizes the CipherText to given size, reallocating if the capacity\n       * of the CipherText is too small.\n       *\n       * This function is mainly intended for internal use and is called\n       * automatically by functions such as Evaluator.multiply and\n       * Evaluator.relinearize. A normal user should never have a reason\n       * to manually resize a CipherText.\n       *\n       * @function\n       * @name CipherText#resize\n       * @param {number} size The new size\n       */\n      resize(size: number) {\n        try {\n          return _instance.resize(size)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Resets the CipherText. This function releases any memory allocated\n       * by the CipherText, returning it to the memory pool. It also sets all\n       * encryption parameter specific size information to zero.\n       *\n       * @function\n       * @name CipherText#release\n       */\n      release() {\n        _instance.release()\n      },\n\n      /**\n       * The number of primes in the coefficient modulus of the\n       * associated encryption parameters. This directly affects the\n       * allocation size of the CipherText.\n       *\n       * @readonly\n       * @name CipherText#coeffModulusSize\n       * @type {number}\n       */\n      get coeffModulusSize() {\n        return _instance.coeffModulusSize()\n      },\n\n      /**\n       * The degree of the polynomial modulus of the associated\n       * encryption parameters. This directly affects the allocation size\n       * of the CipherText.\n       *\n       * @readonly\n       * @name CipherText#polyModulusDegree\n       * @type {number}\n       */\n      get polyModulusDegree() {\n        return _instance.polyModulusDegree()\n      },\n\n      /**\n       * The size of the CipherText.\n       *\n       * @readonly\n       * @name CipherText#size\n       * @type {number}\n       */\n      get size() {\n        return _instance.size()\n      },\n\n      /**\n       * The capacity of the allocation. This means the largest size\n       * of the CipherText that can be stored in the current allocation with\n       * the current encryption parameters.\n       *\n       * @readonly\n       * @name CipherText#sizeCapacity\n       * @type {number}\n       */\n      get sizeCapacity() {\n        return _instance.sizeCapacity()\n      },\n\n      /**\n       * Whether the current CipherText is transparent, i.e. does not require\n       * a secret key to decrypt. In typical security models such transparent\n       * CipherTexts would not be considered to be valid. Starting from the second\n       * polynomial in the current CipherText, this function returns true if all\n       * following coefficients are identically zero. Otherwise, returns false.\n       *\n       * @readonly\n       * @name CipherText#isTransparent\n       * @type {boolean}\n       */\n      get isTransparent() {\n        return _instance.isTransparent()\n      },\n\n      /**\n       * Whether the CipherText is in NTT form.\n       *\n       * @readonly\n       * @name CipherText#isNttForm\n       * @type {boolean}\n       */\n      get isNttForm() {\n        return _instance.isNttForm()\n      },\n\n      /**\n       * The reference to parmsId.\n       * @see {@link EncryptionParameters} for more information about parmsId.\n       *\n       * @readonly\n       * @name CipherText#parmsId\n       * @type {ParmsIdType}\n       */\n      get parmsId() {\n        const parms = ParmsIdType()\n        parms.inject(_instance.parmsId())\n        return parms\n      },\n\n      /**\n       * The reference to the scale. This is only needed when using the\n       * CKKS encryption scheme. The user should have little or no reason to ever\n       * change the scale by hand.\n       *\n       * @readonly\n       * @name CipherText#scale\n       * @type {number}\n       */\n      get scale() {\n        return _instance.scale()\n      },\n\n      /**\n       * Sets the CipherText scale. This is only needed when using the\n       * CKKS encryption scheme. The user should have little or no reason to ever\n       * change the scale by hand.\n       *\n       * @function\n       * @name CipherText#setScale\n       * @param {number} scale The scale to set\n       */\n      setScale(scale: number) {\n        _instance.setScale(scale)\n      },\n\n      /**\n       * The currently used MemoryPoolHandle.\n       *\n       * @readonly\n       * @name CipherText#pool\n       * @type {MemoryPoolHandle}\n       */\n      get pool() {\n        return _instance.pool()\n      },\n\n      /**\n       * Save the CipherText to a base64 string\n       *\n       * @function\n       * @name CipherText#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} Base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        return _instance.saveToString(compression)\n      },\n\n      /**\n       * Save the CipherText as a binary Uint8Array\n       *\n       * @function\n       * @name CipherText#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the CipherText in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Load a CipherText from a base64 string\n       *\n       * @function\n       * @name CipherText#load\n       * @param {Context} context Encryption context to enforce\n       * @param {string} encoded Base64 encoded string\n       */\n      load(context: Context, encoded: string) {\n        try {\n          _instance.loadFromString(context.instance, encoded)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Load a CipherText from an Uint8Array holding binary data\n       *\n       * @function\n       * @name CipherText#loadArray\n       * @param {Context} context Encryption context to enforce\n       * @param {Uint8Array} array TypedArray containing binary data\n       */\n      loadArray(context: Context, array: Uint8Array) {\n        try {\n          _instance.loadFromArray(context.instance, array)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Copy an existing CipherText and overwrite this instance\n       *\n       * @function\n       * @name CipherText#copy\n       * @param {CipherText} cipher CipherText to copy\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * // ... after encoding some data ...\n       * const cipherTextB = seal.CipherText()\n       * cipherTextB.copy(cipherTextA)\n       * // cipherTextB holds a copy of cipherTextA\n       */\n      copy(cipher: CipherText) {\n        try {\n          _instance.copy(cipher.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Clone and return a new instance of this CipherText\n       *\n       * @function\n       * @name CipherText#clone\n       * @returns {CipherText}\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * // ... after encoding some data ...\n       * const cipherTextB = cipherTextA.clone()\n       * // cipherTextB holds a copy of cipherTextA\n       */\n      clone(): CipherText {\n        try {\n          const clonedInstance = _instance.clone()\n          const cipher = CipherTextConstructor(library)({\n            Exception,\n            ComprModeType,\n            ParmsIdType,\n            MemoryPoolHandle,\n            Vector\n          })()\n          cipher.unsafeInject(clonedInstance)\n          return cipher\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Move a CipherText into this one and delete the old reference\n       *\n       * @function\n       * @name CipherText#move\n       * @param {CipherText} cipher CipherText to move\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * // ... after encoding some data ...\n       * const cipherTextB = seal.CipherText()\n       * cipherTextB.move(cipherTextA)\n       * // cipherTextB holds a the instance of cipherTextA.\n       * // cipherTextA no longer holds an instance\n       */\n      move(cipher: CipherText) {\n        try {\n          _instance.move(cipher.instance)\n          // TODO: find optimization\n          // This method results in a copy instead of a real move.\n          // Therefore, we need to delete the old instance.\n          cipher.delete()\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const CipherTextInit = ({\n  loader\n}: LoaderOptions): CipherTextDependencies => {\n  const library: Library = loader.library\n  return CipherTextConstructor(library)\n}\n","import { UNSUPPORTED_CKKS_ENCODE_ARRAY_TYPE } from './constants'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { MemoryPoolHandle } from './memory-pool-handle'\nimport { PlainText, PlainTextConstructorOptions } from './plain-text'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport interface CKKSEncoderDependencyOptions {\n  readonly Exception: Exception\n  readonly MemoryPoolHandle: MemoryPoolHandle\n  readonly PlainText: PlainTextConstructorOptions\n  readonly Vector: VectorConstructorOptions\n}\n\nexport interface CKKSEncoderDependencies {\n  ({\n    Exception,\n    MemoryPoolHandle,\n    PlainText,\n    Vector\n  }: CKKSEncoderDependencyOptions): CKKSEncoderConstructorOptions\n}\n\nexport interface CKKSEncoderConstructorOptions {\n  (context: Context): CKKSEncoder\n}\n\nexport type CKKSEncoderTypes = Float64Array\n\nexport interface CKKSEncoder {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly encode: (\n    array: CKKSEncoderTypes,\n    scale: number,\n    plainText?: PlainText,\n    pool?: MemoryPoolHandle\n  ) => PlainText | void\n  readonly decode: (\n    plainText: PlainText,\n    pool?: MemoryPoolHandle\n  ) => CKKSEncoderTypes\n  readonly slotCount: number\n}\n\nconst CKKSEncoderConstructor =\n  (library: Library): CKKSEncoderDependencies =>\n  ({\n    Exception,\n    MemoryPoolHandle,\n    PlainText,\n    Vector\n  }: CKKSEncoderDependencyOptions): CKKSEncoderConstructorOptions =>\n  (context): CKKSEncoder => {\n    const Constructor = library.CKKSEncoder\n    let _instance: Instance\n    try {\n      _instance = new Constructor(context.instance)\n    } catch (e) {\n      throw Exception.safe(e as SealError)\n    }\n    /**\n     * @implements CKKSEncoder\n     */\n\n    /**\n     * @interface CKKSEncoder\n     */\n    const self: CKKSEncoder = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name CKKSEncoder#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name CKKSEncoder#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        self.delete()\n        _instance = instance\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name CKKSEncoder#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Encodes a vector of double-precision floating-point real numbers\n       * into a plaintext polynomial. Append zeros if vector size is less than N/2.\n       * Dynamic memory allocations in the process are allocated from the memory\n       * pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name CKKSEncoder#encode\n       * @param {Float64Array} array Data to encode\n       * @param {number} scale Scaling parameter defining encoding precision\n       * @param {PlainText} [plainText] Destination to store the encoded result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {PlainText|void} A new PlainText holding the encoded data or void if one was provided\n       * @example\n       * import SEAL from 'node-seal'\n       * const seal = await SEAL()\n       * ...\n       * const ckksEncoder = seal.CKKSEncoder(context)\n       *\n       * const plainText = ckksEncoder.encode(Float64Array.from([1.11, -2.222, 3.333]), Math.pow(2, 20))\n       */\n      encode(\n        array: Float64Array,\n        scale: number,\n        plainText?: PlainText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): PlainText | void {\n        try {\n          if (array.constructor === Float64Array) {\n            if (plainText) {\n              _instance.encode(array, scale, plainText.instance, pool)\n              return\n            }\n            const plain = PlainText()\n            _instance.encode(array, scale, plain.instance, pool)\n            return plain\n          } else {\n            throw new Error(UNSUPPORTED_CKKS_ENCODE_ARRAY_TYPE)\n          }\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Decodes a plaintext polynomial into double-precision floating-point\n       * real numbers. Dynamic memory allocations in the process are\n       * allocated from the memory pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name CKKSEncoder#decode\n       * @param {PlainText} plainText Data to decode\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {Float64Array} TypedArray containing the decoded data\n       * @example\n       * import SEAL from 'node-seal'\n       * const seal = await SEAL()\n       * ...\n       * const ckksEncoder = seal.CKKSEncoder(context)\n       *\n       * const plainText = ckksEncoder.encode(Float64Array.from([1, 2, 3]))\n       *\n       * const result = ckksEncoder.decode(plainText)\n       */\n      decode(\n        plainText: PlainText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): Float64Array {\n        try {\n          const tempVect = Vector()\n          const instance = _instance.decodeDouble(plainText.instance, pool)\n          tempVect.unsafeInject(instance)\n          tempVect.setType('Float64Array')\n          const tempArr = tempVect.toArray() as Float64Array\n          tempVect.delete()\n          return tempArr\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * The total number of CKKS slots available to hold data\n       *\n       * @readonly\n       * @name CKKSEncoder#slotCount\n       * @type {number}\n       */\n      get slotCount() {\n        return _instance.slotCount()\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const CKKSEncoderInit = ({\n  loader\n}: LoaderOptions): CKKSEncoderDependencies => {\n  const library: Library = loader.library\n  return CKKSEncoderConstructor(library)\n}\n","import { UNSUPPORTED_BITSIZES_TYPE } from './constants'\nimport { Exception, SealError } from './exception'\nimport { Library, LoaderOptions } from './seal'\nimport { SecurityLevel } from './security-level'\nimport { Vector, VectorConstructorOptions } from './vector'\n\nexport interface CoeffModulusDependencyOptions {\n  readonly Exception: Exception\n  readonly SecurityLevel: SecurityLevel\n  readonly Vector: VectorConstructorOptions\n}\n\nexport interface CoeffModulusDependencies {\n  ({\n    Exception,\n    SecurityLevel,\n    Vector\n  }: CoeffModulusDependencyOptions): CoeffModulusConstructorOptions\n}\n\nexport interface CoeffModulusConstructorOptions {\n  (): CoeffModulus\n}\n\nexport interface CoeffModulus {\n  readonly MaxBitCount: (\n    polyModulusDegree: number,\n    securityLevel?: SecurityLevel\n  ) => number\n  readonly BFVDefault: (\n    polyModulusDegree: number,\n    securityLevel?: SecurityLevel\n  ) => Vector\n  readonly Create: (polyModulusDegree: number, bitSizes: Int32Array) => Vector\n}\n\nconst CoeffModulusConstructor =\n  (library: Library): CoeffModulusDependencies =>\n  ({\n    Exception,\n    SecurityLevel,\n    Vector\n  }: CoeffModulusDependencyOptions): CoeffModulusConstructorOptions =>\n  (): CoeffModulus => {\n    // Static methods\n    const _MaxBitCount = library.CoeffModulus.MaxBitCount\n    const _BFVDefault = library.CoeffModulus.BFVDefault\n    const _CreateFromArray = library.CoeffModulus.CreateFromArray\n\n    /**\n     * @implements CoeffModulus\n     */\n\n    /**\n     * @interface CoeffModulus\n     */\n    return {\n      /**\n       * Returns the Maximum Bit Count for the specified polyModulusDegree and securityLevel\n       *\n       * @function\n       * @name CoeffModulus.MaxBitCount\n       * @param {number} polyModulusDegree Degree of the polynomial modulus\n       * @param {SecurityLevel} [securityLevel={@link SecurityLevel.tc128}] Security Level\n       * @returns {number} Maximum bit count\n       */\n      MaxBitCount(\n        polyModulusDegree: number,\n        securityLevel: SecurityLevel = SecurityLevel.tc128\n      ): number {\n        return _MaxBitCount(polyModulusDegree, securityLevel)\n      },\n\n      /**\n       * Returns a default vector of primes for the BFV CoeffModulus parameter\n       *\n       * @function\n       * @name CoeffModulus.BFVDefault\n       * @param {number} polyModulusDegree Degree of the polynomial modulus\n       * @param {SecurityLevel} [securityLevel={@link SecurityLevel.tc128}] Security Level\n       * @returns {Vector} Vector containing Modulus primes\n       */\n      BFVDefault(\n        polyModulusDegree: number,\n        securityLevel: SecurityLevel = SecurityLevel.tc128\n      ): Vector {\n        try {\n          const vectorModulus = Vector()\n          const instance = _BFVDefault(polyModulusDegree, securityLevel)\n          vectorModulus.unsafeInject(instance)\n          vectorModulus.setType('Modulus')\n          return vectorModulus\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Creates a vector of primes for a given polyModulusDegree and bitSizes\n       *\n       * @function\n       * @name CoeffModulus.Create\n       * @param {number} polyModulusDegree Degree of the polynomial modulus\n       * @param {Int32Array} bitSizes Int32Array containing values representing\n       * bit-sizes of primes\n       * @returns {Vector} Vector containing Modulus primes\n       */\n      Create(polyModulusDegree: number, bitSizes: Int32Array): Vector {\n        try {\n          if (bitSizes.constructor !== Int32Array) {\n            throw new Error(UNSUPPORTED_BITSIZES_TYPE)\n          }\n          const vectorModulus = Vector()\n          const instance = _CreateFromArray(polyModulusDegree, bitSizes)\n          vectorModulus.unsafeInject(instance)\n          vectorModulus.setType('Modulus')\n          return vectorModulus\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const CoeffModulusInit = ({\n  loader\n}: LoaderOptions): CoeffModulusDependencies => {\n  const library: Library = loader.library\n  return CoeffModulusConstructor(library)\n}\n","import { Library, LoaderOptions } from './seal'\n\nexport interface ComprModeTypeDependencies {\n  (): ComprModeTypeConstructorOptions\n}\n\nexport interface ComprModeTypeConstructorOptions {\n  (): ComprModeType\n}\n\nexport interface ComprModeType {\n  readonly none: any\n  readonly zlib: any\n  readonly zstd: any\n}\n\nconst ComprModeTypeConstructor =\n  (library: Library): ComprModeTypeDependencies =>\n  (): ComprModeTypeConstructorOptions =>\n  (): ComprModeType => {\n    // Static methods\n    const _none = library.ComprModeType.none\n    const _zlib = library.ComprModeType.zlib\n    const _zstd = library.ComprModeType.zstd\n\n    /**\n     * @implements ComprModeType\n     */\n\n    /**\n     * @interface ComprModeType\n     */\n    return {\n      /**\n       * The `none` Compression Mode Type\n       *\n       * @readonly\n       * @name ComprModeType.none\n       * @type {ComprModeType.none}\n       */\n      get none() {\n        /**\n         * @typedef {ComprModeType.none} ComprModeType.none\n         */\n        return _none\n      },\n\n      /**\n       * The `zlib` Compression Mode Type\n       *\n       * @readonly\n       * @name ComprModeType.zlib\n       * @type {ComprModeType.zlib}\n       */\n      get zlib() {\n        /**\n         * @typedef {ComprModeType.zlib} ComprModeType.zlib\n         */\n        return _zlib\n      },\n\n      /**\n       * The `zstd` Compression Mode Type\n       *\n       * @readonly\n       * @name ComprModeType.zstd\n       * @type {ComprModeType.zstd}\n       */\n      get zstd() {\n        /**\n         * @typedef {ComprModeType.zstd} ComprModeType.zstd\n         */\n        return _zstd\n      }\n    }\n  }\n\nexport const ComprModeTypeInit = ({\n  loader\n}: LoaderOptions): ComprModeTypeDependencies => {\n  const library: Library = loader.library\n  return ComprModeTypeConstructor(library)\n}\n","import { ContextData, ContextDataConstructorOptions } from './context-data'\nimport { EncryptionParameters } from './encryption-parameters'\nimport { autoFinalize } from './finalizer'\nimport { ParmsIdType, ParmsIdTypeConstructorOptions } from './parms-id-type'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { SecurityLevel } from './security-level'\n\nexport interface ContextDependencyOptions {\n  readonly ParmsIdType: ParmsIdTypeConstructorOptions\n  readonly ContextData: ContextDataConstructorOptions\n  readonly SecurityLevel: SecurityLevel\n}\n\nexport interface ContextDependencies {\n  ({\n    ParmsIdType,\n    ContextData,\n    SecurityLevel\n  }: ContextDependencyOptions): ContextConstructorOptions\n}\n\nexport interface ContextConstructorOptions {\n  (\n    encryptionParams: EncryptionParameters,\n    expandModChain?: boolean,\n    securityLevel?: SecurityLevel\n  ): Context\n}\n\nexport interface Context {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly toHuman: () => string\n  readonly getContextData: (parmsId: ParmsIdType) => ContextData\n  readonly keyContextData: ContextData\n  readonly firstContextData: ContextData\n  readonly lastContextData: ContextData\n  readonly parametersSet: () => boolean\n  readonly keyParmsId: ParmsIdType\n  readonly firstParmsId: ParmsIdType\n  readonly lastParmsId: ParmsIdType\n  readonly usingKeyswitching: boolean\n}\n\nconst ContextConstructor =\n  (library: Library): ContextDependencies =>\n  ({\n    ParmsIdType,\n    ContextData,\n    SecurityLevel\n  }: ContextDependencyOptions): ContextConstructorOptions =>\n  (\n    encryptionParams,\n    expandModChain = true,\n    securityLevel = SecurityLevel.tc128\n  ): Context => {\n    // Static methods\n    const Constructor = library.SEALContext\n\n    let _instance = new Constructor(\n      encryptionParams.instance,\n      expandModChain,\n      securityLevel\n    ) as Instance\n\n    /**\n     * @implements Context\n     */\n\n    /**\n     * @interface Context\n     */\n    const self: Context = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name Context#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name Context#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        self.delete()\n        _instance = instance\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name Context#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Returns the context parameters in a human readable string format.\n       *\n       * @private\n       * @function\n       * @name Context#toString\n       * @returns {string} Context details as a string\n       */\n      toHuman(): string {\n        return _instance.toHuman()\n      },\n\n      /**\n       * Returns the ContextData corresponding to encryption parameters with a given\n       * parmsId. If parameters with the given parmsId are not found then the\n       * function returns nullptr.\n       *\n       * @function\n       * @name Context#getContextData\n       * @param {ParmsIdType} parmsId Specific id to return ContextData for\n       * @returns {ContextData} ContextData corresponding to encryption parameters\n       */\n      getContextData(parmsId: ParmsIdType): ContextData {\n        const instance = _instance.getContextData(parmsId.instance)\n        const contextData = ContextData()\n        contextData.unsafeInject(instance)\n        return contextData\n      },\n\n      /**\n       * The ContextData corresponding to encryption parameters that are used for keys.\n       *\n       * @readonly\n       * @name Context#keyContextData\n       * @type {ContextData}\n       */\n      get keyContextData() {\n        const instance = _instance.keyContextData()\n        const contextData = ContextData()\n        contextData.unsafeInject(instance)\n        return contextData\n      },\n\n      /**\n       * The ContextData corresponding to the first encryption parameters that are used for data.\n       *\n       * @readonly\n       * @name Context#firstContextData\n       * @type {ContextData}\n       */\n      get firstContextData() {\n        const instance = _instance.firstContextData()\n        const contextData = ContextData()\n        contextData.unsafeInject(instance)\n        return contextData\n      },\n\n      /**\n       * Returns the ContextData corresponding to the last encryption parameters that are used for data.\n       *\n       * @readonly\n       * @name Context#lastContextData\n       * @type {ContextData}\n       */\n      get lastContextData() {\n        const instance = _instance.lastContextData()\n        const contextData = ContextData()\n        contextData.unsafeInject(instance)\n        return contextData\n      },\n\n      /**\n       * Whether the encryption parameters are set in a way that is considered valid by\n       * Microsoft SEAL, the variable parameters_set is set to true.\n       *\n       * @function\n       * @name Context#parametersSet\n       * @type {boolean}\n       */\n      parametersSet() {\n        return _instance.parametersSet()\n      },\n\n      /**\n       * Returns a ParmsIdType corresponding to the set of encryption parameters that are used for keys.\n       *\n       * @readonly\n       * @name Context#keyParmsId\n       * @type {ParmsIdType}\n       */\n      get keyParmsId() {\n        const instance = _instance.keyParmsId()\n        const parmsId = ParmsIdType()\n        parmsId.inject(instance)\n        return parmsId\n      },\n\n      /**\n       * Returns a ParmsIdType corresponding to the first encryption parameters that are used for data.\n       *\n       * @readonly\n       * @name Context#firstParmsId\n       * @type {ParmsIdType}\n       */\n      get firstParmsId() {\n        const instance = _instance.firstParmsId()\n        const parmsId = ParmsIdType()\n        parmsId.inject(instance)\n        return parmsId\n      },\n\n      /**\n       * The ParmsIdType corresponding to the last encryption parameters that are used for data.\n       *\n       * @readonly\n       * @name Context#lastParmsId\n       * @type {ParmsIdType}\n       */\n      get lastParmsId() {\n        const instance = _instance.lastParmsId()\n        const parmsId = ParmsIdType()\n        parmsId.inject(instance)\n        return parmsId\n      },\n\n      /**\n       * Whether the coefficient modulus supports keyswitching. In practice,\n       * support for keyswitching is required by Evaluator.relinearize,\n       * Evaluator.applyGalois, and all rotation and conjugation operations. For\n       * keyswitching to be available, the coefficient modulus parameter must consist\n       * of at least two prime number factors.\n       *\n       * @readonly\n       * @name Context#usingKeyswitching\n       * @type {boolean}\n       */\n      get usingKeyswitching() {\n        return _instance.usingKeyswitching()\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const ContextInit = ({ loader }: LoaderOptions): ContextDependencies => {\n  const library: Library = loader.library\n  return ContextConstructor(library)\n}\n","import {\n  EncryptionParameterQualifiers,\n  EncryptionParameterQualifiersConstructorOptions\n} from './encryption-parameter-qualifiers'\nimport {\n  EncryptionParameters,\n  EncryptionParametersConstructorOptions\n} from './encryption-parameters'\nimport { Exception } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { ParmsIdType, ParmsIdTypeConstructorOptions } from './parms-id-type'\nimport { Instance, Library, LoaderOptions } from './seal'\n\nexport interface ContextDataDependencyOptions {\n  readonly Exception: Exception\n  readonly EncryptionParameters: EncryptionParametersConstructorOptions\n  readonly ParmsIdType: ParmsIdTypeConstructorOptions\n  readonly EncryptionParameterQualifiers: EncryptionParameterQualifiersConstructorOptions\n}\n\nexport interface ContextDataDependencies {\n  ({\n    Exception,\n    EncryptionParameters,\n    ParmsIdType,\n    EncryptionParameterQualifiers\n  }: ContextDataDependencyOptions): ContextDataConstructorOptions\n}\n\nexport interface ContextDataConstructorOptions {\n  (): ContextData\n}\n\nexport interface ContextData {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly parms: EncryptionParameters\n  readonly parmsId: ParmsIdType\n  readonly qualifiers: EncryptionParameterQualifiers\n  readonly totalCoeffModulusBitCount: number\n  readonly prevContextData: ContextData\n  readonly nextContextData: ContextData\n  readonly chainIndex: number\n}\n\nconst ContextDataConstructor =\n  (library: Library): ContextDataDependencies =>\n  ({\n    Exception,\n    EncryptionParameters,\n    ParmsIdType,\n    EncryptionParameterQualifiers\n  }: ContextDataDependencyOptions): ContextDataConstructorOptions =>\n  (): ContextData => {\n    let _instance: Instance\n    /**\n     * @implements ContextData\n     */\n\n    /**\n     * @interface ContextData\n     */\n    const self: ContextData = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name ContextData#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name ContextData#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        self.delete()\n        _instance = instance\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name ContextData#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Returns a const reference to the underlying encryption parameters.\n       *\n       * @readonly\n       * @name ContextData#parms\n       * @type {EncryptionParameters}\n       */\n      get parms() {\n        const instance = _instance.parms()\n        const encryptionParameters = EncryptionParameters()\n        encryptionParameters.unsafeInject(instance)\n        return encryptionParameters\n      },\n\n      /**\n       * Returns the parmsId of the current parameters.\n       *\n       * @readonly\n       * @name ContextData#parmsId\n       * @type {ParmsIdType}\n       */\n      get parmsId() {\n        const parms = ParmsIdType()\n        parms.inject(_instance.parmsId())\n        return parms\n      },\n\n      /**\n       * Returns a copy of EncryptionParameterQualifiers corresponding to the\n       * current encryption parameters. Note that to change the qualifiers it is\n       * necessary to create a new instance of SEALContext once appropriate changes\n       * to the encryption parameters have been made.\n       *\n       * @readonly\n       * @name ContextData#qualifiers\n       * @type {EncryptionParameterQualifiers}\n       */\n      get qualifiers() {\n        const encParmQualifiers = EncryptionParameterQualifiers()\n        encParmQualifiers.unsafeInject(_instance.qualifiers())\n        return encParmQualifiers\n      },\n\n      /**\n       * Returns the significant bit count of the total coefficient modulus.\n       *\n       * @readonly\n       * @name ContextData#totalCoeffModulusBitCount\n       * @type {number}\n       */\n      get totalCoeffModulusBitCount() {\n        return _instance.totalCoeffModulusBitCount()\n      },\n\n      /**\n       * Returns a shared_ptr to the context data corresponding to the previous parameters\n       * in the modulus switching chain. If the current data is the first one in the\n       * chain, then the result is nullptr.\n       *\n       * @readonly\n       * @name ContextData#prevContextData\n       * @type {ContextData}\n       */\n      get prevContextData() {\n        const cxtData = ContextDataConstructor(library)({\n          Exception,\n          EncryptionParameters,\n          ParmsIdType,\n          EncryptionParameterQualifiers\n        })()\n        cxtData.unsafeInject(_instance.prevContextData())\n        return cxtData\n      },\n\n      /**\n       * Returns a shared_ptr to the context data corresponding to the next parameters\n       * in the modulus switching chain. If the current data is the last one in the\n       * chain, then the result is nullptr.\n       *\n       * @readonly\n       * @name ContextData#nextContextData\n       * @type {ContextData}\n       */\n      get nextContextData() {\n        const cxtData = ContextDataConstructor(library)({\n          Exception,\n          EncryptionParameters,\n          ParmsIdType,\n          EncryptionParameterQualifiers\n        })()\n        cxtData.unsafeInject(_instance.nextContextData())\n        return cxtData\n      },\n\n      /**\n       * Returns the index of the parameter set in a chain. The initial parameters\n       * have index 0 and the index increases sequentially in the parameter chain.\n       *\n       * @readonly\n       * @name EncryptionParameterQualifiers#chainIndex\n       * @type {number}\n       */\n      get chainIndex() {\n        return _instance.chainIndex()\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const ContextDataInit = ({\n  loader\n}: LoaderOptions): ContextDataDependencies => {\n  const library: Library = loader.library\n  return ContextDataConstructor(library)\n}\n","import { CipherText } from './cipher-text'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { PlainText, PlainTextConstructorOptions } from './plain-text'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { SecretKey } from './secret-key'\n\nexport interface DecryptorDependencyOptions {\n  readonly Exception: Exception\n  readonly PlainText: PlainTextConstructorOptions\n}\n\nexport interface DecryptorDependencies {\n  ({\n    Exception,\n    PlainText\n  }: DecryptorDependencyOptions): DecryptorConstructorOptions\n}\n\nexport interface DecryptorConstructorOptions {\n  (context: Context, secretKey: SecretKey): Decryptor\n}\n\nexport interface Decryptor {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly decrypt: (\n    cipherText: CipherText,\n    plainText?: PlainText\n  ) => PlainText | void\n  readonly invariantNoiseBudget: (cipherText: CipherText) => number\n}\n\nconst DecryptorConstructor =\n  (library: Library): DecryptorDependencies =>\n  ({\n    Exception,\n    PlainText\n  }: DecryptorDependencyOptions): DecryptorConstructorOptions =>\n  (context, secretKey): Decryptor => {\n    const Constructor = library.Decryptor\n    let _instance: Instance\n    try {\n      _instance = new Constructor(context.instance, secretKey.instance)\n    } catch (e) {\n      throw Exception.safe(e as SealError)\n    }\n    /**\n     * @implements Decryptor\n     */\n\n    /**\n     * @interface Decryptor\n     */\n    const self: Decryptor = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name Decryptor#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name Decryptor#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        self.delete()\n        _instance = instance\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name Decryptor#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Decrypts a CipherText and stores the result in the destination parameter.\n       *\n       * @function\n       * @name Decryptor#decrypt\n       * @param {CipherText} cipherText CipherText to decrypt\n       * @param {PlainText} [plainText] PlainText destination to store the decrypted result\n       * @returns {PlainText|void} Returns undefined if a PlainText was specified. Otherwise returns a\n       * PlainText containng the decrypted result\n       */\n      decrypt(cipherText: CipherText, plainText?: PlainText): PlainText | void {\n        try {\n          if (plainText) {\n            _instance.decrypt(cipherText.instance, plainText.instance)\n            return\n          }\n          const plain = PlainText()\n          _instance.decrypt(cipherText.instance, plain.instance)\n          return plain\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Computes the invariant noise budget (in bits) of a CipherText. The invariant\n       * noise budget measures the amount of room there is for the noise to grow while\n       * ensuring correct decryptions. This function works only with the BFV scheme.\n       *\n       * @par Invariant Noise Budget\n       * The invariant noise polynomial of a CipherText is a rational coefficient\n       * polynomial, such that a CipherText decrypts correctly as long as the\n       * coefficients of the invariantnoise polynomial are of absolute value less\n       * than 1/2. Thus, we call the infinity-norm of the invariant noise polynomial\n       * the invariant noise, and for correct decryption requireit to be less than\n       * 1/2. If v denotes the invariant noise, we define the invariant noise budget\n       * as -log2(2v). Thus, the invariant noise budget starts from some initial\n       * value, which depends on the encryption parameters, and decreases when\n       * computations are performed. When the budget reaches zero, the CipherText\n       * becomes too noisy to decrypt correctly.\n       *\n       * @function\n       * @name Decryptor#invariantNoiseBudget\n       * @param {CipherText} cipherText CipherText to measure\n       * @returns {number} Invariant noise budget (in bits)\n       */\n      invariantNoiseBudget(cipherText: CipherText): number {\n        try {\n          return _instance.invariantNoiseBudget(cipherText.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const DecryptorInit = ({\n  loader\n}: LoaderOptions): DecryptorDependencies => {\n  const library: Library = loader.library\n  return DecryptorConstructor(library)\n}\n","import { autoFinalize } from './finalizer'\nimport { Instance } from './seal'\nimport { SecurityLevel } from './security-level'\n\nexport interface EncryptionParameterQualifiersDependencies {\n  (): EncryptionParameterQualifiersConstructorOptions\n}\n\nexport interface EncryptionParameterQualifiersConstructorOptions {\n  (): EncryptionParameterQualifiers\n}\n\nexport interface EncryptionParameterQualifiers {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly parametersSet: () => boolean\n  readonly usingFFT: boolean\n  readonly usingNTT: boolean\n  readonly usingBatching: boolean\n  readonly usingFastPlainLift: boolean\n  readonly usingDescendingModulusChain: boolean\n  readonly securityLevel: SecurityLevel\n}\n\nconst EncryptionParameterQualifiersConstructor =\n  (): EncryptionParameterQualifiersDependencies =>\n  (): EncryptionParameterQualifiersConstructorOptions =>\n  (): EncryptionParameterQualifiers => {\n    let _instance: Instance\n    /**\n     * @implements EncryptionParameterQualifiers\n     */\n\n    /**\n     * @interface EncryptionParameterQualifiers\n     */\n    const self: EncryptionParameterQualifiers = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name EncryptionParameterQualifiers#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name EncryptionParameterQualifiers#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        self.delete()\n        _instance = instance\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name EncryptionParameterQualifiers#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * If the encryption parameters are set in a way that is considered valid by\n       * Microsoft SEAL, the variable parameters_set is set to true.\n       *\n       * @function\n       * @name EncryptionParameterQualifiers#parametersSet\n       * @type {boolean}\n       */\n      parametersSet() {\n        return _instance.parametersSet()\n      },\n\n      /**\n       * Tells whether FFT can be used for polynomial multiplication. If the\n       * polynomial modulus is of the form X^N+1, where N is a power of two, then\n       * FFT can be used for fast multiplication of polynomials modulo the polynomial\n       * modulus. In this case the variable using_fft will be set to true. However,\n       * currently Microsoft SEAL requires this to be the case for the parameters\n       * to be valid. Therefore, parameters_set can only be true if using_fft is\n       * true.\n       *\n       * @readonly\n       * @name EncryptionParameterQualifiers#usingFFT\n       * @type {boolean}\n       */\n      get usingFFT() {\n        return _instance.usingFFT\n      },\n\n      /**\n       * Tells whether NTT can be used for polynomial multiplication. If the primes\n       * in the coefficient modulus are congruent to 1 modulo 2N, where X^N+1 is the\n       * polynomial modulus and N is a power of two, then the number-theoretic\n       * transform (NTT) can be used for fast multiplications of polynomials modulo\n       * the polynomial modulus and coefficient modulus. In this case the variable\n       * using_ntt will be set to true. However, currently Microsoft SEAL requires\n       * this to be the case for the parameters to be valid. Therefore, parameters_set\n       * can only be true if using_ntt is true.\n       *\n       * @readonly\n       * @name EncryptionParameterQualifiers#usingNTT\n       * @type {boolean}\n       */\n      get usingNTT() {\n        return _instance.usingNTT\n      },\n\n      /**\n       * Tells whether batching is supported by the encryption parameters. If the\n       * plaintext modulus is congruent to 1 modulo 2N, where X^N+1 is the polynomial\n       * modulus and N is a power of two, then it is possible to use the BatchEncoder\n       * class to view plaintext elements as 2-by-(N/2) matrices of integers modulo\n       * the plaintext modulus. This is called batching, and allows the user to\n       * operate on the matrix elements (slots) in a SIMD fashion, and rotate the\n       * matrix rows and columns. When the computation is easily vectorizable, using\n       * batching can yield a huge performance boost. If the encryption parameters\n       * support batching, the variable using_batching is set to true.\n       *\n       * @readonly\n       * @name EncryptionParameterQualifiers#usingBatching\n       * @type {boolean}\n       */\n      get usingBatching() {\n        return _instance.usingBatching\n      },\n\n      /**\n       * Tells whether fast plain lift is supported by the encryption parameters.\n       * A certain performance optimization in multiplication of a ciphertext by\n       * a plaintext (Evaluator::multiply_plain) and in transforming a plaintext\n       * element to NTT domain (Evaluator::transform_to_ntt) can be used when the\n       * plaintext modulus is smaller than each prime in the coefficient modulus.\n       * In this case the variable using_fast_plain_lift is set to true.\n       *\n       * @readonly\n       * @name EncryptionParameterQualifiers#usingFastPlainLift\n       * @type {boolean}\n       */\n      get usingFastPlainLift() {\n        return _instance.usingFastPlainLift\n      },\n\n      /**\n       * Tells whether the coefficient modulus consists of a set of primes that\n       * are in decreasing order. If this is true, certain modular reductions in\n       * base conversion can be omitted, improving performance.\n       *\n       * @readonly\n       * @name EncryptionParameterQualifiers#usingDescendingModulusChain\n       * @type {boolean}\n       */\n      get usingDescendingModulusChain() {\n        return _instance.usingDescendingModulusChain\n      },\n\n      /**\n       * Tells whether the encryption parameters are secure based on the standard\n       * parameters from HomomorphicEncryption.org security standard.\n       *\n       * @readonly\n       * @name EncryptionParameterQualifiers#securityLevel\n       * @type {(SecurityLevel.none|SecurityLevel.tc128|SecurityLevel.tc192|SecurityLevel.tc256)}\n       */\n      get securityLevel() {\n        return _instance.securityLevel\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const EncryptionParameterQualifiersInit =\n  (): EncryptionParameterQualifiersDependencies => {\n    return EncryptionParameterQualifiersConstructor()\n  }\n","import { ComprModeType } from './compr-mode-type'\nimport { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { Modulus, ModulusConstructorOptions } from './modulus'\nimport { ParmsIdType, ParmsIdTypeConstructorOptions } from './parms-id-type'\nimport { SchemeType } from './scheme-type'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { Vector, VectorConstructorOptions } from './vector'\n\nexport interface EncryptionParametersDependencyOptions {\n  readonly Exception: Exception\n  readonly ComprModeType: ComprModeType\n  readonly Modulus: ModulusConstructorOptions\n  readonly SchemeType: SchemeType\n  readonly ParmsIdType: ParmsIdTypeConstructorOptions\n  readonly Vector: VectorConstructorOptions\n}\n\nexport interface EncryptionParametersDependencies {\n  ({\n    Exception,\n    ComprModeType,\n    Modulus,\n    SchemeType,\n    Vector\n  }: EncryptionParametersDependencyOptions): EncryptionParametersConstructorOptions\n}\n\nexport interface EncryptionParametersConstructorOptions {\n  (schemeType?: SchemeType): EncryptionParameters\n}\n\nexport interface EncryptionParameters {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly setPolyModulusDegree: (polyModulusDegree: number) => void\n  readonly setCoeffModulus: (coeffModulus: Vector) => void\n  readonly setPlainModulus: (plainModulus: Modulus) => void\n  readonly scheme: SchemeType\n  readonly polyModulusDegree: number\n  readonly coeffModulus: BigUint64Array\n  readonly plainModulus: Modulus\n  readonly parmsId: ParmsIdType\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n  readonly load: (encoded: string) => void\n  readonly loadArray: (array: Uint8Array) => void\n}\n\nconst EncryptionParametersConstructor =\n  (library: Library): EncryptionParametersDependencies =>\n  ({\n    Exception,\n    ComprModeType,\n    Modulus,\n    SchemeType,\n    ParmsIdType,\n    Vector\n  }: EncryptionParametersDependencyOptions): EncryptionParametersConstructorOptions =>\n  (schemeType: SchemeType = SchemeType.none): EncryptionParameters => {\n    const Constructor = library.EncryptionParameters\n    let _instance = new Constructor(schemeType)\n\n    /**\n     * @implements EncryptionParameters\n     */\n\n    /**\n     * @interface EncryptionParameters\n     */\n    const self: EncryptionParameters = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name EncryptionParameters#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name EncryptionParameters#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        self.delete()\n        _instance = instance\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name EncryptionParameters#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Sets the degree of the polynomial modulus parameter to the specified value.\n       * The polynomial modulus directly affects the number of coefficients in\n       * PlainText polynomials, the size of CipherText elements, the computational\n       * performance of the scheme (bigger is worse), and the security level (bigger\n       * is better). In Microsoft SEAL the degree of the polynomial modulus must be a power\n       * of 2 (e.g.  1024, 2048, 4096, 8192, 16384, or 32768).\n       *\n       * @function\n       * @name EncryptionParameters#setPolyModulusDegree\n       * @param {number} polyModulusDegree The degree of the polynomial modulus\n       */\n      setPolyModulusDegree(polyModulusDegree: number) {\n        try {\n          _instance.setPolyModulusDegree(polyModulusDegree)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Sets the coefficient modulus parameter. The coefficient modulus consists\n       * of a list of distinct prime numbers, and is represented by a vector of\n       * Modulus objects. The coefficient modulus directly affects the size\n       * of CipherText elements, the amount of computation that the scheme can perform\n       * (bigger is better), and the security level (bigger is worse). In Microsoft SEAL each\n       * of the prime numbers in the coefficient modulus must be at most 60 bits,\n       * and must be congruent to 1 modulo 2*degree(poly_modulus).\n       *\n       * @function\n       * @name EncryptionParameters#setCoeffModulus\n       * @param {Vector} coeffModulus Vector of Modulus primes\n       */\n      setCoeffModulus(coeffModulus: Vector) {\n        try {\n          _instance.setCoeffModulus(coeffModulus.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Sets the PlainText modulus parameter. The PlainText modulus is an integer\n       * modulus represented by the Modulus class. The PlainText modulus\n       * determines the largest coefficient that PlainText polynomials can represent.\n       * It also affects the amount of computation that the scheme can perform\n       * (bigger is worse). In Microsoft SEAL the PlainText modulus can be at most 60 bits\n       * long, but can otherwise be any integer. Note, however, that some features\n       * (e.g. batching) require the PlainText modulus to be of a particular form.\n       *\n       * @function\n       * @name EncryptionParameters#setPlainModulus\n       * @param {Modulus} plainModulus PlainText modulus parameter\n       */\n      setPlainModulus(plainModulus: Modulus) {\n        try {\n          _instance.setPlainModulus(plainModulus.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * The encryption scheme type.\n       *\n       * @readonly\n       * @name EncryptionParameters#scheme\n       * @type {SchemeType.none|SchemeType.bfv|SchemeType.ckks}\n       */\n      get scheme() {\n        return _instance.scheme()\n      },\n\n      /**\n       * The degree of the polynomial modulus parameter.\n       *\n       * @readonly\n       * @name EncryptionParameters#polyModulusDegree\n       * @type {number}\n       */\n      get polyModulusDegree() {\n        return _instance.polyModulusDegree()\n      },\n\n      /**\n       * Returns the currently set coefficient modulus parameter.\n       *\n       * @readonly\n       * @name EncryptionParameters#coeffModulus\n       * @type {BigUint64Array}\n       */\n      get coeffModulus() {\n        const tempVect = Vector()\n        const instance = _instance.coeffModulus()\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Modulus')\n        const tempArr = tempVect.toArray() as BigUint64Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Returns the currently set PlainText modulus parameter.\n       *\n       * @readonly\n       * @name EncryptionParameters#plainModulus\n       * @type {Modulus}\n       */\n      get plainModulus() {\n        const instance = _instance.plainModulus()\n        const smallModulus = Modulus(BigInt(0))\n        smallModulus.inject(instance)\n        return smallModulus\n      },\n\n      /**\n       * Returns the ParmsId of the current parameters.\n       *\n       * @readonly\n       * @name EncryptionParameters#parmsId\n       * @type {ParmsIdType}\n       */\n      get parmsId() {\n        const parms = ParmsIdType()\n        parms.inject(_instance.parmsId())\n        return parms\n      },\n\n      /**\n       * Save the Encryption Parameters to a base64 string\n       *\n       * @function\n       * @name EncryptionParameters#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        return _instance.saveToString(compression)\n      },\n\n      /**\n       * Save the Encryption Parameters as a binary Uint8Array\n       *\n       * @function\n       * @name EncryptionParameters#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the CipherText in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Load the Encryption Parameters from a base64 string\n       *\n       * @function\n       * @name EncryptionParameters#load\n       * @param {string} encoded base64 encoded string\n       */\n      load(encoded: string) {\n        try {\n          _instance.loadFromString(encoded)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Load the Encryption Parameters from an Uint8Array holding binary data\n       *\n       * @function\n       * @name EncryptionParameters#loadArray\n       * @param {Uint8Array} array TypedArray containing binary data\n       */\n      loadArray(array: Uint8Array) {\n        try {\n          _instance.loadFromArray(array)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const EncryptionParametersInit = ({\n  loader\n}: LoaderOptions): EncryptionParametersDependencies => {\n  const library: Library = loader.library\n  return EncryptionParametersConstructor(library)\n}\n","import { CipherText, CipherTextConstructorOptions } from './cipher-text'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { MemoryPoolHandle } from './memory-pool-handle'\nimport { PlainText } from './plain-text'\nimport { PublicKey } from './public-key'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { SecretKey } from './secret-key'\nimport { Serializable, SerializableConstructorOptions } from './serializable'\n\nexport interface EncryptorDependencyOptions {\n  readonly Exception: Exception\n  readonly MemoryPoolHandle: MemoryPoolHandle\n  readonly CipherText: CipherTextConstructorOptions\n  readonly Serializable: SerializableConstructorOptions\n}\n\nexport interface EncryptorDependencies {\n  ({\n    Exception,\n    MemoryPoolHandle,\n    CipherText,\n    Serializable\n  }: EncryptorDependencyOptions): EncryptorConstructorOptions\n}\n\nexport interface EncryptorConstructorOptions {\n  (context: Context, publicKey: PublicKey, secretKey?: SecretKey): Encryptor\n}\n\nexport interface Encryptor {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly encrypt: (\n    plainText: PlainText,\n    cipherText?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly encryptSerializable: (\n    plainText: PlainText,\n    pool?: MemoryPoolHandle\n  ) => Serializable\n  readonly encryptSymmetric: (\n    plainText: PlainText,\n    cipherText?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly encryptSymmetricSerializable: (\n    plainText: PlainText,\n    pool?: MemoryPoolHandle\n  ) => Serializable\n  readonly encryptZero: (\n    cipherText?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly encryptZeroSerializable: (pool?: MemoryPoolHandle) => Serializable\n}\n\nconst EncryptorConstructor =\n  (library: Library): EncryptorDependencies =>\n  ({\n    Exception,\n    MemoryPoolHandle,\n    CipherText,\n    Serializable\n  }: EncryptorDependencyOptions): EncryptorConstructorOptions =>\n  (context, publicKey, secretKey): Encryptor => {\n    const Constructor = library.Encryptor\n    let _instance = constructInstance(context, publicKey, secretKey)\n\n    function constructInstance(\n      context: Context,\n      publicKey: PublicKey,\n      secretKey?: SecretKey\n    ) {\n      try {\n        if (secretKey) {\n          return new Constructor(\n            context.instance,\n            publicKey.instance,\n            secretKey.instance\n          )\n        }\n        return new Constructor(context.instance, publicKey.instance)\n      } catch (e) {\n        throw Exception.safe(e as SealError)\n      }\n    }\n    /**\n     * @implements Encryptor\n     */\n\n    /**\n     * @interface Encryptor\n     */\n    const self: Encryptor = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name Encryptor#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name Encryptor#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        self.delete()\n        _instance = instance\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name Encryptor#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Encrypts a PlainText and stores the result in the destination parameter.\n       * Dynamic memory allocations in the process are allocated from the memory\n       * pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Encryptor#encrypt\n       * @param {PlainText} plainText PlainText to encrypt\n       * @param {CipherText} [cipherText] CipherText destination to store the encrypted result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} Returns undefined if a CipherText was specified. Otherwise returns a\n       * CipherText containing the encrypted result\n       */\n      encrypt(\n        plainText: PlainText,\n        cipherText?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (cipherText) {\n            _instance.encrypt(plainText.instance, cipherText.instance, pool)\n            return\n          }\n          const cipher = CipherText()\n          _instance.encrypt(plainText.instance, cipher.instance, pool)\n          return cipher\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Encrypts a PlainText and returns a CipherText as a Serializable object.\n       * Dynamic memory allocations in the process are allocated from the memory\n       * pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Encryptor#encryptSerializable\n       * @param {PlainText} plainText PlainText to encrypt\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {Serializable<CipherText>} A Serializable containing the encrypted result\n       */\n      encryptSerializable(\n        plainText: PlainText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): Serializable {\n        try {\n          const temp = Serializable()\n          const instance = _instance.encryptSerializable(\n            plainText.instance,\n            pool\n          )\n          temp.unsafeInject(instance)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Encrypts a PlainText with the secret key and stores the result in\n       * destination.\n       *\n       * The encryption parameters for the resulting CipherText\n       * correspond to:\n       * 1) in BFV or BGV, the highest (data) level in the modulus switching chain,\n       * 2) in CKKS, the encryption parameters of the plaintext.\n       * Dynamic memory allocations in the process are allocated from the memory\n       * pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Encryptor#encryptSymmetric\n       * @param {PlainText} plainText PlainText to encrypt\n       * @param {CipherText} [cipherText] CipherText destination to store the encrypted result.\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} Returns undefined if a CipherText was specified. Otherwise returns a\n       * CipherText containing the encrypted result\n       */\n      encryptSymmetric(\n        plainText: PlainText,\n        cipherText?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (cipherText) {\n            _instance.encryptSymmetric(\n              plainText.instance,\n              cipherText.instance,\n              pool\n            )\n            return\n          }\n          const cipher = CipherText()\n          _instance.encryptSymmetric(plainText.instance, cipher.instance, pool)\n          return cipher\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Encrypts a plaintext with the secret key and returns the ciphertext as\n       * a serializable object.\n       *\n       * The encryption parameters for the resulting CipherText\n       * correspond to:\n       * 1) in BFV or BGV, the highest (data) level in the modulus switching chain,\n       * 2) in CKKS, the encryption parameters of the plaintext.\n       * Dynamic memory allocations in the process are allocated from the memory\n       * pool pointed to by the given MemoryPoolHandle.\n       *\n       * Half of the ciphertext data is pseudo-randomly generated from a seed to\n       * reduce the object size. The resulting serializable object cannot be used\n       * directly and is meant to be serialized for the size reduction to have an\n       * impact.\n       *\n       * @function\n       * @name Encryptor#encryptSymmetricSerializable\n       * @param {PlainText} plainText PlainText to encrypt\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {Serializable<CipherText>} Returns a Serializable containing the encrypted result\n       */\n      encryptSymmetricSerializable(\n        plainText: PlainText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): Serializable {\n        try {\n          const serialized = Serializable()\n          const instance = _instance.encryptSymmetricSerializable(\n            plainText.instance,\n            pool\n          )\n          serialized.unsafeInject(instance)\n          return serialized\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Encrypts a zero plaintext with the public key and returns the ciphertext\n       * as a serializable object.\n       *\n       * The encryption parameters for the resulting ciphertext correspond to the\n       * highest (data) level in the modulus switching chain. Dynamic memory\n       * allocations in the process are allocated from the memory pool pointed to\n       * by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Encryptor#encryptZero\n       * @param {CipherText} [cipherText] A CipherText to overwrite.\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} Returns undefined if a CipherText was specified. Otherwise returns a\n       * CipherText containing the encrypted result\n       */\n      encryptZero(\n        cipherText?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (cipherText) {\n            _instance.encryptZero(cipherText.instance, pool)\n            return\n          }\n          const cipher = CipherText()\n          _instance.encryptZero(cipher.instance, pool)\n          return cipher\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Encrypts a zero plaintext with the public key and stores the result in\n       * destination.\n       *\n       * The encryption parameters for the resulting ciphertext correspond to the\n       * highest (data) level in the modulus switching chain. Dynamic memory\n       * allocations in the process are allocated from the memory pool pointed to\n       * by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Encryptor#encryptZeroSerializable\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {Serializable<CipherText>} A CipherText as a serialized object containing the encrypted result\n       */\n      encryptZeroSerializable(\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): Serializable {\n        try {\n          const serialized = Serializable()\n          const instance = _instance.encryptZeroSerializable(pool)\n          serialized.unsafeInject(instance)\n          return serialized\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const EncryptorInit = ({\n  loader\n}: LoaderOptions): EncryptorDependencies => {\n  const library: Library = loader.library\n  return EncryptorConstructor(library)\n}\n","import { CipherText, CipherTextConstructorOptions } from './cipher-text'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { GaloisKeys } from './galois-keys'\nimport { MemoryPoolHandle } from './memory-pool-handle'\nimport { ParmsIdType } from './parms-id-type'\nimport { PlainText, PlainTextConstructorOptions } from './plain-text'\nimport { RelinKeys } from './relin-keys'\nimport { SchemeType } from './scheme-type'\nimport { Instance, Library, LoaderOptions } from './seal'\n\nexport interface EvaluatorDependencyOptions {\n  readonly Exception: Exception\n  readonly MemoryPoolHandle: MemoryPoolHandle\n  readonly CipherText: CipherTextConstructorOptions\n  readonly PlainText: PlainTextConstructorOptions\n}\n\nexport interface EvaluatorDependencies {\n  ({\n    Exception,\n    MemoryPoolHandle,\n    CipherText,\n    PlainText\n  }: EvaluatorDependencyOptions): EvaluatorConstructorOptions\n}\n\nexport interface EvaluatorConstructorOptions {\n  (context: Context): Evaluator\n}\n\nexport interface Evaluator {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly negate: (\n    encrypted: CipherText,\n    destination?: CipherText\n  ) => CipherText | void\n  readonly add: (\n    a: CipherText,\n    b: CipherText,\n    destination?: CipherText\n  ) => CipherText | void\n  readonly sub: (\n    a: CipherText,\n    b: CipherText,\n    destination?: CipherText\n  ) => CipherText | void\n  readonly multiply: (\n    a: CipherText,\n    b: CipherText,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly square: (\n    encrypted: CipherText,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly relinearize: (\n    encrypted: CipherText,\n    relinKeys: RelinKeys,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly cipherModSwitchToNext: (\n    encrypted: CipherText,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly cipherModSwitchTo: (\n    encrypted: CipherText,\n    parmsId: ParmsIdType,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly plainModSwitchToNext: (\n    plain: PlainText,\n    destination?: PlainText\n  ) => PlainText | void\n  readonly plainModSwitchTo: (\n    plain: PlainText,\n    parmsId: ParmsIdType,\n    destination?: PlainText\n  ) => PlainText | void\n  readonly rescaleToNext: (\n    encrypted: CipherText,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly rescaleTo: (\n    encrypted: CipherText,\n    parmsId: ParmsIdType,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly modReduceToNext: (\n    encrypted: CipherText,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly modReduceTo: (\n    encrypted: CipherText,\n    parmsId: ParmsIdType,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly exponentiate: (\n    encrypted: CipherText,\n    exponent: number,\n    relinKeys: RelinKeys,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly addPlain: (\n    encrypted: CipherText,\n    plain: PlainText,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly subPlain: (\n    encrypted: CipherText,\n    plain: PlainText,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly multiplyPlain: (\n    encrypted: CipherText,\n    plain: PlainText,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly plainTransformToNtt: (\n    plain: PlainText,\n    parmsId: ParmsIdType,\n    destinationNtt?: PlainText,\n    pool?: MemoryPoolHandle\n  ) => PlainText | void\n  readonly cipherTransformToNtt: (\n    encrypted: CipherText,\n    destinationNtt?: CipherText\n  ) => CipherText | void\n  readonly cipherTransformFromNtt: (\n    encryptedNtt: CipherText,\n    destination?: CipherText\n  ) => CipherText | void\n  readonly applyGalois: (\n    encrypted: CipherText,\n    galoisElt: number,\n    galoisKeys: GaloisKeys,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly rotateRows: (\n    encrypted: CipherText,\n    steps: number,\n    galoisKeys: GaloisKeys,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly rotateColumns: (\n    encrypted: CipherText,\n    galoisKeys: GaloisKeys,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly rotateVector: (\n    encrypted: CipherText,\n    steps: number,\n    galoisKeys: GaloisKeys,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly complexConjugate: (\n    encrypted: CipherText,\n    galoisKeys: GaloisKeys,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly sumElements: (\n    encrypted: CipherText,\n    galoisKeys: GaloisKeys,\n    scheme: SchemeType,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly dotProduct: (\n    a: CipherText,\n    b: CipherText,\n    relinKeys: RelinKeys,\n    galoisKeys: GaloisKeys,\n    scheme: SchemeType,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly dotProductPlain: (\n    a: CipherText,\n    b: PlainText,\n    galoisKeys: GaloisKeys,\n    scheme: SchemeType,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n}\n\nconst EvaluatorConstructor =\n  (library: Library): EvaluatorDependencies =>\n  ({\n    Exception,\n    MemoryPoolHandle,\n    CipherText,\n    PlainText\n  }: EvaluatorDependencyOptions): EvaluatorConstructorOptions =>\n  (context): Evaluator => {\n    const Constructor = library.Evaluator\n    let _instance: Instance\n    try {\n      _instance = new Constructor(context.instance)\n    } catch (e) {\n      throw Exception.safe(e as SealError)\n    }\n    /**\n     * @implements Evaluator\n     */\n\n    /**\n     * @interface Evaluator\n     */\n    const self: Evaluator = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name Evaluator#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name Evaluator#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        self.delete()\n        _instance = instance\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name Evaluator#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Negates a CipherText and stores the result in the destination parameter.\n       *\n       * @function\n       * @name Evaluator#negate\n       * @param {CipherText} encrypted CipherText to negate\n       * @param {CipherText} [destination] CipherText to store the negated results\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherText = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.negate(cipherText)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.negate(encrypted, cipherDest)\n       */\n      negate(\n        encrypted: CipherText,\n        destination?: CipherText\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.negate(encrypted.instance, destination.instance)\n            return\n          }\n          const temp = CipherText()\n          _instance.negate(encrypted.instance, temp.instance)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Adds two CipherTexts. This function adds together a and b\n       * and stores the result in the destination parameter.\n       *\n       * @function\n       * @name Evaluator#add\n       * @param {CipherText} a CipherText operand A\n       * @param {CipherText} b CipherText operand B\n       * @param {CipherText} [destination] CipherText destination to store the sum\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * const cipherTextB = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.add(cipherTextA, cipherTextB)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.add(cipherTextA, cipherTextB, cipherDest)\n       */\n      add(\n        a: CipherText,\n        b: CipherText,\n        destination?: CipherText\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.add(a.instance, b.instance, destination.instance)\n            return\n          }\n          const temp = CipherText()\n          _instance.add(a.instance, b.instance, temp.instance)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Subtracts two CipherTexts. This function computes the difference of a\n       * and b and stores the result in the destination parameter.\n       *\n       * @function\n       * @name Evaluator#sub\n       * @param {CipherText} a CipherText operand A\n       * @param {CipherText} b CipherText operand B\n       * @param {CipherText} [destination] CipherText destination to store the difference\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * const cipherTextB = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.sub(cipherTextA, cipherTextB)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.sub(cipherTextA, cipherTextB, cipherDest)\n       */\n      sub(\n        a: CipherText,\n        b: CipherText,\n        destination?: CipherText\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.sub(a.instance, b.instance, destination.instance)\n            return\n          }\n          const temp = CipherText()\n          _instance.sub(a.instance, b.instance, temp.instance)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Multiplies two CipherTexts. This functions computes the product of a\n       * and b and stores the result in the destination parameter. Dynamic\n       * memory allocations in the process are allocated from the memory pool pointed\n       * to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#multiply\n       * @param {CipherText} a CipherText operand A\n       * @param {CipherText} b CipherText operand B\n       * @param {CipherText} [destination] CipherText destination to store the product\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * const cipherTextB = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.multiply(cipherTextA, cipherTextB)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.multiply(cipherTextA, cipherTextB, cipherDest)\n       */\n      multiply(\n        a: CipherText,\n        b: CipherText,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.multiply(\n              a.instance,\n              b.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.multiply(a.instance, b.instance, temp.instance, pool)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Squares a CipherText. This functions computes the square of encrypted and\n       * stores the result in the destination parameter. Dynamic memory allocations\n       * in the process are allocated from the memory pool pointed to by the given\n       * MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#square\n       * @param {CipherText} encrypted CipherText to square\n       * @param {CipherText} [destination] CipherText destination to store the squared result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.square(cipherTextA, cipherTextB)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.square(cipherTextA, cipherDest)\n       */\n      square(\n        encrypted: CipherText,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.square(encrypted.instance, destination.instance, pool)\n            return\n          }\n          const temp = CipherText()\n          _instance.square(encrypted.instance, temp.instance, pool)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Relinearizes a CipherText. This functions relinearizes encrypted, reducing\n       * its size down to 2, and stores the result in the destination parameter.\n       * If the size of encrypted is K+1, the given relinearization keys need to\n       * have size at least K-1. Dynamic memory allocations in the process are allocated\n       * from the memory pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#relinearize\n       * @param {CipherText} encrypted CipherText to relinearize\n       * @param {RelinKeys} relinKeys RelinKey used to perform relinearization\n       * @param {CipherText} [destination] CipherText destination to store the relinearized result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const relinKeys = keyGenerator.createRelinKeys()\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.relinearize(cipherTextA, relinKeys)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.relinearize(cipherTextA, relinKeys, cipherDest)\n       */\n      relinearize(\n        encrypted: CipherText,\n        relinKeys: RelinKeys,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.relinearize(\n              encrypted.instance,\n              relinKeys.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.relinearize(\n            encrypted.instance,\n            relinKeys.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Given a CipherText encrypted modulo q_1...q_k, this function switches the\n       * modulus down to q_1...q_{k-1} and stores the result in the destination\n       * parameter. Dynamic memory allocations in the process are allocated from\n       * the memory pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#cipherModSwitchToNext\n       * @param {CipherText} encrypted CipherText to switch its modulus down\n       * @param {CipherText} [destination] CipherText destination to store the switched result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.cipherModSwitchToNext(cipherTextA)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.cipherModSwitchToNext(cipherTextA, cipherDest)\n       */\n      cipherModSwitchToNext(\n        encrypted: CipherText,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.cipherModSwitchToNext(\n              encrypted.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.cipherModSwitchToNext(\n            encrypted.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Given a CipherText encrypted modulo q_1...q_k, this function switches the\n       * modulus down until the parameters reach the given parmsId and stores the\n       * result in the destination parameter. Dynamic memory allocations in the process\n       * are allocated from the memory pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#cipherModSwitchTo\n       * @param {CipherText} encrypted CipherText to switch its modulus down\n       * @param {ParmsIdType} parmsId Target parmsId to switch to\n       * @param {CipherText} [destination] CipherText destination to store the switched result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const context = seal.Context(encParms, true)\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const parmsId = context.lastParmsId\n       * const resultCipher = evaluator.cipherModSwitchTo(cipherTextA, parmsId)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.cipherModSwitchTo(cipherTextA, parmsId, cipherDest)\n       */\n      cipherModSwitchTo(\n        encrypted: CipherText,\n        parmsId: ParmsIdType,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.cipherModSwitchTo(\n              encrypted.instance,\n              parmsId.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.cipherModSwitchTo(\n            encrypted.instance,\n            parmsId.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Modulus switches an NTT transformed PlainText from modulo q_1...q_k down\n       * to modulo q_1...q_{k-1} and stores the result in the destination parameter.\n       *\n       * @function\n       * @name Evaluator#plainModSwitchToNext\n       * @param {PlainText} plain PlainText to switch its modulus down\n       * @param {PlainText} [destination] PlainText destination to store the switched result\n       * @returns {PlainText|void} PlainText containing the result or void if a destination was supplied\n       * @example\n       * const plainTextA = seal.PlainText()\n       * // ... after encoding some data ...\n       * const resultCipher = evaluator.plainModSwitchToNext(plainTextA)\n       * // or\n       * const plainDest = seal.PlainText()\n       * evaluator.plainModSwitchToNext(plainTextA, plainDest)\n       */\n      plainModSwitchToNext(\n        plain: PlainText,\n        destination?: PlainText\n      ): PlainText | void {\n        try {\n          if (destination) {\n            _instance.plainModSwitchToNext(plain.instance, destination.instance)\n            return\n          }\n          const temp = PlainText()\n          _instance.plainModSwitchToNext(plain.instance, temp.instance)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Given an NTT transformed PlainText modulo q_1...q_k, this function switches\n       * the modulus down until the parameters reach the given parmsId and stores\n       * the result in the destination parameter.\n       *\n       * @function\n       * @name Evaluator#plainModSwitchTo\n       * @param {PlainText} plain PlainText to switch its modulus down\n       * @param {ParmsIdType} parmsId Target parmsId to switch to\n       * @param {PlainText} [destination] PlainText destination to store the switched result\n       * @returns {PlainText|void} PlainText containing the result or void if a destination was supplied\n       * @example\n       * const context = seal.Context(encParms, true)\n       * const plainTextA = seal.PlainText()\n       * // ... after encoding some data ...\n       * const parmsId = context.lastParmsId\n       * const resultCipher = evaluator.plainModSwitchTo(plainTextA, parmsId)\n       * // or\n       * const plainDest = seal.PlainText()\n       * evaluator.plainModSwitchTo(plainTextA, parmsId, plainDest)\n       */\n      plainModSwitchTo(\n        plain: PlainText,\n        parmsId: ParmsIdType,\n        destination?: PlainText\n      ): PlainText | void {\n        try {\n          if (destination) {\n            _instance.plainModSwitchTo(\n              plain.instance,\n              parmsId.instance,\n              destination.instance\n            )\n            return\n          }\n          const temp = PlainText()\n          _instance.plainModSwitchTo(\n            plain.instance,\n            parmsId.instance,\n            temp.instance\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Given a CipherText encrypted modulo q_1...q_k, this function switches the\n       * modulus down to q_1...q_{k-1}, scales the message down accordingly, and\n       * stores the result in the destination parameter. Dynamic memory allocations\n       * in the process are allocated from the memory pool pointed to by the given\n       * MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#rescaleToNext\n       * @param {CipherText} encrypted CipherText to rescale\n       * @param {CipherText} [destination] CipherText destination to store the rescaled result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.rescaleToNext(cipherTextA)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.rescaleToNext(cipherTextA, cipherDest)\n       */\n      rescaleToNext(\n        encrypted: CipherText,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.rescaleToNext(\n              encrypted.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.rescaleToNext(encrypted.instance, temp.instance, pool)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Given a CipherText encrypted modulo q_1...q_k, this function switches the\n       * modulus down until the parameters reach the given parmsId, scales the message\n       * down accordingly, and stores the result in the destination parameter. Dynamic\n       * memory allocations in the process are allocated from the memory pool pointed\n       * to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#rescaleTo\n       * @param {CipherText} encrypted CipherText to rescale\n       * @param {ParmsIdType} parmsId Target parmsId to rescale to\n       * @param {CipherText} [destination] CipherText destination to store the rescaled result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const context = seal.Context(encParms, true)\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const parmsId = context.lastParmsId\n       * const resultCipher = evaluator.rescaleTo(cipherTextA, parmsId)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.rescaleTo(cipherTextA, parmsId, cipherDest)\n       */\n      rescaleTo(\n        encrypted: CipherText,\n        parmsId: ParmsIdType,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.rescaleTo(\n              encrypted.instance,\n              parmsId.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.rescaleTo(\n            encrypted.instance,\n            parmsId.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Given a ciphertext encrypted modulo q_1...q_k, this function switches\n       * the modulus down to q_1...q_{k-1}, scales the message down accordingly,\n       * and stores the result in the destination parameter. Dynamic memory\n       * allocations in the process are allocated from the memory pool pointed\n       * to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#modReduceToNext\n       * @param {CipherText} encrypted CipherText to reduce\n       * @param {CipherText} [destination] CipherText destination to store the\n       * reduced result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}]\n       * MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if\n       * a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.modReduceToNext(cipherTextA)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.modReduceToNext(cipherTextA, cipherDest)\n       */\n      modReduceToNext(\n        encrypted: CipherText,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.modReduceToNext(\n              encrypted.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.modReduceToNext(encrypted.instance, temp.instance, pool)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Given a ciphertext encrypted modulo q_1...q_k, this function reduces\n       * the modulus down until the parameters reach the given parms_id and\n       * stores the result in the destination parameter. Dynamic memory\n       * allocations in the process are allocated from the memory pool pointed\n       * to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#modReduceTo\n       * @param {CipherText} encrypted CipherText to reduce\n       * @param {ParmsIdType} parmsId Target parmsId to reduce to\n       * @param {CipherText} [destination] CipherText destination to store the\n       * reduced result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}]\n       * MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if\n       * a destination was supplied\n       * @example\n       * const context = seal.Context(encParms, true)\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const parmsId = context.lastParmsId\n       * const resultCipher = evaluator.modReduceTo(cipherTextA, parmsId)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.modReduceTo(cipherTextA, parmsId, cipherDest)\n       */\n      modReduceTo(\n        encrypted: CipherText,\n        parmsId: ParmsIdType,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.modReduceTo(\n              encrypted.instance,\n              parmsId.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.modReduceTo(\n            encrypted.instance,\n            parmsId.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Exponentiates a CipherText. This functions raises encrypted to a power and\n       * stores the result in the destination parameter. Dynamic memory allocations\n       * in the process are allocated from the memory pool pointed to by the given\n       * MemoryPoolHandle. The exponentiation is done in a depth-optimal order, and\n       * relinearization is performed automatically after every multiplication in\n       * the process. In relinearization the given relinearization keys are used.\n       *\n       * @function\n       * @name Evaluator#exponentiate\n       * @param {CipherText} encrypted CipherText to exponentiate\n       * @param {number} exponent Positive integer to exponentiate the CipherText\n       * @param {RelinKeys} relinKeys RelinKeys used to perform relinearization after each exponentiation\n       * @param {CipherText} [destination] CipherText destination to store the exponentiated result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const relinKeys = keyGenerator.createRelinKeys()\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.exponentiate(cipherTextA, 3, relinKeys)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.exponentiate(cipherTextA, 3, relinKeys, cipherDest)\n       */\n      exponentiate(\n        encrypted: CipherText,\n        exponent: number,\n        relinKeys: RelinKeys,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.exponentiate(\n              encrypted.instance,\n              exponent,\n              relinKeys.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.exponentiate(\n            encrypted.instance,\n            exponent,\n            relinKeys.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Adds a CipherText and a PlainText. This function adds a CipherText and\n       * a PlainText and stores the result in the destination parameter. The PlainText\n       * must be valid for the current encryption parameters.\n       *\n       * @function\n       * @name Evaluator#addPlain\n       * @param {CipherText} encrypted CipherText operand A\n       * @param {PlainText} plain PlainText operand B\n       * @param {CipherText} [destination] CipherText destination to store the sum\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * const plainTextB = seal.PlainText()\n       * // ... after encrypting/encoding some data ...\n       * const resultCipher = evaluator.addPlain(cipherTextA, plainTextB)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.addPlain(cipherTextA, plainTextB, cipherDest)\n       */\n      addPlain(\n        encrypted: CipherText,\n        plain: PlainText,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.addPlain(\n              encrypted.instance,\n              plain.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.addPlain(\n            encrypted.instance,\n            plain.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Subtracts a PlainText from a CipherText. This function subtracts a PlainText\n       * from a CipherText and stores the result in the destination parameter. The\n       * PlainText must be valid for the current encryption parameters.\n       *\n       * @function\n       * @name Evaluator#subPlain\n       * @param {CipherText} encrypted CipherText operand A\n       * @param {PlainText} plain PlainText operand B\n       * @param {CipherText} [destination] CipherText destination to store the difference\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * const plainTextB = seal.PlainText()\n       * // ... after encrypting/encoding some data ...\n       * const resultCipher = evaluator.subPlain(cipherTextA, plainTextB)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.subPlain(cipherTextA, plainTextB, cipherDest)\n       */\n      subPlain(\n        encrypted: CipherText,\n        plain: PlainText,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.subPlain(\n              encrypted.instance,\n              plain.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.subPlain(\n            encrypted.instance,\n            plain.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Multiplies a CipherText with a PlainText. This function multiplies\n       * a CipherText with a PlainText and stores the result in the destination\n       * parameter. The PlainText must be a valid for the current encryption parameters,\n       * and cannot be identially 0. Dynamic memory allocations in the process are\n       * allocated from the memory pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#multiplyPlain\n       * @param {CipherText} encrypted CipherText operand A\n       * @param {PlainText} plain PlainText operand B\n       * @param {CipherText} [destination] CipherText destination to store the product\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText?} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * const plainTextB = seal.PlainText()\n       * // ... after encrypting/encoding some data ...\n       * const resultCipher = evaluator.multiplyPlain(cipherTextA, plainTextB)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.multiplyPlain(cipherTextA, plainTextB, cipherDest)\n       */\n      multiplyPlain(\n        encrypted: CipherText,\n        plain: PlainText,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.multiplyPlain(\n              encrypted.instance,\n              plain.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.multiplyPlain(\n            encrypted.instance,\n            plain.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Transforms a PlainText to NTT domain. This functions applies the number\n       * Theoretic Transform to a PlainText by first embedding integers modulo the\n       * PlainText modulus to integers modulo the coefficient modulus and then\n       * performing David Harvey's NTT on the resulting polynomial. The transformation\n       * is done with respect to encryption parameters corresponding to a given\n       * parmsId. The result is stored in the destinationNtt parameter. For the\n       * operation to be valid, the PlainText must have degree less than PolyModulusDegree\n       * and each coefficient must be less than the PlainText modulus, i.e., the PlainText\n       * must be a valid PlainText under the current encryption parameters. Dynamic\n       * memory allocations in the process are allocated from the memory pool pointed\n       * to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#plainTransformToNtt\n       * @param {PlainText} plain PlainText to transform\n       * @param {ParmsIdType} parmsId target parmsId to perform NTT transformation\n       * @param {PlainText} [destinationNtt] PlainText destination to store the transformed result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {PlainText|void} PlainText containing the result or void if a destination was supplied\n       * @example\n       * const context = seal.Context(encParms, true)\n       * const plainTextA = seal.PlainText()\n       * // ... after encoding some data ...\n       * const parmsId = context.lastParmsId\n       * const resultCipher = evaluator.plainTransformToNtt(plainTextA, parmsId)\n       * // or\n       * const plainDest = seal.PlainText()\n       * evaluator.plainTransformToNtt(plainTextA, parmsId, plainDest)\n       */\n      plainTransformToNtt(\n        plain: PlainText,\n        parmsId: ParmsIdType,\n        destinationNtt?: PlainText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): PlainText | void {\n        try {\n          if (destinationNtt) {\n            _instance.plainTransformToNtt(\n              plain.instance,\n              parmsId.instance,\n              destinationNtt.instance,\n              pool\n            )\n            return\n          }\n          const temp = PlainText()\n          _instance.plainTransformToNtt(\n            plain.instance,\n            parmsId.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Transforms a CipherText to NTT domain. This functions applies David Harvey's\n       * number Theoretic Transform separately to each polynomial of a CipherText.\n       * The result is stored in the destinationNtt parameter.\n       *\n       * @function\n       * @name Evaluator#cipherTransformToNtt\n       * @param {CipherText} encrypted CipherText to transform\n       * @param {CipherText} [destinationNtt] CipherText destination to store the transformed result\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.cipherTransformToNtt(cipherTextA)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.cipherTransformToNtt(cipherTextA, cipherDest)\n       */\n      cipherTransformToNtt(\n        encrypted: CipherText,\n        destinationNtt?: CipherText\n      ): CipherText | void {\n        try {\n          if (destinationNtt) {\n            _instance.cipherTransformToNtt(\n              encrypted.instance,\n              destinationNtt.instance\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.cipherTransformToNtt(encrypted.instance, temp.instance)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Transforms a CipherText back from NTT domain. This functions applies the\n       * inverse of David Harvey's number Theoretic Transform separately to each\n       * polynomial of a CipherText. The result is stored in the destination parameter.\n       *\n       * @function\n       * @name Evaluator#cipherTransformFromNtt\n       * @param {CipherText} encryptedNtt CipherText to transform\n       * @param {CipherText} [destination] CipherText destination to store the transformed result\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * // ... after cipherTransformToNtt ...\n       * const resultCipher = evaluator.cipherTransformFromNtt(cipherTextANtt)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.cipherTransformFromNtt(cipherTextANtt, cipherDest)\n       */\n      cipherTransformFromNtt(\n        encryptedNtt: CipherText,\n        destination?: CipherText\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.cipherTransformFromNtt(\n              encryptedNtt.instance,\n              destination.instance\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.cipherTransformFromNtt(encryptedNtt.instance, temp.instance)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Applies a Galois automorphism to a CipherText and writes the result to the\n       * destination parameter. To evaluate the Galois automorphism, an appropriate\n       * set of Galois keys must also be provided. Dynamic memory allocations in\n       * the process are allocated from the memory pool pointed to by the given\n       * MemoryPoolHandle.\n       *\n       * The desired Galois automorphism is given as a Galois element, and must be\n       * an odd integer in the interval [1, M-1], where M = 2*N, and N = degree(poly_modulus).\n       * Used with batching, a Galois element 3^i % M corresponds to a cyclic row\n       * rotation i steps to the left, and a Galois element 3^(N/2-i) % M corresponds\n       * to a cyclic row rotation i steps to the right. The Galois element M-1 corresponds\n       * to a column rotation (row swap) in BFV, and complex conjugation in CKKS.\n       * In the polynomial view (not batching), a Galois automorphism by a Galois\n       * element p changes Enc(plain(x)) to Enc(plain(x^p)).\n       *\n       * @function\n       * @name Evaluator#applyGalois\n       * @param {CipherText} encrypted CipherText to apply the automorphism\n       * @param {number} galoisElt number representing the Galois element\n       * @param {GaloisKeys} galoisKeys GaloisKeys used to perform rotations\n       * @param {CipherText} [destination] CipherText destination to store the result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * ...\n       * const evaluator = seal.Evaluator(context)\n       * const arr = Int32Array.from({ length: encoder.slotCount }, (_, i) => i)\n       * const plain = encoder.encode(arr)\n       * const cipher = encryptor.encrypt(plain)\n       * const cipherDest = seal.CipherText()\n       * const galElt = 2 * parms.polyModulusDegree - 1\n       * evaluator.applyGalois(cipher, galElt, galoisKeys, cipherDest)\n       */\n      applyGalois(\n        encrypted: CipherText,\n        galoisElt: number,\n        galoisKeys: GaloisKeys,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.applyGalois(\n              encrypted.instance,\n              galoisElt,\n              galoisKeys.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.applyGalois(\n            encrypted.instance,\n            galoisElt,\n            galoisKeys.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Rotates PlainText matrix rows cyclically. When batching is used with the\n       * BFV/BGV scheme, this function rotates the encrypted PlainText matrix rows\n       * cyclically to the left (steps > 0) or to the right (steps < 0) and writes\n       * the result to the destination parameter. Since the size of the batched\n       * matrix is 2-by-(N/2), where N is the degree of the polynomial modulus,\n       * the number of steps to rotate must have absolute value at most N/2-1. Dynamic\n       * memory allocations in the process are allocated from the memory pool pointed\n       * to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#rotateRows\n       * @param {CipherText} encrypted CipherText to rotate rows\n       * @param {number} steps Int representing steps to rotate (negative = right, positive = left)\n       * @param {GaloisKeys} galoisKeys GaloisKeys used to perform rotations\n       * @param {CipherText} [destination] CipherText destination to store the rotated result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const galoisKeys = keyGenerator.createGaloisKeys()\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.rotateRows(cipherTextA, 3, galoisKeys)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.rotateRows(cipherTextA, 3, galoisKeys, cipherDest)\n       */\n      rotateRows(\n        encrypted: CipherText,\n        steps: number,\n        galoisKeys: GaloisKeys,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.rotateRows(\n              encrypted.instance,\n              steps,\n              galoisKeys.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.rotateRows(\n            encrypted.instance,\n            steps,\n            galoisKeys.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Rotates PlainText matrix columns cyclically. When batching is used with\n       * the BFV scheme, this function rotates the encrypted PlainText matrix columns\n       * cyclically, and writes the result to the destination parameter. Since the\n       * size of the batched matrix is 2-by-(N/2), where N is the degree of the\n       * polynomial modulus, this means simply swapping the two rows. Dynamic memory\n       * allocations in the process are allocated from the memory pool pointed to\n       * by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#rotateColumns\n       * @param {CipherText} encrypted CipherText to rotate columns\n       * @param {GaloisKeys} galoisKeys GaloisKeys used to perform rotations\n       * @param {CipherText} [destination] CipherText destination to store the rotated result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const galoisKeys = keyGenerator.createGaloisKeys()\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.rotateColumns(cipherTextA, galoisKeys)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.rotateColumns(cipherTextA, galoisKeys, cipherDest)\n       */\n      rotateColumns(\n        encrypted: CipherText,\n        galoisKeys: GaloisKeys,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.rotateColumns(\n              encrypted.instance,\n              galoisKeys.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.rotateColumns(\n            encrypted.instance,\n            galoisKeys.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Rotates PlainText vector cyclically. When using the CKKS scheme, this function\n       * rotates the encrypted PlainText vector cyclically to the left (steps > 0)\n       * or to the right (steps < 0) and writes the result to the destination parameter.\n       * Since the size of the batched matrix is 2-by-(N/2), where N is the degree\n       * of the polynomial modulus, the number of steps to rotate must have absolute\n       * value at most N/2-1. Dynamic memory allocations in the process are allocated\n       * from the memory pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#rotateVector\n       * @param {CipherText} encrypted CipherText to rotate the entire vector\n       * @param {number} steps Int representing steps to rotate (negative = right, positive = left)\n       * @param {GaloisKeys} galoisKeys GaloisKeys used to perform rotations\n       * @param {CipherText} [destination] CipherText destination to store the rotated result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const galoisKeys = keyGenerator.createGaloisKeys()\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.rotateVector(cipherTextA, 3, galoisKeys)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.rotateVector(cipherTextA, 3, galoisKeys, cipherDest)\n       */\n      rotateVector(\n        encrypted: CipherText,\n        steps: number,\n        galoisKeys: GaloisKeys,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.rotateVector(\n              encrypted.instance,\n              steps,\n              galoisKeys.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.rotateVector(\n            encrypted.instance,\n            steps,\n            galoisKeys.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Complex conjugates PlainText slot values. When using the CKKS scheme, this\n       * function complex conjugates all values in the underlying PlainText, and\n       * writes the result to the destination parameter. Dynamic memory allocations\n       * in the process are allocated from the memory pool pointed to by the given\n       * MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#complexConjugate\n       * @param {CipherText} encrypted CipherText to complex conjugate\n       * @param {GaloisKeys} galoisKeys GaloisKeys used to perform rotations\n       * @param {CipherText} [destination] CipherText destination to store the conjugated result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const galoisKeys = keyGenerator.createGaloisKeys()\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.complexConjugate(cipherTextA, galoisKeys)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.complexConjugate(cipherTextA, galoisKeys, cipherDest)\n       */\n      complexConjugate(\n        encrypted: CipherText,\n        galoisKeys: GaloisKeys,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.complexConjugate(\n              encrypted.instance,\n              galoisKeys.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.complexConjugate(\n            encrypted.instance,\n            galoisKeys.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Sum all elements in the encrypted CipherText. The resulting CipherText contains the sum in every element.\n       *\n       * @function\n       * @name Evaluator#sumElements\n       * @param {CipherText} encrypted CipherText to sum elements\n       * @param {GaloisKeys} galoisKeys GaloisKeys used to perform rotations\n       * @param {SchemeType} scheme Scheme that was used for encryption\n       * @param {CipherText} [destination] CipherText destination to store the result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const galoisKeys = keyGenerator.createGaloisKeys()\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.sumElements(cipherTextA, galoisKeys, seal.SchemeTypes.BFV)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.sumElements(cipherTextA, galoisKeys, seal.SchemeTypes.BFV, cipherDest)\n       */\n      sumElements(\n        encrypted: CipherText,\n        galoisKeys: GaloisKeys,\n        scheme: SchemeType,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.sumElements(\n              encrypted.instance,\n              galoisKeys.instance,\n              scheme,\n              destination.instance,\n              pool\n            )\n            return\n          }\n\n          const newDest = CipherText()\n          _instance.sumElements(\n            encrypted.instance,\n            galoisKeys.instance,\n            scheme,\n            newDest.instance,\n            pool\n          )\n          return newDest\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Perform the dot product (A.B) of two CipherTexts The resulting CipherText contains the dot product in every\n       * element.\n       *\n       * @function\n       * @name Evaluator#dotProduct\n       * @param {CipherText} a CipherText operand A\n       * @param {CipherText} b CipherText operand B\n       * @param {RelinKeys} relinKeys RelinKeys used to perform relinearization after multiplication\n       * @param {GaloisKeys} galoisKeys GaloisKeys used to perform rotations\n       * @param {SchemeType} scheme Scheme that was used for encryption\n       * @param {CipherText} [destination] CipherText destination to store the result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const relinKeys = keyGenerator.createRelinKeys()\n       * const galoisKeys = keyGenerator.createGaloisKeys()\n       * const cipherTextA = seal.CipherText()\n       * const cipherTextB = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.dotProduct(cipherTextA, cipherTextB, relinKeys, galoisKeys, seal.SchemeTypes.BFV)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.dotProduct(cipherTextA, cipherTextB, relinKeys, galoisKeys, seal.SchemeTypes.BFV, cipherDest)\n       */\n      dotProduct(\n        a: CipherText,\n        b: CipherText,\n        relinKeys: RelinKeys,\n        galoisKeys: GaloisKeys,\n        scheme: SchemeType,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.multiply(\n              a.instance,\n              b.instance,\n              destination.instance,\n              pool\n            )\n            _instance.relinearize(\n              destination.instance,\n              relinKeys.instance,\n              destination.instance,\n              pool\n            )\n            _instance.sumElements(\n              destination.instance,\n              galoisKeys.instance,\n              scheme,\n              destination.instance,\n              pool\n            )\n            return\n          }\n\n          const newDest = CipherText()\n          _instance.multiply(a.instance, b.instance, newDest.instance, pool)\n          _instance.relinearize(\n            newDest.instance,\n            relinKeys.instance,\n            newDest.instance,\n            pool\n          )\n          _instance.sumElements(\n            newDest.instance,\n            galoisKeys.instance,\n            scheme,\n            newDest.instance,\n            pool\n          )\n          return newDest\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Perform the dot product (A.B) of CipherText (A) and PlainText (B). The resulting CipherText contains the dot\n       * product in every element.\n       *\n       * @function\n       * @name Evaluator#dotProductPlain\n       * @param {CipherText} a CipherText operand A\n       * @param {PlainText} b PlainText operand B\n       * @param {GaloisKeys} galoisKeys GaloisKeys used to perform rotations\n       * @param {SchemeType} scheme Scheme that was used for encryption\n       * @param {CipherText} [destination] CipherText destination to store the result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const galoisKeys = keyGenerator.createGaloisKeys()\n       * const cipherTextA = seal.CipherText()\n       * const plainTextB = seal.PlainText()\n       * // ... after encoding / encrypting some data ...\n       * const resultCipher = evaluator.dotProductPlain(cipherTextA, plainTextB, galoisKeys, seal.SchemeTypes.BFV)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.dotProductPlain(cipherTextA, plainTextB, galoisKeys, seal.SchemeTypes.BFV, cipherDest)\n       */\n      dotProductPlain(\n        a: CipherText,\n        b: PlainText,\n        galoisKeys: GaloisKeys,\n        scheme: SchemeType,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.multiplyPlain(\n              a.instance,\n              b.instance,\n              destination.instance,\n              pool\n            )\n            _instance.sumElements(\n              destination.instance,\n              galoisKeys.instance,\n              scheme,\n              destination.instance,\n              pool\n            )\n            return\n          }\n\n          const newDest = CipherText()\n          _instance.multiplyPlain(\n            a.instance,\n            b.instance,\n            newDest.instance,\n            pool\n          )\n          _instance.sumElements(\n            newDest.instance,\n            galoisKeys.instance,\n            scheme,\n            newDest.instance,\n            pool\n          )\n          return newDest\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const EvaluatorInit = ({\n  loader\n}: LoaderOptions): EvaluatorDependencies => {\n  const library: Library = loader.library\n  return EvaluatorConstructor(library)\n}\n","import { Library, LoaderOptions } from './seal'\n\nexport interface ExceptionDependencies {\n  (): ExceptionConstructorOptions\n}\n\nexport interface ExceptionConstructorOptions {\n  (): Exception\n}\n\nexport type SealError = number | Error | string\n\nexport interface Exception {\n  readonly safe: (e: SealError) => Error\n}\n\nconst ExceptionConstructor =\n  (library: Library): ExceptionDependencies =>\n  (): ExceptionConstructorOptions =>\n  (): Exception => {\n    // Static methods\n    const _getException = library.getException\n\n    /**\n     * @implements Exception\n     */\n\n    /**\n     * @interface Exception\n     */\n    return {\n      /**\n       * Takes a caught exception in SEAL library and gets a safe error string\n       *\n       * @function\n       * @name Exception.safe\n       * @param {(number|Error|string)} error Unsafe error to normalize\n       * @returns {Error}\n       */\n      safe(error: number | Error | string): Error {\n        if (typeof error === 'number') {\n          return new Error(_getException(error))\n        }\n\n        if (error instanceof Error) {\n          return error\n        }\n        return new Error(error || 'Unknown Error!')\n      }\n    }\n  }\n\nexport const ExceptionInit = ({\n  loader\n}: LoaderOptions): ExceptionDependencies => {\n  const library: Library = loader.library\n  return ExceptionConstructor(library)\n}\n","import { ComprModeType } from './compr-mode-type'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport interface GaloisKeysDependencyOptions {\n  readonly Exception: Exception\n  readonly ComprModeType: ComprModeType\n  readonly Vector: VectorConstructorOptions\n}\n\nexport interface GaloisKeysDependencies {\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: GaloisKeysDependencyOptions): GaloisKeysConstructorOptions\n}\n\nexport interface GaloisKeysConstructorOptions {\n  (): GaloisKeys\n}\n\nexport interface GaloisKeys {\n  readonly instance: Instance\n  readonly inject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly size: number\n  readonly getIndex: (galoisElt: number) => number\n  readonly hasKey: (galoisElt: number) => boolean\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n  readonly load: (context: Context, encoded: string) => void\n  readonly loadArray: (context: Context, array: Uint8Array) => void\n  readonly copy: (key: GaloisKeys) => void\n  readonly clone: () => GaloisKeys\n  readonly move: (key: GaloisKeys) => void\n}\n\nconst GaloisKeysConstructor =\n  (library: Library): GaloisKeysDependencies =>\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: GaloisKeysDependencyOptions): GaloisKeysConstructorOptions =>\n  (): GaloisKeys => {\n    const Constructor = library.GaloisKeys\n    let _instance = new Constructor()\n\n    /**\n     * @implements GaloisKeys\n     */\n\n    /**\n     * @interface GaloisKeys\n     */\n    const self: GaloisKeys = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name GaloisKeys#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance\n       *\n       * @private\n       * @function\n       * @name GaloisKeys#inject\n       * @param {Instance} instance WASM instance\n       */\n      inject(instance: Instance) {\n        self.delete()\n        _instance = new Constructor(instance)\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name GaloisKeys#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Returns the current number of keyswitching keys. Only keys that are\n       * non-empty are counted.\n       *\n       * @readonly\n       * @name GaloisKeys#size\n       * @type {number}\n       */\n      get size() {\n        return _instance.size()\n      },\n\n      /**\n       * Returns the index of a Galois key in the backing KSwitchKeys instance that\n       * corresponds to the given Galois element, assuming that it exists in the\n       * backing KSwitchKeys.\n       *\n       * @function\n       * @name GaloisKeys#getIndex\n       * @param {number} galoisElt The Galois element\n       * @returns {number} The index of the galois element\n       */\n      getIndex(galoisElt: number): number {\n        try {\n          return _instance.getIndex(galoisElt)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Returns whether a Galois key corresponding to a given Galois element exists.\n       *\n       * @function\n       * @name GaloisKeys#hasKey\n       * @param {number} galoisElt The Galois element\n       * @returns {boolean} True if the key exists\n       */\n      hasKey(galoisElt: number): boolean {\n        try {\n          return _instance.hasKey(galoisElt)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n      /**\n       * Save the Encryption Parameters to a base64 string\n       *\n       * @function\n       * @name GaloisKeys#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} Base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        try {\n          return _instance.saveToString(compression)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Save the GaloisKeys as a binary Uint8Array\n       *\n       * @function\n       * @name GaloisKeys#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the GaloisKeys in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Load a GaloisKeys from a base64 string\n       *\n       * @function\n       * @name GaloisKeys#load\n       * @param {Context} context Encryption context to enforce\n       * @param {string} encoded Base64 encoded string\n       */\n      load(context: Context, encoded: string) {\n        try {\n          _instance.loadFromString(context.instance, encoded)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Load a GaloisKeys from an Uint8Array holding binary data\n       *\n       * @function\n       * @name GaloisKeys#loadArray\n       * @param {Context} context Encryption context to enforce\n       * @param {Uint8Array} array TypedArray containing binary data\n       */\n      loadArray(context: Context, array: Uint8Array) {\n        try {\n          _instance.loadFromArray(context.instance, array)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Copy an existing GaloisKeys and overwrite this instance\n       *\n       * @function\n       * @name GaloisKeys#copy\n       * @param {GaloisKeys} key GaloisKeys to copy\n       * @example\n       * const keyA = keyGenerator.createGaloisKeys()\n       * const keyB = seal.GaloisKeys()\n       * keyB.copy(keyA)\n       * // keyB holds a copy of keyA\n       */\n      copy(key: GaloisKeys) {\n        try {\n          _instance.copy(key.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Clone and return a new instance of this GaloisKeys\n       *\n       * @function\n       * @name GaloisKeys#clone\n       * @returns {GaloisKeys}\n       * @example\n       * const keyA = keyGenerator.createGaloisKeys()\n       * const keyB = keyA.clone()\n       * // keyB holds a copy of keyA\n       */\n      clone(): GaloisKeys {\n        try {\n          const clonedInstance = _instance.clone()\n          const key = GaloisKeysConstructor(library)({\n            Exception,\n            ComprModeType,\n            Vector\n          })()\n          key.inject(clonedInstance)\n          return key\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Move a GaloisKeys into this one and delete the old reference\n       *\n       * @function\n       * @name GaloisKeys#move\n       * @param {GaloisKeys} key GaloisKeys to move\n       * @example\n       * const keyA = keyGenerator.createGaloisKeys()\n       * const keyB = seal.GaloisKeys()\n       * keyB.move(keyA)\n       * // keyB holds a the instance of keyA.\n       * // keyA no longer holds an instance\n       */\n      move(key: GaloisKeys) {\n        try {\n          _instance.move(key.instance)\n          // TODO: find optimization\n          // This method results in a copy instead of a real move.\n          // Therefore, we need to delete the old instance.\n          key.delete()\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const GaloisKeysInit = ({\n  loader\n}: LoaderOptions): GaloisKeysDependencies => {\n  const library: Library = loader.library\n  return GaloisKeysConstructor(library)\n}\n","import { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { GaloisKeys, GaloisKeysConstructorOptions } from './galois-keys'\nimport { PublicKey, PublicKeyConstructorOptions } from './public-key'\nimport { RelinKeys, RelinKeysConstructorOptions } from './relin-keys'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { SecretKey, SecretKeyConstructorOptions } from './secret-key'\nimport { Serializable, SerializableConstructorOptions } from './serializable'\n\nexport interface KeyGeneratorDependencyOptions {\n  readonly Exception: Exception\n  readonly PublicKey: PublicKeyConstructorOptions\n  readonly SecretKey: SecretKeyConstructorOptions\n  readonly RelinKeys: RelinKeysConstructorOptions\n  readonly GaloisKeys: GaloisKeysConstructorOptions\n  readonly Serializable: SerializableConstructorOptions\n}\n\nexport interface KeyGeneratorDependencies {\n  ({\n    Exception,\n    PublicKey,\n    SecretKey,\n    RelinKeys,\n    GaloisKeys,\n    Serializable\n  }: KeyGeneratorDependencyOptions): KeyGeneratorConstructorOptions\n}\n\nexport interface KeyGeneratorConstructorOptions {\n  (context: Context, secretKey?: SecretKey): KeyGenerator\n}\n\nexport interface KeyGenerator {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly secretKey: () => SecretKey\n  readonly createPublicKeySerializable: () => Serializable\n  readonly createPublicKey: () => PublicKey\n  readonly createRelinKeysSerializable: () => Serializable\n  readonly createRelinKeys: () => RelinKeys\n  readonly createGaloisKeysSerializable: (steps?: Int32Array) => Serializable\n  readonly createGaloisKeys: (steps?: Int32Array) => GaloisKeys\n}\n\nconst KeyGeneratorConstructor =\n  (library: Library): KeyGeneratorDependencies =>\n  ({\n    Exception,\n    PublicKey,\n    SecretKey,\n    RelinKeys,\n    GaloisKeys,\n    Serializable\n  }: KeyGeneratorDependencyOptions): KeyGeneratorConstructorOptions =>\n  (context, secretKey): KeyGenerator => {\n    const Constructor = library.KeyGenerator\n    let _instance = constructInstance(context, secretKey)\n\n    function constructInstance(context: Context, secretKey?: SecretKey) {\n      try {\n        if (secretKey) {\n          return new Constructor(context.instance, secretKey.instance)\n        }\n        return new Constructor(context.instance)\n      } catch (e) {\n        throw Exception.safe(e as SealError)\n      }\n    }\n    /**\n     * @implements KeyGenerator\n     */\n\n    /**\n     * @interface KeyGenerator\n     */\n    const self: KeyGenerator = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name KeyGenerator#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name KeyGenerator#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        self.delete()\n        _instance = instance\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name KeyGenerator#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Return the generated SecretKey\n       *\n       * @function\n       * @name KeyGenerator#secretKey\n       * @returns {SecretKey} The secret key that was generated upon instantiation of this KeyGenerator\n       */\n      secretKey(): SecretKey {\n        try {\n          const key = SecretKey()\n          const instance = _instance.secretKey()\n          key.inject(instance)\n          return key\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Create a new PublicKey instance\n       *\n       * @function\n       * @name KeyGenerator#createPublicKey\n       * @returns {PublicKey} A new PublicKey instance\n       */\n      createPublicKey(): PublicKey {\n        try {\n          const key = PublicKey()\n          _instance.createPublicKey(key.instance)\n          return key\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Create a new, Serializable PublicKey instance\n       *\n       * @function\n       * @name KeyGenerator#createPublicKeySerializable\n       * @returns {Serializable<PublicKey>} A new, serializable, PublicKey instance\n       */\n      createPublicKeySerializable(): Serializable {\n        try {\n          const serialized = Serializable()\n          const instance = _instance.createPublicKeySerializable()\n          serialized.unsafeInject(instance)\n          return serialized\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Generates and returns relinearization keys. This function returns\n       * relinearization keys in a fully expanded form and is meant to be used\n       * primarily for demo, testing, and debugging purposes.\n       *\n       * @function\n       * @name KeyGenerator#createRelinKeys\n       * @returns {RelinKeys} New RelinKeys from the KeyGenerator's internal secret key\n       */\n      createRelinKeys(): RelinKeys {\n        try {\n          const keys = RelinKeys()\n          _instance.createRelinKeys(keys.instance)\n          return keys\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Generates and returns relinearization keys as a serializable object.\n       *\n       * Half of the key data is pseudo-randomly generated from a seed to reduce\n       * the object size. The resulting serializable object cannot be used\n       * directly and is meant to be serialized for the size reduction to have an\n       * impact.\n       *\n       *\n       * @function\n       * @name KeyGenerator#createRelinKeysSerializable\n       * @returns {Serializable<RelinKeys>} New, serializable RelinKeys from the KeyGenerator's internal secret key\n       */\n      createRelinKeysSerializable(): Serializable {\n        try {\n          const serialized = Serializable()\n          const instance = _instance.createRelinKeysSerializable()\n          serialized.unsafeInject(instance)\n          return serialized\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Generates and returns Galois keys. This function returns Galois keys in\n       * a fully expanded form and is meant to be used primarily for demo, testing,\n       * and debugging purposes. The user can optionally give an input a vector of desired\n       * Galois rotation step counts, where negative step counts correspond to\n       * rotations to the right and positive step counts correspond to rotations to\n       * the left. A step count of zero can be used to indicate a column rotation\n       * in the BFV scheme complex conjugation in the CKKS scheme.\n       *\n       * @function\n       * @name KeyGenerator#createGaloisKeys\n       * @param {Int32Array} [steps=Int32Array.from([])] Specific Galois Elements to generate\n       * @returns {GaloisKeys} New GaloisKeys from the KeyGenerator's internal secret key\n       */\n      createGaloisKeys(steps: Int32Array = Int32Array.from([])): GaloisKeys {\n        try {\n          const keys = GaloisKeys()\n          _instance.createGaloisKeys(steps, keys.instance)\n          return keys\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Generates and returns Galois keys as a serializable object. This function\n       * creates specific Galois keys that can be used to apply specific Galois\n       * automorphisms on encrypted data. The user can optionally give an input a vector\n       * of desired Galois rotation step counts, where negative step counts\n       * correspond to rotations to the right and positive step counts correspond\n       * to rotations to the left. A step count of zero can be used to indicate\n       * a column rotation in the BFV scheme complex conjugation in the CKKS scheme.\n       * Half of the key data is pseudo-randomly generated from a seed to reduce\n       * the object size. The resulting serializable object cannot be used\n       * directly and is meant to be serialized for the size reduction to have an\n       * impact.\n       *\n       * @function\n       * @name KeyGenerator#createGaloisKeysSerializable\n       * @param {Int32Array} [steps=Int32Array.from([])] Specific Galois Elements to generate\n       * @returns {Serializable<GaloisKeys>} Base64 encoded string\n       */\n      createGaloisKeysSerializable(\n        steps: Int32Array = Int32Array.from([])\n      ): Serializable {\n        try {\n          const serialized = Serializable()\n          const instance = _instance.createGaloisKeysSerializable(steps)\n          serialized.unsafeInject(instance)\n          return serialized\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const KeyGeneratorInit = ({\n  loader\n}: LoaderOptions): KeyGeneratorDependencies => {\n  const library: Library = loader.library\n  return KeyGeneratorConstructor(library)\n}\n","import { Library, LoaderOptions } from './seal'\n\nexport interface MemoryPoolHandleDependencies {\n  (): MemoryPoolHandleConstructorOptions\n}\n\nexport interface MemoryPoolHandleConstructorOptions {\n  (): MemoryPoolHandle\n}\n\nexport interface MemoryPoolHandle {\n  readonly global: any\n  readonly threadLocal: any\n}\n\nconst MemoryPoolHandleConstructor =\n  (library: Library): MemoryPoolHandleDependencies =>\n  (): MemoryPoolHandleConstructorOptions =>\n  (): MemoryPoolHandle => {\n    // Static methods\n    const _global = library.MemoryPoolHandle.MemoryPoolHandleGlobal\n    const _threadLocal = library.MemoryPoolHandle.MemoryPoolHandleThreadLocal\n\n    /**\n     * @implements MemoryPoolHandle\n     */\n\n    /**\n     * @interface MemoryPoolHandle\n     */\n    return {\n      /**\n       * The MemoryPoolHandle pointing to the global memory pool.\n       *\n       * @readonly\n       * @name MemoryPoolHandle.global\n       * @type {MemoryPoolHandle.global}\n       */\n      get global() {\n        /**\n         * @typedef {MemoryPoolHandle.global} MemoryPoolHandle.global\n         */\n        return _global()\n      },\n\n      /**\n       * The MemoryPoolHandle pointing to the thread-local memory pool.\n       *\n       * @readonly\n       * @name MemoryPoolHandle.threadLocal\n       * @type {MemoryPoolHandle.threadLocal}\n       */\n      get threadLocal() {\n        /**\n         * @typedef {MemoryPoolHandle.threadLocal} MemoryPoolHandle.threadLocal\n         */\n        return _threadLocal()\n      }\n    }\n  }\n\nexport const MemoryPoolHandleInit = ({\n  loader\n}: LoaderOptions): MemoryPoolHandleDependencies => {\n  const library: Library = loader.library\n  return MemoryPoolHandleConstructor(library)\n}\n","import { ComprModeType } from './compr-mode-type'\nimport { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport interface ModulusDependencyOptions {\n  readonly Exception: Exception\n  readonly ComprModeType: ComprModeType\n  readonly Vector: VectorConstructorOptions\n}\n\nexport interface ModulusDependencies {\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: ModulusDependencyOptions): ModulusConstructorOptions\n}\n\nexport interface ModulusConstructorOptions {\n  (value: bigint): Modulus\n}\n\nexport interface Modulus {\n  readonly instance: Instance\n  readonly inject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly setValue: (value: bigint) => void\n  readonly value: bigint\n  readonly bitCount: number\n  readonly isZero: boolean\n  readonly isPrime: boolean\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n  readonly load: (encoded: string) => void\n  readonly loadArray: (array: Uint8Array) => void\n}\n\nconst ModulusConstructor =\n  (library: Library): ModulusDependencies =>\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: ModulusDependencyOptions): ModulusConstructorOptions =>\n  (value: bigint): Modulus => {\n    // Static methods\n    const Constructor = library.Modulus\n\n    let _instance = createModulus(value)\n\n    function createModulus(value: bigint) {\n      try {\n        const inst = new Constructor()\n        inst.setValue(value.toString())\n        return inst\n      } catch (e) {\n        throw Exception.safe(e as SealError)\n      }\n    }\n\n    /**\n     * @implements Modulus\n     */\n\n    /**\n     * @interface Modulus\n     */\n    const self: Modulus = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name Modulus#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance\n       *\n       * @private\n       * @function\n       * @name Modulus#inject\n       * @param {Instance} instance WASM instance\n       */\n      inject(instance: Instance) {\n        self.delete()\n        _instance = new Constructor(instance)\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name Modulus#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Loads a Modulus from a string representing an uint64 value.\n       *\n       * @function\n       * @name Modulus#setValue\n       * @param {BigInt} value BigInt value to set\n       */\n      setValue(value: bigint) {\n        try {\n          _instance.setValue(value.toString())\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * The value of the current Modulus as a BigInt.\n       *\n       * @readonly\n       * @name Modulus#value\n       * @type {BigInt}\n       */\n      get value() {\n        // eslint-disable-next-line no-undef\n        return BigInt(_instance.value())\n      },\n\n      /**\n       * The significant bit count of the value of the current Modulus.\n       *\n       * @readonly\n       * @name Modulus#bitCount\n       * @type {number}\n       */\n      get bitCount() {\n        return _instance.bitCount()\n      },\n\n      /**\n       * Whether the value of the current Modulus is zero.\n       *\n       * @readonly\n       * @name Modulus#isZero\n       * @type {boolean}\n       */\n      get isZero() {\n        return _instance.isZero()\n      },\n\n      /**\n       * Whether the value of the current Modulus is a prime number.\n       *\n       * @readonly\n       * @name Modulus#isPrime\n       * @type {boolean}\n       */\n      get isPrime() {\n        return _instance.isPrime()\n      },\n\n      /**\n       * Save the Modulus as a base64 string\n       *\n       * @function\n       * @name Modulus#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} Base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        return _instance.saveToString(compression)\n      },\n\n      /**\n       * Save the Modulus as a binary Uint8Array\n       *\n       * @function\n       * @name Modulus#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the Modulus in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Load a Modulus from a base64 string\n       *\n       * @function\n       * @name Modulus#load\n       * @param {string} encoded Base64 encoded string\n       */\n      load(encoded: string) {\n        try {\n          _instance.loadFromString(encoded)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Load a Modulus from an Uint8Array holding binary data\n       *\n       * @function\n       * @name Modulus#loadArray\n       * @param {Uint8Array} array TypedArray containing binary data\n       */\n      loadArray(array: Uint8Array) {\n        try {\n          _instance.loadFromArray(array)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const ModulusInit = ({ loader }: LoaderOptions): ModulusDependencies => {\n  const library: Library = loader.library\n  return ModulusConstructor(library)\n}\n","import { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { Instance, Library, LoaderOptions } from './seal'\n\nexport interface ParmsIdTypeDependencyOptions {\n  readonly Exception: Exception\n}\n\nexport interface ParmsIdTypeDependencies {\n  ({ Exception }: ParmsIdTypeDependencyOptions): ParmsIdTypeConstructorOptions\n}\n\nexport interface ParmsIdTypeConstructorOptions {\n  (): ParmsIdType\n}\n\nexport interface ParmsIdType {\n  readonly instance: Instance\n  readonly inject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly values: BigUint64Array\n}\n\nconst ParmsIdTypeConstructor =\n  (library: Library): ParmsIdTypeDependencies =>\n  ({\n    Exception\n  }: ParmsIdTypeDependencyOptions): ParmsIdTypeConstructorOptions =>\n  (): ParmsIdType => {\n    const Constructor = library.ParmsIdType\n\n    let _instance: Instance\n\n    /**\n     * @implements ParmsIdType\n     */\n\n    /**\n     * @interface ParmsIdType\n     */\n    const self: ParmsIdType = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name ParmsIdType#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance\n       *\n       * @private\n       * @function\n       * @name ParmsIdType#inject\n       * @param {Instance} instance WASM instance\n       */\n      inject(instance: Instance) {\n        self.delete()\n        _instance = new Constructor(instance)\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name ParmsIdType#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * The values of the current ParmsIdType as an Array of BigInts.\n       *\n       * @readonly\n       * @name ParmsIdType#values\n       * @type {BigUint64Array}\n       */\n      get values() {\n        try {\n          const instance = _instance.values()\n          return BigUint64Array.from(instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const ParmsIdTypeInit = ({\n  loader\n}: LoaderOptions): ParmsIdTypeDependencies => {\n  const library: Library = loader.library\n  return ParmsIdTypeConstructor(library)\n}\n","import { Exception, SealError } from './exception'\nimport { Modulus, ModulusConstructorOptions } from './modulus'\nimport { Library, LoaderOptions } from './seal'\nimport { Vector, VectorConstructorOptions } from './vector'\n\nexport interface PlainModulusDependencyOptions {\n  readonly Exception: Exception\n  readonly Modulus: ModulusConstructorOptions\n  readonly Vector: VectorConstructorOptions\n}\n\nexport interface PlainModulusDependencies {\n  ({\n    Exception,\n    Modulus,\n    Vector\n  }: PlainModulusDependencyOptions): PlainModulusConstructorOptions\n}\n\nexport interface PlainModulusConstructorOptions {\n  (): PlainModulus\n}\n\nexport interface PlainModulus {\n  readonly Batching: (polyModulusDegree: number, bitSize: number) => Modulus\n  readonly BatchingVector: (\n    polyModulusDegree: number,\n    bitSizes: Int32Array\n  ) => Vector\n}\n\nconst PlainModulusConstructor =\n  (library: Library): PlainModulusDependencies =>\n  ({\n    Exception,\n    Modulus,\n    Vector\n  }: PlainModulusDependencyOptions): PlainModulusConstructorOptions =>\n  (): PlainModulus => {\n    // Static methods\n    const _Batching = library.PlainModulus.Batching\n    const _BatchingVector = library.PlainModulus.BatchingVector\n\n    /**\n     * @implements PlainModulus\n     */\n\n    /**\n     * @interface PlainModulus\n     */\n    return {\n      /**\n       * Creates a prime number PlainModulus for use as plainPlainModulus encryption\n       * parameter that supports batching with a given polyPlainModulusDegree.\n       *\n       * @function\n       * @name PlainModulus.Batching\n       * @param {number} polyModulusDegree The degree of the polynomial modulus\n       * @param {number} bitSize The bit-size of the desired prime number\n       * @returns {Modulus} A PlainModulus containing the prime number\n       */\n      Batching(polyModulusDegree: number, bitSize: number): Modulus {\n        try {\n          const smallMod = Modulus(BigInt(0))\n          smallMod.inject(_Batching(polyModulusDegree, bitSize))\n          return smallMod\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Creates several prime number PlainModulus elements that can be used as\n       * plainPlainModulus encryption parameters, each supporting batching with a given\n       * polyPlainModulusDegree.\n       *\n       * @function\n       * @name PlainModulus.BatchingVector\n       * @param {Number} polyPlainModulusDegree The degree of the polynomial modulus\n       * @param {Int32Array} bitSizes Int32Array containing values representing bit-sizes of primes\n       * @returns {Vector} Vector of Modulus containing prime numbers\n       */\n      BatchingVector(\n        polyPlainModulusDegree: number,\n        bitSizes: Int32Array\n      ): Vector {\n        try {\n          const vectBitSizes = Vector()\n          vectBitSizes.from(bitSizes)\n          const vect = _BatchingVector(\n            polyPlainModulusDegree,\n            vectBitSizes.instance\n          )\n          vectBitSizes.delete()\n          return vect\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const PlainModulusInit = ({\n  loader\n}: LoaderOptions): PlainModulusDependencies => {\n  const library: Library = loader.library\n  return PlainModulusConstructor(library)\n}\n","import { ComprModeType } from './compr-mode-type'\nimport { INVALID_PLAIN_CONSRUCTOR_OPTIONS } from './constants'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { MemoryPoolHandle } from './memory-pool-handle'\nimport { ParmsIdType, ParmsIdTypeConstructorOptions } from './parms-id-type'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport interface PlainTextDependencyOptions {\n  readonly Exception: Exception\n  readonly ComprModeType: ComprModeType\n  readonly ParmsIdType: ParmsIdTypeConstructorOptions\n  readonly MemoryPoolHandle: MemoryPoolHandle\n  readonly Vector: VectorConstructorOptions\n}\n\nexport interface PlainTextConstructorParams {\n  capacity?: number\n  coeffCount?: number\n  pool?: MemoryPoolHandle\n}\n\nexport type PlainTextDependencies = (\n  deps: PlainTextDependencyOptions\n) => PlainTextConstructorOptions\n\nexport type PlainTextConstructorOptions = (\n  params?: PlainTextConstructorParams\n) => PlainText\n\nexport interface PlainText {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly reserve: (capacity: number) => void\n  readonly shrinkToFit: () => void\n  readonly release: () => void\n  readonly resize: (coeffCount: number) => void\n  readonly setZero: () => void\n  readonly isZero: boolean\n  readonly capacity: number\n  readonly coeffCount: number\n  readonly significantCoeffCount: number\n  readonly nonzeroCoeffCount: number\n  readonly toPolynomial: () => string\n  readonly isNttForm: boolean\n  readonly parmsId: ParmsIdType\n  readonly scale: number\n  readonly setScale: (scale: number) => void\n  readonly pool: MemoryPoolHandle\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n  readonly load: (context: Context, encoded: string) => void\n  readonly loadArray: (context: Context, array: Uint8Array) => void\n  readonly copy: (plain: PlainText) => void\n  readonly clone: () => PlainText\n  readonly move: (plain: PlainText) => void\n}\n\nconst PlainTextConstructor =\n  (library: Library): PlainTextDependencies =>\n  ({\n    Exception,\n    ComprModeType,\n    ParmsIdType,\n    MemoryPoolHandle,\n    Vector\n  }: PlainTextDependencyOptions): PlainTextConstructorOptions =>\n  (params: PlainTextConstructorParams = {}): PlainText => {\n    // Static methods\n    const Constructor = library.Plaintext\n\n    let _instance = construct(params)\n\n    function construct(constructParams: PlainTextConstructorParams = {}) {\n      const {\n        capacity,\n        coeffCount,\n        pool = MemoryPoolHandle.global\n      } = constructParams\n\n      try {\n        if (capacity === undefined && coeffCount === undefined) {\n          return new Constructor(pool)\n        } else if (capacity === undefined && coeffCount !== undefined) {\n          return new Constructor(coeffCount, pool)\n        } else if (capacity !== undefined && coeffCount !== undefined) {\n          return new Constructor(capacity, coeffCount, pool)\n        } else {\n          throw new Error(INVALID_PLAIN_CONSRUCTOR_OPTIONS)\n        }\n      } catch (e) {\n        throw Exception.safe(e as SealError)\n      }\n    }\n    /**\n     * @implements PlainText\n     */\n\n    /**\n     * @interface PlainText\n     */\n    const self: PlainText = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name PlainText#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name PlainText#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        self.delete()\n        _instance = instance\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name PlainText#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Allocates enough memory to accommodate the backing array of a plaintext\n       * with given capacity.\n       *\n       * @function\n       * @name PlainText#reserve\n       * @param {number} capacity The capacity to reserve\n       */\n      reserve(capacity: number) {\n        try {\n          return _instance.reserve(capacity)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Allocates enough memory to accommodate the backing array of the current\n       * PlainText and copies it over to the new location. This function is meant\n       * to reduce the memory use of the PlainText to smallest possible and can be\n       * particularly important after modulus switching.\n       *\n       * @function\n       * @name PlainText#shrinkToFit\n       */\n      shrinkToFit() {\n        _instance.shrinkToFit()\n      },\n\n      /**\n       * Resets the PlainText. This function releases any memory allocated by the\n       * PlainText, returning it to the memory pool.\n       *\n       * @function\n       * @name PlainText#release\n       */\n      release() {\n        _instance.release()\n      },\n\n      /**\n       * Resizes the PlainText to have a given coefficient count. The PlainText\n       * is automatically reallocated if the new coefficient count does not fit in\n       * the current capacity.\n       *\n       * @function\n       * @name PlainText#resize\n       * @param {number} coeffCount The number of coefficients in the plaintext polynomial\n       */\n      resize(coeffCount: number) {\n        try {\n          _instance.resize(coeffCount)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Sets the PlainText polynomial to zero.\n       *\n       * @function\n       * @name PlainText#setZero\n       */\n      setZero() {\n        _instance.setZero()\n      },\n\n      /**\n       * Whether the current PlainText polynomial has all zero coefficients.\n       *\n       * @readonly\n       * @name PlainText#isZero\n       * @type {boolean}\n       */\n      get isZero() {\n        return _instance.isZero()\n      },\n\n      /**\n       * The capacity of the current allocation.\n       *\n       * @readonly\n       * @name PlainText#capacity\n       * @type {number}\n       */\n      get capacity() {\n        return _instance.capacity()\n      },\n\n      /**\n       * The coefficient count of the current PlainText polynomial.\n       *\n       * @readonly\n       * @name PlainText#coeffCount\n       * @type {number}\n       */\n      get coeffCount() {\n        return _instance.coeffCount()\n      },\n\n      /**\n       * The significant coefficient count of the current PlainText polynomial.\n       *\n       * @readonly\n       * @name PlainText#significantCoeffCount\n       * @type {number}\n       */\n      get significantCoeffCount() {\n        return _instance.significantCoeffCount()\n      },\n\n      /**\n       * Returns the non-zero coefficient count of the current PlainText polynomial.\n       *\n       * @readonly\n       * @name PlainText#nonzeroCoeffCount\n       * @type {number}\n       */\n      get nonzeroCoeffCount() {\n        return _instance.nonzeroCoeffCount()\n      },\n\n      /**\n       * Returns a human-readable string description of the PlainText polynomial.\n       *\n       * The returned string is of the form \"7FFx^3 + 1x^1 + 3\" with a format\n       * summarized by the following:\n       * 1. Terms are listed in order of strictly decreasing exponent\n       * 2. Coefficient values are non-negative and in hexadecimal format (hexadecimal\n       * letters are in upper-case)\n       * 3. Exponents are positive and in decimal format\n       * 4. Zero coefficient terms (including the constant term) are omitted unless\n       * the polynomial is exactly 0 (see rule 9)\n       * 5. Term with the exponent value of one is written as x^1\n       * 6. Term with the exponent value of zero (the constant term) is written as\n       * just a hexadecimal number without x or exponent\n       * 7. Terms are separated exactly by <space>+<space>\n       * 8. Other than the +, no other terms have whitespace\n       * 9. If the polynomial is exactly 0, the string \"0\" is returned\n       *\n       * @function\n       * @name PlainText#toPolynomial\n       * @throws std::invalid_argument if the PlainText is in NTT transformed form\n       * @returns {string} Polynomial string\n       */\n      toPolynomial(): string {\n        try {\n          return _instance.toPolynomial()\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Whether the PlainText is in NTT form.\n       *\n       * @readonly\n       * @name PlainText#isNttForm\n       * @type {boolean}\n       */\n      get isNttForm() {\n        return _instance.isNttForm()\n      },\n\n      /**\n       * The reference to parmsId of the PlainText. The parmsId must remain zero unless the\n       * PlainText polynomial is in NTT form.\n       *\n       * @see {@link EncryptionParameters} for more information about parmsId.\n       *\n       * @readonly\n       * @name PlainText#parmsId\n       * @type {ParmsIdType}\n       */\n      get parmsId() {\n        const parms = ParmsIdType()\n        parms.inject(_instance.parmsId())\n        return parms\n      },\n\n      /**\n       * The reference to the scale. This is only needed when using the CKKS\n       * encryption scheme. The user should have little or no reason to ever change\n       * the scale by hand.\n       *\n       * @readonly\n       * @name PlainText#scale\n       * @type {number}\n       */\n      get scale() {\n        return _instance.scale()\n      },\n\n      /**\n       * Sets the PlainText scale. This is only needed when using the\n       * CKKS encryption scheme. The user should have little or no reason to ever\n       * change the scale by hand.\n       *\n       * @function\n       * @name PlainText#setScale\n       * @param {number} scale The scale to set\n       */\n      setScale(scale: number) {\n        _instance.setScale(scale)\n      },\n\n      /**\n       * The currently used MemoryPoolHandle.\n       *\n       * @readonly\n       * @name PlainText#pool\n       * @type {MemoryPoolHandle}\n       */\n      get pool() {\n        return _instance.pool()\n      },\n\n      /**\n       * Save the PlainText to a base64 string\n       *\n       * @function\n       * @name PlainText#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} Base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        return _instance.saveToString(compression)\n      },\n\n      /**\n       * Save the PlainText as a binary Uint8Array\n       *\n       * @function\n       * @name PlainText#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the PlainText in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Load a PlainText from a base64 string\n       *\n       * @function\n       * @name PlainText#load\n       * @param {Context} context Encryption context to enforce\n       * @param {string} encoded Base64 encoded string\n       */\n      load(context: Context, encoded: string) {\n        try {\n          _instance.loadFromString(context.instance, encoded)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Load a PlainText from an Uint8Array holding binary data\n       *\n       * @function\n       * @name PlainText#loadArray\n       * @param {Context} context Encryption context to enforce\n       * @param {Uint8Array} array TypedArray containing binary data\n       */\n      loadArray(context: Context, array: Uint8Array) {\n        try {\n          _instance.loadFromArray(context.instance, array)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Copy an existing PlainText and overwrite this instance\n       *\n       * @function\n       * @name PlainText#copy\n       * @param {PlainText} plain PlainText to copy\n       * @example\n       * const plainTextA = seal.PlainText()\n       * // ... after encoding some data ...\n       * const plainTextB = seal.PlainText()\n       * plainTextB.copy(plainTextA)\n       * // plainTextB holds a copy of plainTextA\n       */\n      copy(plain: PlainText) {\n        try {\n          _instance.copy(plain.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Clone and return a new instance of this PlainText\n       *\n       * @function\n       * @name PlainText#clone\n       * @returns {PlainText}\n       * @example\n       * const plainTextA = seal.PlainText()\n       * // ... after encoding some data ...\n       * const plainTextB = plainTextA.clone()\n       * // plainTextB holds a copy of plainTextA\n       */\n      clone(): PlainText {\n        try {\n          const clonedInstance = _instance.clone()\n          const plain = PlainTextConstructor(library)({\n            Exception,\n            ComprModeType,\n            ParmsIdType,\n            MemoryPoolHandle,\n            Vector\n          })()\n          plain.unsafeInject(clonedInstance)\n          return plain\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Move a PlainText into this one and delete the old reference\n       *\n       * @function\n       * @name PlainText#move\n       * @param {PlainText} plain PlainText to move\n       * @example\n       * const plainTextA = seal.PlainText()\n       * // ... after encoding some data ...\n       * const plainTextB = seal.PlainText()\n       * plainTextB.move(plainTextA)\n       * // plainTextB holds a the instance of plainTextA.\n       * // plainTextA no longer holds an instance\n       */\n      move(plain: PlainText) {\n        try {\n          _instance.move(plain.instance)\n          // TODO: find optimization\n          // This method results in a copy instead of a real move.\n          // Therefore, we need to delete the old instance.\n          plain.delete()\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const PlainTextInit = ({\n  loader\n}: LoaderOptions): PlainTextDependencies => {\n  const library: Library = loader.library\n  return PlainTextConstructor(library)\n}\n","import { ComprModeType } from './compr-mode-type'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport interface PublicKeyDependencyOptions {\n  readonly Exception: Exception\n  readonly ComprModeType: ComprModeType\n  readonly Vector: VectorConstructorOptions\n}\n\nexport interface PublicKeyDependencies {\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: PublicKeyDependencyOptions): PublicKeyConstructorOptions\n}\n\nexport interface PublicKeyConstructorOptions {\n  (): PublicKey\n}\n\nexport interface PublicKey {\n  readonly instance: Instance\n  readonly inject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n  readonly load: (context: Context, encoded: string) => void\n  readonly loadArray: (context: Context, array: Uint8Array) => void\n  readonly copy: (key: PublicKey) => void\n  readonly clone: () => PublicKey\n  readonly move: (key: PublicKey) => void\n}\n\nconst PublicKeyConstructor =\n  (library: Library): PublicKeyDependencies =>\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: PublicKeyDependencyOptions): PublicKeyConstructorOptions =>\n  (): PublicKey => {\n    const Constructor = library.PublicKey\n    let _instance = new Constructor()\n\n    /**\n     * @implements PublicKey\n     */\n\n    /**\n     * @interface PublicKey\n     */\n    const self: PublicKey = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name PublicKey#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance\n       *\n       * @private\n       * @function\n       * @name PublicKey#inject\n       * @param {Instance} instance WASM instance\n       */\n      inject(instance: Instance) {\n        self.delete()\n        _instance = new Constructor(instance)\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name PublicKey#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Save the Encryption Parameters to a base64 string\n       *\n       * @function\n       * @name PublicKey#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} Base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        try {\n          return _instance.saveToString(compression)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Save the PublicKey as a binary Uint8Array\n       *\n       * @function\n       * @name PublicKey#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the PublicKey in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Load a PublicKey from a base64 string\n       *\n       * @function\n       * @name PublicKey#load\n       * @param {Context} context Encryption context to enforce\n       * @param {string} encoded Base64 encoded string\n       */\n      load(context: Context, encoded: string) {\n        try {\n          _instance.loadFromString(context.instance, encoded)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Load a PublicKey from an Uint8Array holding binary data\n       *\n       * @function\n       * @name PublicKey#loadArray\n       * @param {Context} context Encryption context to enforce\n       * @param {Uint8Array} array TypedArray containing binary data\n       */\n      loadArray(context: Context, array: Uint8Array) {\n        try {\n          _instance.loadFromArray(context.instance, array)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Copy an existing PublicKey and overwrite this instance\n       *\n       * @function\n       * @name PublicKey#copy\n       * @param {PublicKey} key PublicKey to copy\n       * @example\n       * const keyA = keyGenerator.createPublicKey()\n       * const keyB = seal.PublicKey()\n       * keyB.copy(keyA)\n       * // keyB holds a copy of keyA\n       */\n      copy(key: PublicKey) {\n        try {\n          _instance.copy(key.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Clone and return a new instance of this PublicKey\n       *\n       * @function\n       * @name PublicKey#clone\n       * @returns {PublicKey}\n       * @example\n       * const keyA = keyGenerator.createPublicKey()\n       * const keyB = keyA.clone()\n       * // keyB holds a copy of keyA\n       */\n      clone(): PublicKey {\n        try {\n          const clonedInstance = _instance.clone()\n          const key = PublicKeyConstructor(library)({\n            Exception,\n            ComprModeType,\n            Vector\n          })()\n          key.inject(clonedInstance)\n          return key\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Move a PublicKey into this one and delete the old reference\n       *\n       * @function\n       * @name PublicKey#move\n       * @param {PublicKey} key PublicKey to move\n       * @example\n       * const keyA = keyGenerator.createPublicKey()\n       * const keyB = seal.PublicKey()\n       * keyB.move(keyA)\n       * // keyB holds a the instance of keyA.\n       * // keyA no longer holds an instance\n       */\n      move(key: PublicKey) {\n        try {\n          _instance.move(key.instance)\n          // TODO: find optimization\n          // This method results in a copy instead of a real move.\n          // Therefore, we need to delete the old instance.\n          key.delete()\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const PublicKeyInit = ({\n  loader\n}: LoaderOptions): PublicKeyDependencies => {\n  const library: Library = loader.library\n  return PublicKeyConstructor(library)\n}\n","import { ComprModeType } from './compr-mode-type'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport interface RelinKeysDependencyOptions {\n  readonly Exception: Exception\n  readonly ComprModeType: ComprModeType\n  readonly Vector: VectorConstructorOptions\n}\n\nexport interface RelinKeysDependencies {\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: RelinKeysDependencyOptions): RelinKeysConstructorOptions\n}\n\nexport interface RelinKeysConstructorOptions {\n  (): RelinKeys\n}\n\nexport interface RelinKeys {\n  readonly instance: Instance\n  readonly inject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly size: number\n  readonly getIndex: (keyPower: number) => number\n  readonly hasKey: (keyPower: number) => boolean\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n  readonly load: (context: Context, encoded: string) => void\n  readonly loadArray: (context: Context, array: Uint8Array) => void\n  readonly copy: (key: RelinKeys) => void\n  readonly clone: () => RelinKeys\n  readonly move: (key: RelinKeys) => void\n}\n\nconst RelinKeysConstructor =\n  (library: Library): RelinKeysDependencies =>\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: RelinKeysDependencyOptions): RelinKeysConstructorOptions =>\n  (): RelinKeys => {\n    const Constructor = library.RelinKeys\n    let _instance = new Constructor()\n\n    /**\n     * @implements RelinKeys\n     */\n\n    /**\n     * @interface RelinKeys\n     */\n    const self: RelinKeys = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name RelinKeys#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance\n       *\n       * @private\n       * @function\n       * @name RelinKeys#inject\n       * @param {Instance} instance WASM instance\n       */\n      inject(instance: Instance) {\n        self.delete()\n        _instance = new Constructor(instance)\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name RelinKeys#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Returns the current number of keyswitching keys. Only keys that are\n       * non-empty are counted.\n       *\n       * @readonly\n       * @name RelinKeys#size\n       * @type {number}\n       */\n      get size() {\n        return _instance.size()\n      },\n\n      /**\n       * Returns the index of a relinearization key in the backing KSwitchKeys\n       * instance that corresponds to the given secret key power, assuming that\n       * it exists in the backing KSwitchKeys.\n       *\n       * @function\n       * @name RelinKeys#getIndex\n       * @param {number} keyPower The power of the secret key\n       * @returns {number} The index of the relin key\n       */\n      getIndex(keyPower: number): number {\n        try {\n          return _instance.getIndex(keyPower)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Returns whether a relinearization key corresponding to a given power of\n       * the secret key exists.\n       *\n       * @function\n       * @name RelinKeys#hasKey\n       * @param {number} keyPower The power of the secret key\n       * @returns {boolean} True if the power exists\n       */\n      hasKey(keyPower: number): boolean {\n        try {\n          return _instance.hasKey(keyPower)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Save the Encryption Parameters to a base64 string\n       *\n       * @function\n       * @name RelinKeys#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} Base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        try {\n          return _instance.saveToString(compression)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Save the RelinKeys as a binary Uint8Array\n       *\n       * @function\n       * @name RelinKeys#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the RelinKeys in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Load a RelinKeys from a base64 string\n       *\n       * @function\n       * @name RelinKeys#load\n       * @param {Context} context Encryption context to enforce\n       * @param {string} encoded Base64 encoded string\n       */\n      load(context: Context, encoded: string) {\n        try {\n          _instance.loadFromString(context.instance, encoded)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Load a RelinKeys from an Uint8Array holding binary data\n       *\n       * @function\n       * @name RelinKeys#loadArray\n       * @param {Context} context Encryption context to enforce\n       * @param {Uint8Array} array TypedArray containing binary data\n       */\n      loadArray(context: Context, array: Uint8Array) {\n        try {\n          _instance.loadFromArray(context.instance, array)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Copy an existing RelinKeys and overwrite this instance\n       *\n       * @function\n       * @name RelinKeys#copy\n       * @param {RelinKeys} key RelinKeys to copy\n       * @example\n       * const keyA = keyGenerator.createRelinKeys()\n       * const keyB = seal.RelinKeys()\n       * keyB.copy(keyA)\n       * // keyB holds a copy of keyA\n       */\n      copy(key: RelinKeys) {\n        try {\n          _instance.copy(key.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Clone and return a new instance of this RelinKeys\n       *\n       * @function\n       * @name RelinKeys#clone\n       * @returns {RelinKeys}\n       * @example\n       * const keyA = keyGenerator.createRelinKeys()\n       * const keyB = keyA.clone()\n       * // keyB holds a copy of keyA\n       */\n      clone(): RelinKeys {\n        try {\n          const clonedInstance = _instance.clone()\n          const key = RelinKeysConstructor(library)({\n            Exception,\n            ComprModeType,\n            Vector\n          })()\n          key.inject(clonedInstance)\n          return key\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Move a RelinKeys into this one and delete the old reference\n       *\n       * @function\n       * @name RelinKeys#move\n       * @param {RelinKeys} key RelinKeys to move\n       * @example\n       * const keyA = keyGenerator.createRelinKeys()\n       * const keyB = seal.RelinKeys()\n       * keyB.move(keyA)\n       * // keyB holds a the instance of keyA.\n       * // keyA no longer holds an instance\n       */\n      move(key: RelinKeys) {\n        try {\n          _instance.move(key.instance)\n          // TODO: find optimization\n          // This method results in a copy instead of a real move.\n          // Therefore, we need to delete the old instance.\n          key.delete()\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const RelinKeysInit = ({\n  loader\n}: LoaderOptions): RelinKeysDependencies => {\n  const library: Library = loader.library\n  return RelinKeysConstructor(library)\n}\n","import { Library, LoaderOptions } from './seal'\n\nexport interface SchemeTypeDependencies {\n  (): SchemeTypeConstructorOptions\n}\n\nexport interface SchemeTypeConstructorOptions {\n  (): SchemeType\n}\n\nexport interface SchemeType {\n  readonly none: any\n  readonly bfv: any\n  readonly ckks: any\n  readonly bgv: any\n}\n\nconst SchemeTypeConstructor =\n  (library: Library): SchemeTypeDependencies =>\n  (): SchemeTypeConstructorOptions =>\n  (): SchemeType => {\n    // Static methods\n    const _none = library.SchemeType.none\n    const _bfv = library.SchemeType.bfv\n    const _ckks = library.SchemeType.ckks\n    const _bgv = library.SchemeType.bgv\n\n    /**\n     * @implements SchemeType\n     */\n\n    /**\n     * @interface SchemeType\n     */\n    return {\n      /**\n       * Return the 'none' scheme type\n       *\n       * @readonly\n       * @name SchemeType.none\n       * @type {SchemeType.none}\n       */\n      get none() {\n        /**\n         * @typedef {SchemeType.none} SchemeType.none\n         */\n        return _none\n      },\n\n      /**\n       * Return the 'bfv' scheme type\n       *\n       * @readonly\n       * @name SchemeType.bfv\n       * @type {SchemeType.bfv}\n       */\n      get bfv() {\n        /**\n         * @typedef {SchemeType.bfv} SchemeType.bfv\n         */\n        return _bfv\n      },\n\n      /**\n       * Return the 'ckks' scheme type\n       *\n       * @readonly\n       * @name SchemeType.ckks\n       * @type {SchemeType.ckks}\n       */\n      get ckks() {\n        /**\n         * @typedef {SchemeType.ckks} SchemeType.ckks\n         */\n        return _ckks\n      },\n\n      /**\n       * Return the 'bgv' scheme type\n       *\n       * @readonly\n       * @name SchemeType.bgv\n       * @type {SchemeType.bgv}\n       */\n      get bgv() {\n        /**\n         * @typedef {SchemeType.bgv} SchemeType.bgv\n         */\n        return _bgv\n      }\n    }\n  }\n\nexport const SchemeTypeInit = ({\n  loader\n}: LoaderOptions): SchemeTypeDependencies => {\n  const library: Library = loader.library\n  return SchemeTypeConstructor(library)\n}\n","import { version } from '../../package.json'\nimport {\n  BatchEncoderConstructorOptions,\n  BatchEncoderDependencies\n} from './batch-encoder'\nimport {\n  CipherTextConstructorOptions,\n  CipherTextDependencies\n} from './cipher-text'\nimport {\n  CKKSEncoderConstructorOptions,\n  CKKSEncoderDependencies\n} from './ckks-encoder'\nimport { CoeffModulus, CoeffModulusDependencies } from './coeff-modulus'\nimport { ComprModeType, ComprModeTypeDependencies } from './compr-mode-type'\nimport { ContextConstructorOptions, ContextDependencies } from './context'\nimport {\n  ContextDataConstructorOptions,\n  ContextDataDependencies\n} from './context-data'\nimport { DecryptorConstructorOptions, DecryptorDependencies } from './decryptor'\nimport {\n  EncryptionParameterQualifiersConstructorOptions,\n  EncryptionParameterQualifiersDependencies\n} from './encryption-parameter-qualifiers'\nimport {\n  EncryptionParametersConstructorOptions,\n  EncryptionParametersDependencies\n} from './encryption-parameters'\nimport { EncryptorConstructorOptions, EncryptorDependencies } from './encryptor'\nimport { EvaluatorConstructorOptions, EvaluatorDependencies } from './evaluator'\nimport { Exception, ExceptionDependencies } from './exception'\nimport {\n  GaloisKeysConstructorOptions,\n  GaloisKeysDependencies\n} from './galois-keys'\nimport {\n  KeyGeneratorConstructorOptions,\n  KeyGeneratorDependencies\n} from './key-generator'\nimport {\n  MemoryPoolHandle,\n  MemoryPoolHandleDependencies\n} from './memory-pool-handle'\nimport { ModulusConstructorOptions, ModulusDependencies } from './modulus'\nimport {\n  ParmsIdTypeConstructorOptions,\n  ParmsIdTypeDependencies\n} from './parms-id-type'\nimport { PlainModulus, PlainModulusDependencies } from './plain-modulus'\nimport {\n  PlainTextConstructorOptions,\n  PlainTextDependencies\n} from './plain-text'\nimport {\n  PublicKeyConstructorOptions,\n  PublicKeyDependencies\n} from './public-key'\nimport {\n  RelinKeysConstructorOptions,\n  RelinKeysDependencies\n} from './relin-keys'\nimport { SchemeType, SchemeTypeDependencies } from './scheme-type'\nimport {\n  SecretKeyConstructorOptions,\n  SecretKeyDependencies\n} from './secret-key'\nimport { SecurityLevel, SecurityLevelDependencies } from './security-level'\nimport {\n  SerializableConstructorOptions,\n  SerializableDependencies\n} from './serializable'\nimport { VectorConstructorOptions, VectorDependencies } from './vector'\n\nexport type Instance = any\nexport type Loader = any\nexport type Library = any\nexport type Dependencies = any\nexport interface LoaderOptions {\n  readonly loader: Loader\n}\n\nexport interface SEALLibrary {\n  readonly BatchEncoder: BatchEncoderConstructorOptions\n  readonly CipherText: CipherTextConstructorOptions\n  readonly CKKSEncoder: CKKSEncoderConstructorOptions\n  readonly CoeffModulus: CoeffModulus\n  readonly ComprModeType: ComprModeType\n  readonly ContextData: ContextDataConstructorOptions\n  readonly Context: ContextConstructorOptions\n  readonly Decryptor: DecryptorConstructorOptions\n  readonly EncryptionParameterQualifiers: EncryptionParameterQualifiersConstructorOptions\n  readonly EncryptionParameters: EncryptionParametersConstructorOptions\n  readonly Encryptor: EncryptorConstructorOptions\n  readonly Evaluator: EvaluatorConstructorOptions\n  readonly Exception: Exception\n  readonly GaloisKeys: GaloisKeysConstructorOptions\n  readonly KeyGenerator: KeyGeneratorConstructorOptions\n  readonly MemoryPoolHandle: MemoryPoolHandle\n  readonly Modulus: ModulusConstructorOptions\n  readonly ParmsIdType: ParmsIdTypeConstructorOptions\n  readonly PlainText: PlainTextConstructorOptions\n  readonly PlainModulus: PlainModulus\n  readonly PublicKey: PublicKeyConstructorOptions\n  readonly RelinKeys: RelinKeysConstructorOptions\n  readonly SchemeType: SchemeType\n  readonly SecretKey: SecretKeyConstructorOptions\n  readonly SecurityLevel: SecurityLevel\n  readonly Serializable: SerializableConstructorOptions\n  readonly Vector: VectorConstructorOptions\n  readonly Version: string\n}\ninterface SEALConstructorOptions {\n  readonly BatchEncoder: BatchEncoderDependencies\n  readonly CipherText: CipherTextDependencies\n  readonly CKKSEncoder: CKKSEncoderDependencies\n  readonly CoeffModulus: CoeffModulusDependencies\n  readonly ComprModeType: ComprModeTypeDependencies\n  readonly ContextData: ContextDataDependencies\n  readonly Context: ContextDependencies\n  readonly Decryptor: DecryptorDependencies\n  readonly EncryptionParameterQualifiers: EncryptionParameterQualifiersDependencies\n  readonly EncryptionParameters: EncryptionParametersDependencies\n  readonly Encryptor: EncryptorDependencies\n  readonly Evaluator: EvaluatorDependencies\n  readonly Exception: ExceptionDependencies\n  readonly GaloisKeys: GaloisKeysDependencies\n  readonly KeyGenerator: KeyGeneratorDependencies\n  readonly MemoryPoolHandle: MemoryPoolHandleDependencies\n  readonly Modulus: ModulusDependencies\n  readonly ParmsIdType: ParmsIdTypeDependencies\n  readonly PlainText: PlainTextDependencies\n  readonly PlainModulus: PlainModulusDependencies\n  readonly PublicKey: PublicKeyDependencies\n  readonly RelinKeys: RelinKeysDependencies\n  readonly SchemeType: SchemeTypeDependencies\n  readonly SecretKey: SecretKeyDependencies\n  readonly SecurityLevel: SecurityLevelDependencies\n  readonly Serializable: SerializableDependencies\n  readonly Vector: VectorDependencies\n}\n\n/**\n * @implements SEAL\n */\nexport const SEALConstructor = ({\n  BatchEncoder,\n  CipherText,\n  CKKSEncoder,\n  CoeffModulus,\n  ComprModeType,\n  ContextData,\n  Context,\n  Decryptor,\n  EncryptionParameterQualifiers,\n  EncryptionParameters,\n  Encryptor,\n  Evaluator,\n  Exception,\n  GaloisKeys,\n  KeyGenerator,\n  MemoryPoolHandle,\n  Modulus,\n  ParmsIdType,\n  PlainText,\n  PlainModulus,\n  PublicKey,\n  RelinKeys,\n  SchemeType,\n  SecretKey,\n  SecurityLevel,\n  Serializable,\n  Vector\n}: SEALConstructorOptions): SEALLibrary => {\n  // Unfortunately, this library has nested depenencies\n  // so we need to load them in order.\n\n  // Define our singletons\n  const exception = Exception()()\n  const comprModeType = ComprModeType()()\n  const memoryPoolHandle = MemoryPoolHandle()()\n  const securityLevel = SecurityLevel()()\n  const schemeType = SchemeType()()\n\n  // Define our constructors (ORDER MATTERS)\n  const vector = Vector({ Exception: exception })\n  const coeffModulus = CoeffModulus({\n    Exception: exception,\n    SecurityLevel: securityLevel,\n    Vector: vector\n  })()\n  const modulus = Modulus({\n    Exception: exception,\n    ComprModeType: comprModeType,\n    Vector: vector\n  })\n  const plainModulus = PlainModulus({\n    Exception: exception,\n    Modulus: modulus,\n    Vector: vector\n  })()\n  const serializable = Serializable({\n    Exception: exception,\n    Vector: vector,\n    ComprModeType: comprModeType\n  })\n  const parmsIdType = ParmsIdType({ Exception: exception })\n  const plainText = PlainText({\n    Exception: exception,\n    ComprModeType: comprModeType,\n    ParmsIdType: parmsIdType,\n    MemoryPoolHandle: memoryPoolHandle,\n    Vector: vector\n  })\n  const cipherText = CipherText({\n    Exception: exception,\n    ComprModeType: comprModeType,\n    ParmsIdType: parmsIdType,\n    MemoryPoolHandle: memoryPoolHandle,\n    Vector: vector\n  })\n  const batchEncoder = BatchEncoder({\n    Exception: exception,\n    MemoryPoolHandle: memoryPoolHandle,\n    PlainText: plainText,\n    Vector: vector\n  })\n  const ckksEncoder = CKKSEncoder({\n    Exception: exception,\n    MemoryPoolHandle: memoryPoolHandle,\n    PlainText: plainText,\n    Vector: vector\n  })\n  const encryptionParameterQualifiers = EncryptionParameterQualifiers()\n  const encryptionParameters = EncryptionParameters({\n    Exception: exception,\n    ComprModeType: comprModeType,\n    Modulus: modulus,\n    SchemeType: schemeType,\n    ParmsIdType: parmsIdType,\n    Vector: vector\n  })\n  const contextData = ContextData({\n    Exception: exception,\n    EncryptionParameters: encryptionParameters,\n    ParmsIdType: parmsIdType,\n    EncryptionParameterQualifiers: encryptionParameterQualifiers\n  })\n  const context = Context({\n    ParmsIdType: parmsIdType,\n    ContextData: contextData,\n    SecurityLevel: securityLevel\n  })\n  const decryptor = Decryptor({\n    Exception: exception,\n    PlainText: plainText\n  })\n  const encryptor = Encryptor({\n    Exception: exception,\n    MemoryPoolHandle: memoryPoolHandle,\n    CipherText: cipherText,\n    Serializable: serializable\n  })\n  const evaluator = Evaluator({\n    Exception: exception,\n    MemoryPoolHandle: memoryPoolHandle,\n    CipherText: cipherText,\n    PlainText: plainText\n  })\n  const publicKey = PublicKey({\n    Exception: exception,\n    ComprModeType: comprModeType,\n    Vector: vector\n  })\n  const secretKey = SecretKey({\n    Exception: exception,\n    ComprModeType: comprModeType,\n    Vector: vector\n  })\n  const relinKeys = RelinKeys({\n    Exception: exception,\n    ComprModeType: comprModeType,\n    Vector: vector\n  })\n  const galoisKeys = GaloisKeys({\n    Exception: exception,\n    ComprModeType: comprModeType,\n    Vector: vector\n  })\n  const keyGenerator = KeyGenerator({\n    Exception: exception,\n    PublicKey: publicKey,\n    SecretKey: secretKey,\n    RelinKeys: relinKeys,\n    GaloisKeys: galoisKeys,\n    Serializable: serializable\n  })\n\n  /**\n   * @interface SEAL\n   */\n  return {\n    BatchEncoder: batchEncoder,\n    CipherText: cipherText,\n    CKKSEncoder: ckksEncoder,\n    CoeffModulus: coeffModulus, // Singleton\n    ComprModeType: comprModeType, // Singleton\n    ContextData: contextData,\n    Context: context,\n    Decryptor: decryptor,\n    EncryptionParameterQualifiers: encryptionParameterQualifiers,\n    EncryptionParameters: encryptionParameters,\n    Encryptor: encryptor,\n    Evaluator: evaluator,\n    Exception: exception, // Singleton\n    GaloisKeys: galoisKeys,\n    KeyGenerator: keyGenerator,\n    MemoryPoolHandle: memoryPoolHandle, // Singleton\n    Modulus: modulus,\n    ParmsIdType: parmsIdType,\n    PlainText: plainText,\n    PlainModulus: plainModulus, // Singleton\n    PublicKey: publicKey,\n    RelinKeys: relinKeys,\n    SchemeType: schemeType,\n    SecretKey: secretKey,\n    SecurityLevel: securityLevel, // Singleton\n    Serializable: serializable,\n    Vector: vector,\n    Version: version\n  }\n}\n","import { ComprModeType } from './compr-mode-type'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport interface SecretKeyDependencyOptions {\n  readonly Exception: Exception\n  readonly ComprModeType: ComprModeType\n  readonly Vector: VectorConstructorOptions\n}\n\nexport interface SecretKeyDependencies {\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: SecretKeyDependencyOptions): SecretKeyConstructorOptions\n}\n\nexport interface SecretKeyConstructorOptions {\n  (): SecretKey\n}\n\nexport interface SecretKey {\n  readonly instance: Instance\n  readonly inject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n  readonly load: (context: Context, encoded: string) => void\n  readonly loadArray: (context: Context, array: Uint8Array) => void\n  readonly copy: (key: SecretKey) => void\n  readonly clone: () => SecretKey\n  readonly move: (key: SecretKey) => void\n}\n\nconst SecretKeyConstructor =\n  (library: Library): SecretKeyDependencies =>\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: SecretKeyDependencyOptions): SecretKeyConstructorOptions =>\n  (): SecretKey => {\n    const Constructor = library.SecretKey\n    let _instance = new Constructor()\n\n    /**\n     * @implements SecretKey\n     */\n\n    /**\n     * @interface SecretKey\n     */\n    const self: SecretKey = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name SecretKey#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance\n       *\n       * @private\n       * @function\n       * @name SecretKey#inject\n       * @param {Instance} instance WASM instance\n       */\n      inject(instance: Instance) {\n        self.delete()\n        _instance = new Constructor(instance)\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name SecretKey#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Save the Encryption Parameters to a base64 string\n       *\n       * @function\n       * @name SecretKey#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} Base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        try {\n          return _instance.saveToString(compression)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Save the SecretKey as a binary Uint8Array\n       *\n       * @function\n       * @name SecretKey#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the SecretKey in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Load a SecretKey from a base64 string\n       *\n       * @function\n       * @name SecretKey#load\n       * @param {Context} context Encryption context to enforce\n       * @param {string} encoded Base64 encoded string\n       */\n      load(context: Context, encoded: string) {\n        try {\n          _instance.loadFromString(context.instance, encoded)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Load a SecretKey from an Uint8Array holding binary data\n       *\n       * @function\n       * @name SecretKey#loadArray\n       * @param {Context} context Encryption context to enforce\n       * @param {Uint8Array} array TypedArray containing binary data\n       */\n      loadArray(context: Context, array: Uint8Array) {\n        try {\n          _instance.loadFromArray(context.instance, array)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Copy an existing SecretKey and overwrite this instance\n       *\n       * @function\n       * @name SecretKey#copy\n       * @param {SecretKey} key SecretKey to copy\n       * @example\n       * const keyA = keyGenerator.secretKey()\n       * const keyB = seal.SecretKey()\n       * keyB.copy(keyA)\n       * // keyB holds a copy of keyA\n       */\n      copy(key: SecretKey) {\n        try {\n          _instance.copy(key.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Clone and return a new instance of this SecretKey\n       *\n       * @function\n       * @name SecretKey#clone\n       * @returns {SecretKey}\n       * @example\n       * const keyA = keyGenerator.secretKey()\n       * const keyB = keyA.clone()\n       * // keyB holds a copy of keyA\n       */\n      clone(): SecretKey {\n        try {\n          const clonedInstance = _instance.clone()\n          const key = SecretKeyConstructor(library)({\n            Exception,\n            ComprModeType,\n            Vector\n          })()\n          key.inject(clonedInstance)\n          return key\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Move a SecretKey into this one and delete the old reference\n       *\n       * @function\n       * @name SecretKey#move\n       * @param {SecretKey} key SecretKey to move\n       * @example\n       * const keyA = keyGenerator.secretKey()\n       * const keyB = seal.SecretKey()\n       * keyB.move(keyA)\n       * // keyB holds a the instance of keyA.\n       * // keyA no longer holds an instance\n       */\n      move(key: SecretKey) {\n        try {\n          _instance.move(key.instance)\n          // TODO: find optimization\n          // This method results in a copy instead of a real move.\n          // Therefore, we need to delete the old instance.\n          key.delete()\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const SecretKeyInit = ({\n  loader\n}: LoaderOptions): SecretKeyDependencies => {\n  const library: Library = loader.library\n  return SecretKeyConstructor(library)\n}\n","import { Library, LoaderOptions } from './seal'\n\nexport interface SecurityLevelDependencies {\n  (): SecurityLevelConstructorOptions\n}\n\nexport interface SecurityLevelConstructorOptions {\n  (): SecurityLevel\n}\n\nexport interface SecurityLevel {\n  readonly none: any\n  readonly tc128: any\n  readonly tc192: any\n  readonly tc256: any\n}\n\nconst SecurityLevelConstructor =\n  (library: Library): SecurityLevelDependencies =>\n  (): SecurityLevelConstructorOptions =>\n  (): SecurityLevel => {\n    // Static methods\n    const _none = library.SecLevelType.none\n    const _tc128 = library.SecLevelType.tc128\n    const _tc192 = library.SecLevelType.tc192\n    const _tc256 = library.SecLevelType.tc256\n\n    /**\n     * @implements SecurityLevel\n     */\n\n    /**\n     * @interface SecurityLevel\n     */\n    return {\n      /**\n       * Returns the 'none' security level\n       *\n       * @readonly\n       * @name SecurityLevel.none\n       * @type {SecurityLevel.none}\n       */\n      get none() {\n        /**\n         * @typedef {SecurityLevel.none} SecurityLevel.none\n         */\n        return _none\n      },\n\n      /**\n       * Returns the '128' security level\n       *\n       * @readonly\n       * @name SecurityLevel.tc128\n       * @type {SecurityLevel.tc128}\n       */\n      get tc128() {\n        /**\n         * @typedef {SecurityLevel.tc128} SecurityLevel.tc128\n         */\n        return _tc128\n      },\n\n      /**\n       * Returns the '192' security level\n       *\n       * @readonly\n       * @name SecurityLevel.tc192\n       * @type {SecurityLevel.tc192}\n       */\n      get tc192() {\n        /**\n         * @typedef {SecurityLevel.tc192} SecurityLevel.tc192\n         */\n        return _tc192\n      },\n\n      /**\n       * Returns the '256' security level\n       *\n       * @readonly\n       * @name SecurityLevel.tc256\n       * @type {SecurityLevel.tc256}\n       */\n      get tc256() {\n        /**\n         * @typedef {SecurityLevel.tc256} SecurityLevel.tc256\n         */\n        return _tc256\n      }\n    }\n  }\nexport const SecurityLevelInit = ({\n  loader\n}: LoaderOptions): SecurityLevelDependencies => {\n  const library: Library = loader.library\n  return SecurityLevelConstructor(library)\n}\n","import { ComprModeType } from './compr-mode-type'\nimport { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { Instance } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport interface SerializableDependencyOptions {\n  readonly Exception: Exception\n  readonly Vector: VectorConstructorOptions\n  readonly ComprModeType: ComprModeType\n}\n\nexport interface SerializableDependencies {\n  ({\n    Exception,\n    Vector,\n    ComprModeType\n  }: SerializableDependencyOptions): SerializableConstructorOptions\n}\n\nexport interface SerializableConstructorOptions {\n  (): Serializable\n}\n\nexport interface Serializable {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n}\n\nconst SerializableConstructor =\n  (): SerializableDependencies =>\n  ({\n    Exception,\n    Vector,\n    ComprModeType\n  }: SerializableDependencyOptions): SerializableConstructorOptions =>\n  (): Serializable => {\n    let _instance: Instance\n\n    /**\n     * @implements Serializable\n     */\n\n    /**\n     * @interface Serializable\n     */\n    const self: Serializable = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name Serializable#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name Serializable#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        self.delete()\n        _instance = instance\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name Serializable#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Save to a base64 string\n       *\n       * @function\n       * @name Serializable#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} Base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        try {\n          return _instance.saveToString(compression)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Save as a binary Uint8Array\n       *\n       * @function\n       * @name Serializable#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the Serializable object in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const SerializableInit = (): SerializableDependencies => {\n  return SerializableConstructor()\n}\n","import { INSTANCE_DELETED, UNSUPPORTED_VECTOR_TYPE } from './constants'\nimport { Exception, SealError } from './exception'\nimport { autoFinalize } from './finalizer'\nimport { Instance, Library, LoaderOptions } from './seal'\n\nexport interface VectorDependencyOptions {\n  readonly Exception: Exception\n}\n\nexport interface VectorDependencies {\n  ({ Exception }: VectorDependencyOptions): VectorConstructorOptions\n}\n\nexport interface VectorConstructorOptions {\n  (): Vector\n}\n\nexport interface Vector {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly from: (array: VectorTypes, type?: StringTypes) => Instance\n  readonly type: string\n  readonly setType: (type: StringTypes) => void\n  readonly size: number\n  readonly getValue: (index: number) => number\n  readonly resize: (size: number, fill: number) => void\n  readonly toArray: () => VectorTypes\n}\n\nexport type VectorTypes =\n  | Uint8Array\n  | Int32Array\n  | Uint32Array\n  | Float64Array\n  | BigInt64Array\n  | BigUint64Array\n\nexport type StringTypes =\n  | 'Uint8Array'\n  | 'Int32Array'\n  | 'Uint32Array'\n  | 'Float64Array'\n  | 'BigInt64Array'\n  | 'BigUint64Array'\n  | 'Modulus'\n\nconst VectorConstructor =\n  (library: Library): VectorDependencies =>\n  ({ Exception }: VectorDependencyOptions): VectorConstructorOptions =>\n  (): Vector => {\n    // Static methods\n    const _vecFromArrayUint8 = library.vecFromArrayUint8\n    const _vecFromArrayUint32 = library.vecFromArrayUint32\n    const _vecFromArrayInt32 = library.vecFromArrayInt32\n    const _vecFromArrayFloat64 = library.vecFromArrayFloat64\n    const _vecFromArrayBigInt64 = library.vecFromArrayBigInt64\n    const _vecFromArrayBigUint64 = library.vecFromArrayBigUint64\n    const _vecFromArrayModulus = library.vecFromArrayModulus\n    const _jsArrayUint8FromVec = library.jsArrayUint8FromVec\n    const _jsArrayUint32FromVec = library.jsArrayUint32FromVec\n    const _jsArrayInt32FromVec = library.jsArrayInt32FromVec\n    const _jsArrayFloat64FromVec = library.jsArrayFloat64FromVec\n    const _jsArrayStringFromVecInt64 = library.jsArrayStringFromVecInt64\n    const _jsArrayStringFromVecUint64 = library.jsArrayStringFromVecUint64\n    const _jsArrayStringFromVecModulus = library.jsArrayStringFromVecModulus\n\n    let _instance: Instance\n    let _type: StringTypes\n    /**\n     * @implements Vector\n     */\n\n    /**\n     * @interface Vector\n     */\n    const self: Vector = {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name Vector#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name Vector#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        self.delete()\n        _instance = instance\n        fin.reregister(_instance)\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name Vector#delete\n       */\n      delete() {\n        if (!_instance) {\n          return\n        }\n        fin.unregister()\n        _instance.delete()\n        _instance = undefined\n      },\n\n      /**\n       * Converts a JS TypedArray into a vector\n       *\n       * @function\n       * @name Vector#from\n       * @param {VectorTypes} array The TypedArray to convert\n       * @param {StringTypes} [type] An optional type override - useful for 'Modulus' only\n       */\n      from(array: VectorTypes, type?: StringTypes) {\n        try {\n          _type = type ? type : (array.constructor.name as StringTypes)\n          switch (_type) {\n            case 'Uint8Array':\n              _instance = _vecFromArrayUint8(array)\n              break\n            case 'Int32Array':\n              _instance = _vecFromArrayInt32(array)\n              break\n            case 'Uint32Array':\n              _instance = _vecFromArrayUint32(array)\n              break\n            case 'Float64Array':\n              _instance = _vecFromArrayFloat64(array)\n              break\n            case 'BigInt64Array':\n              _instance = _vecFromArrayBigInt64(array.toString().split(','))\n              break\n            case 'BigUint64Array':\n              _instance = _vecFromArrayBigUint64(array.toString().split(','))\n              break\n            case 'Modulus':\n              _instance = _vecFromArrayModulus(array.toString().split(','))\n              break\n            default:\n              throw new Error(UNSUPPORTED_VECTOR_TYPE)\n          }\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * The Vector type\n       *\n       * @readonly\n       * @name Vector#type\n       */\n      get type(): StringTypes {\n        return _type\n      },\n\n      /**\n       * Set the Vector type\n       *\n       * @function\n       * @name Vector#setType\n       * @param {StringTypes} type the type of the vector\n       */\n      setType(type: StringTypes) {\n        _type = type\n      },\n\n      /**\n       * The vector size\n       *\n       * @readonly\n       * @name Vector#size\n       * @type {number}\n       */\n      get size(): number {\n        return _instance.size()\n      },\n\n      /**\n       * Get a value pointed to by the specified index\n       *\n       * @function\n       * @name Vector#getValue\n       * @param {number} index Index of the Vector\n       * @returns {number} Value of the element in the Vector pointed to by the index\n       */\n      getValue(index: number): number {\n        try {\n          return _instance.get(index)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Resizes a vector to the given size\n       *\n       * @function\n       * @name Vector#resize\n       * @param {number} size number of elements to resize\n       * @param {number} fill Data to fill the vector with\n       */\n      resize(size: number, fill: number) {\n        try {\n          _instance.resize(size, fill)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Copy a vector's data into a Typed Array\n       *\n       * Note: we cannot simply return a view on the underlying ArrayBuffer\n       * because WASM memory can grow and cause all the views to become\n       * neutered. We have to perform a hard copy to get data from WASM heap to JS.\n       *\n       * @function\n       * @name Vector#toArray\n       * @returns {VectorTypes} TypedArray containing values from the Vector\n       */\n      toArray(): VectorTypes {\n        if (!_instance) {\n          throw new Error(INSTANCE_DELETED)\n        }\n        switch (_type) {\n          case 'Uint8Array':\n            return Uint8Array.from(_jsArrayUint8FromVec(_instance))\n          case 'Int32Array':\n            return Int32Array.from(_jsArrayInt32FromVec(_instance))\n          case 'Uint32Array':\n            return Uint32Array.from(_jsArrayUint32FromVec(_instance))\n          case 'Float64Array':\n            return Float64Array.from(_jsArrayFloat64FromVec(_instance))\n          case 'BigInt64Array':\n            return BigInt64Array.from(_jsArrayStringFromVecInt64(_instance))\n          case 'BigUint64Array':\n            return BigUint64Array.from(_jsArrayStringFromVecUint64(_instance))\n          case 'Modulus':\n            return BigUint64Array.from(_jsArrayStringFromVecModulus(_instance))\n          default:\n            throw new Error(UNSUPPORTED_VECTOR_TYPE)\n        }\n      }\n    }\n\n    const fin = autoFinalize(self, _instance)\n\n    return self\n  }\n\nexport const VectorInit = ({ loader }: LoaderOptions): VectorDependencies => {\n  const library: Library = loader.library\n  return VectorConstructor(library)\n}\n","import sealLibrary from 'seal_allows_wasm_cf_worker'\nimport { SEALLibrary } from './implementation/seal'\nimport { SEAL } from './main/seal'\n\n/**\n * Main export for node-seal\n */\nexport default async (wasmBinary: WebAssembly.Module): Promise<SEALLibrary> => {\n  const library = await sealLibrary({\n    instantiateWasm(\n      info: WebAssembly.Imports,\n      cb: (instance: WebAssembly.Instance, module: WebAssembly.Module) => void\n    ) {\n      const instance = new WebAssembly.Instance(wasmBinary, info)\n      cb(instance, wasmBinary)\n    }\n  })\n  return SEAL(async () => ({ library }))\n}\n","import { BatchEncoderInit } from '../implementation/batch-encoder'\nimport { CipherTextInit } from '../implementation/cipher-text'\nimport { CKKSEncoderInit } from '../implementation/ckks-encoder'\nimport { CoeffModulusInit } from '../implementation/coeff-modulus'\nimport { ComprModeTypeInit } from '../implementation/compr-mode-type'\nimport { ContextInit } from '../implementation/context'\nimport { ContextDataInit } from '../implementation/context-data'\nimport { DecryptorInit } from '../implementation/decryptor'\nimport { EncryptionParameterQualifiersInit } from '../implementation/encryption-parameter-qualifiers'\nimport { EncryptionParametersInit } from '../implementation/encryption-parameters'\nimport { EncryptorInit } from '../implementation/encryptor'\nimport { EvaluatorInit } from '../implementation/evaluator'\nimport { ExceptionInit } from '../implementation/exception'\nimport { GaloisKeysInit } from '../implementation/galois-keys'\nimport { KeyGeneratorInit } from '../implementation/key-generator'\nimport { MemoryPoolHandleInit } from '../implementation/memory-pool-handle'\nimport { ModulusInit } from '../implementation/modulus'\nimport { ParmsIdTypeInit } from '../implementation/parms-id-type'\nimport { PlainModulusInit } from '../implementation/plain-modulus'\nimport { PlainTextInit } from '../implementation/plain-text'\nimport { PublicKeyInit } from '../implementation/public-key'\nimport { RelinKeysInit } from '../implementation/relin-keys'\nimport { SchemeTypeInit } from '../implementation/scheme-type'\nimport { SEALConstructor, SEALLibrary } from '../implementation/seal'\nimport { SecretKeyInit } from '../implementation/secret-key'\nimport { SecurityLevelInit } from '../implementation/security-level'\nimport { SerializableInit } from '../implementation/serializable'\nimport { VectorInit } from '../implementation/vector'\nimport { Loader } from './loader'\n\n/**\n * Main export for the library\n */\nexport const SEAL = async (\n  Loader: () => Promise<Loader>\n): Promise<SEALLibrary> => {\n  const loader = await Loader()\n  return SEALConstructor({\n    BatchEncoder: BatchEncoderInit({\n      loader\n    }),\n    CipherText: CipherTextInit({\n      loader\n    }),\n    CKKSEncoder: CKKSEncoderInit({\n      loader\n    }),\n    CoeffModulus: CoeffModulusInit({\n      loader\n    }),\n    ComprModeType: ComprModeTypeInit({\n      loader\n    }),\n    ContextData: ContextDataInit({\n      loader\n    }),\n    Context: ContextInit({\n      loader\n    }),\n    Decryptor: DecryptorInit({\n      loader\n    }),\n    EncryptionParameterQualifiers: EncryptionParameterQualifiersInit(),\n    EncryptionParameters: EncryptionParametersInit({\n      loader\n    }),\n    Encryptor: EncryptorInit({\n      loader\n    }),\n    Evaluator: EvaluatorInit({\n      loader\n    }),\n    Exception: ExceptionInit({\n      loader\n    }),\n    GaloisKeys: GaloisKeysInit({\n      loader\n    }),\n    KeyGenerator: KeyGeneratorInit({\n      loader\n    }),\n    MemoryPoolHandle: MemoryPoolHandleInit({\n      loader\n    }),\n    Modulus: ModulusInit({\n      loader\n    }),\n    ParmsIdType: ParmsIdTypeInit({\n      loader\n    }),\n    PlainText: PlainTextInit({\n      loader\n    }),\n    PlainModulus: PlainModulusInit({\n      loader\n    }),\n    PublicKey: PublicKeyInit({\n      loader\n    }),\n    RelinKeys: RelinKeysInit({\n      loader\n    }),\n    SchemeType: SchemeTypeInit({\n      loader\n    }),\n    SecretKey: SecretKeyInit({\n      loader\n    }),\n    SecurityLevel: SecurityLevelInit({\n      loader\n    }),\n    Serializable: SerializableInit(),\n    Vector: VectorInit({\n      loader\n    })\n  })\n}\n"],"names":["async","Module","moduleArg","da","ea","l","aa","ba","document","location","require","pathToFileURL","__filename","href","_documentCurrentScript","tagName","toUpperCase","src","URL","baseURI","ca","b","a","XMLHttpRequest","open","responseType","send","Uint8Array","response","fetch","credentials","ok","arrayBuffer","Error","status","url","v","y","fa","ha","ia","ja","z","A","C","D","F","ka","la","ma","na","n","console","error","bind","x","oa","pa","buffer","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array","ra","G","I","qa","onAbort","WebAssembly","RuntimeError","ta","c","sa","instantiate","d","va","name","constructor","this","message","wa","length","shift","xa","ya","za","preRun","push","Aa","Ba","V","J","String","fromCharCode","K","L","Ea","N","super","O","hasOwnProperty","forEach","e","Fa","Ha","TypeError","Ia","T","X","U","Ja","Ka","P","FinalizationRegistry","count","value","Z","unregister","register","Ma","Na","Object","defineProperty","Oa","Pa","Y","apply","ga","Qa","Sa","f","g","h","Ta","Ua","toString","Va","Wa","clone","Q","Xa","Ya","W","Za","$a","bb","cb","create","writable","db","k","p","m","$","gb","eb","fb","hb","get","jb","ib","R","includes","kb","mb","lb","S","map","join","Array","nb","pop","pb","ob","r","q","u","t","w","E","qb","rb","trim","indexOf","slice","sb","tb","vb","Wb","wb","xb","yb","zb","Ab","assign","optional","codePointAt","Bb","charCodeAt","Cb","TextDecoder","Db","Fb","Gb","decode","subarray","Hb","Ib","Jb","fromCodePoint","Kb","Lb","Mb","Nb","Qb","Rb","Sb","Tb","onExit","Vb","Xb","USER","LOGNAME","PATH","PWD","HOME","LANG","navigator","language","replace","_","Zb","crypto","getRandomValues","prototype","isAliasOf","getPrototypeOf","call","isDeleted","deleteLater","Symbol","dispose","ua","ab","pointerType","noExitRuntime","printErr","wasmBinary","thisProgram","$b","ac","bc","cc","BigInt","asUintN","H","Ra","Ga","M","B","ub","keys","startsWith","substring","concat","enumerable","configurable","set","splice","className","values","o","Eb","ArrayBuffer","isView","BYTES_PER_ELEMENT","s","Pb","Ob","Reflect","construct","j","i","clearTimeout","id","setTimeout","Ub","performance","now","Ca","Date","getFullYear","getTimezoneOffset","Math","max","Number","abs","floor","padStart","min","ceil","byteLength","grow","Infinity","exports","_emscripten_stack_alloc","emscripten_stack_get_current","dc","_main","monitorRunDependencies","instantiateWasm","Promise","locateFile","instantiateStreaming","instance","preInit","ec","calledRun","onRuntimeInitialized","noInitialRun","postRun","setStatus","UNSUPPORTED_VECTOR_TYPE","globalRegistry","registry","undefined","entry","resource","delete","target","reregister","token","newResource","newEntry","autoFinalize","BatchEncoderInit","loader","library","Exception","MemoryPoolHandle","PlainText","Vector","context","Constructor","BatchEncoder","_instance","safe","self","unsafeInject","fin","encode","array","plainText","plain","stringArray","split","signed","pool","global","tempVect","decodeInt32","setType","tempArr","toArray","decodeUint32","decodeBigInt","from","slotCount","BatchEncoderConstructor","CipherTextConstructor","ComprModeType","ParmsIdType","params","Ciphertext","constructParams","parmsId","sizeCapacity","reserve","capacity","resize","size","release","coeffModulusSize","polyModulusDegree","isTransparent","isNttForm","parms","inject","scale","setScale","save","compression","zstd","saveToString","saveArray","saveToArray","load","encoded","loadFromString","loadArray","loadFromArray","copy","cipher","clonedInstance","move","CipherTextInit","CKKSEncoderInit","CKKSEncoder","decodeDouble","CKKSEncoderConstructor","CoeffModulusInit","SecurityLevel","_MaxBitCount","CoeffModulus","MaxBitCount","_BFVDefault","BFVDefault","_CreateFromArray","CreateFromArray","securityLevel","tc128","vectorModulus","Create","bitSizes","CoeffModulusConstructor","ComprModeTypeInit","_none","none","_zlib","zlib","_zstd","ComprModeTypeConstructor","ContextInit","ContextData","encryptionParams","expandModChain","SEALContext","toHuman","getContextData","contextData","keyContextData","firstContextData","lastContextData","parametersSet","keyParmsId","firstParmsId","lastParmsId","usingKeyswitching","ContextConstructor","ContextDataConstructor","EncryptionParameters","EncryptionParameterQualifiers","encryptionParameters","qualifiers","encParmQualifiers","totalCoeffModulusBitCount","prevContextData","cxtData","nextContextData","chainIndex","ContextDataInit","DecryptorInit","secretKey","Decryptor","decrypt","cipherText","invariantNoiseBudget","DecryptorConstructor","EncryptionParameterQualifiersInit","usingFFT","usingNTT","usingBatching","usingFastPlainLift","usingDescendingModulusChain","EncryptionParametersInit","Modulus","SchemeType","schemeType","setPolyModulusDegree","setCoeffModulus","coeffModulus","setPlainModulus","plainModulus","scheme","smallModulus","EncryptionParametersConstructor","EncryptorInit","CipherText","Serializable","publicKey","Encryptor","constructInstance","encrypt","encryptSerializable","temp","encryptSymmetric","encryptSymmetricSerializable","serialized","encryptZero","encryptZeroSerializable","EncryptorConstructor","EvaluatorInit","Evaluator","negate","encrypted","destination","add","sub","multiply","square","relinearize","relinKeys","cipherModSwitchToNext","cipherModSwitchTo","plainModSwitchToNext","plainModSwitchTo","rescaleToNext","rescaleTo","modReduceToNext","modReduceTo","exponentiate","exponent","addPlain","subPlain","multiplyPlain","plainTransformToNtt","destinationNtt","cipherTransformToNtt","cipherTransformFromNtt","encryptedNtt","applyGalois","galoisElt","galoisKeys","rotateRows","steps","rotateColumns","rotateVector","complexConjugate","sumElements","newDest","dotProduct","dotProductPlain","EvaluatorConstructor","ExceptionInit","_getException","getException","ExceptionConstructor","GaloisKeysConstructor","GaloisKeys","getIndex","hasKey","key","GaloisKeysInit","KeyGeneratorInit","PublicKey","SecretKey","RelinKeys","KeyGenerator","createPublicKey","createPublicKeySerializable","createRelinKeys","createRelinKeysSerializable","createGaloisKeys","createGaloisKeysSerializable","KeyGeneratorConstructor","MemoryPoolHandleInit","_global","MemoryPoolHandleGlobal","_threadLocal","MemoryPoolHandleThreadLocal","threadLocal","MemoryPoolHandleConstructor","ModulusInit","inst","setValue","createModulus","bitCount","isZero","isPrime","ModulusConstructor","ParmsIdTypeInit","ParmsIdTypeConstructor","PlainModulusInit","_Batching","PlainModulus","Batching","_BatchingVector","BatchingVector","bitSize","smallMod","polyPlainModulusDegree","vectBitSizes","vect","PlainModulusConstructor","PlainTextConstructor","Plaintext","coeffCount","shrinkToFit","setZero","significantCoeffCount","nonzeroCoeffCount","toPolynomial","PlainTextInit","PublicKeyConstructor","PublicKeyInit","RelinKeysConstructor","keyPower","RelinKeysInit","SchemeTypeInit","_bfv","bfv","_ckks","ckks","_bgv","bgv","SchemeTypeConstructor","SecretKeyConstructor","SecretKeyInit","SecurityLevelInit","SecLevelType","_tc128","_tc192","tc192","_tc256","tc256","SecurityLevelConstructor","SerializableInit","VectorInit","_vecFromArrayUint8","vecFromArrayUint8","_vecFromArrayUint32","vecFromArrayUint32","_vecFromArrayInt32","vecFromArrayInt32","_vecFromArrayFloat64","vecFromArrayFloat64","_vecFromArrayBigInt64","vecFromArrayBigInt64","_vecFromArrayBigUint64","vecFromArrayBigUint64","_vecFromArrayModulus","vecFromArrayModulus","_jsArrayUint8FromVec","jsArrayUint8FromVec","_jsArrayUint32FromVec","jsArrayUint32FromVec","_jsArrayInt32FromVec","jsArrayInt32FromVec","_jsArrayFloat64FromVec","jsArrayFloat64FromVec","_jsArrayStringFromVecInt64","jsArrayStringFromVecInt64","_jsArrayStringFromVecUint64","jsArrayStringFromVecUint64","_jsArrayStringFromVecModulus","jsArrayStringFromVecModulus","_type","type","getValue","index","fill","VectorConstructor","sealLibrary","info","Instance","Loader","Context","exception","comprModeType","memoryPoolHandle","vector","modulus","serializable","parmsIdType","batchEncoder","ckksEncoder","encryptionParameterQualifiers","decryptor","encryptor","evaluator","Version","SEALConstructor","SEAL"],"mappings":"oSAAAA,eAAeC,EAAOC,EAAU,IAAI,IAA2EC,EAAGC,EAA5DC,EAAEH,EAAUI,EAAG,iBAAiBC,EAAG,oBAAAC,UAAA,oBAAAC,SAAAC,QAAA,OAAAC,cAAAC,YAAAC,KAAA,oBAAAL,SAAAC,SAAAI,KAAAC,GAAA,WAAAA,EAAAC,QAAAC,eAAAF,EAAAG,KAAA,IAAAC,IAAA,+BAAAV,SAAAW,SAAAN,KAAgBO,EAAG,GAAS,IAAIA,EAAG,IAAKF,IAAI,IAAIX,GAAKM,IAAI,CAAC,MAAM,CAACT,EAAGiB,IAAI,IAAIC,EAAE,IAAIC,eAA4E,OAA7DD,EAAEE,KAAK,MAAMH,GAAE,GAAIC,EAAEG,aAAa,cAAcH,EAAEI,KAAK,MAAa,IAAIC,WAAWL,EAAEM,SAAQ,EAAGzB,EAAGH,UAAuD,IAA7CqB,QAAQQ,MAAMR,EAAE,CAACS,YAAY,iBAAqBC,GAAG,OAAOV,EAAEW,cAAc,MAAMC,MAAMZ,EAAEa,OAAO,MAAMb,EAAEc,IAAI,EAAG,IAAkCC,EAAOC,EAAEC,EAAGC,EAAGC,EAAGC,EAAGC,EAAEC,EAAEC,EAAEC,EAAEC,EAAEC,EAAGC,EAAGC,EAAGC,EAAtEC,EAAEC,QAAQC,MAAMC,KAAKF,SAAWG,GAAE,EAAuCC,GAAG,EACve,SAASC,IAAK,IAAIpC,EAAEmB,EAAGkB,OAAOjB,EAAG,IAAIkB,UAAUtC,GAAGsB,EAAE,IAAIiB,WAAWvC,GAAGqB,EAAE,IAAIf,WAAWN,GAAGuB,EAAE,IAAIiB,YAAYxC,GAAGwB,EAAE,IAAIiB,WAAWzC,GAAGyB,EAAE,IAAIiB,YAAY1C,GAAG0B,EAAG,IAAIiB,aAAa3C,GAAG2B,EAAG,IAAIiB,aAAa5C,GAAG4B,EAAG,IAAIiB,cAAc7C,GAAG6B,EAAG,IAAIiB,eAAe9C,EAAE,CAAC,IAA4K+C,EAAxKC,EAAE,EAAEC,EAAE,KAAK,SAASC,EAAGlD,GAAoI,MAAjIhB,EAAEmE,UAAUnD,GAAsB8B,EAAnB9B,EAAE,WAAWA,EAAE,KAASkC,GAAE,EAAGlC,EAAE,IAAIoD,YAAYC,aAAarD,EAAE,4CAA4CkB,IAAKlB,GAASA,CAAE,CACrNrB,eAAe2E,EAAGtD,EAAEC,GAAG,IAAI,IAAIsD,QAAxO5E,eAAkBqB,GAAG,IAAIe,EAAE,IAAI,IAAId,QAAQnB,EAAGkB,GAAG,OAAO,IAAIM,WAAWL,EAAE,CAAC,MAAM,CAAC,GAAGD,GAAG+C,GAAIhC,EAAEf,EAAE,IAAIM,WAAWS,OAAQ,KAAGhC,EAAgB,KAAK,kDAAlBiB,EAAEjB,EAAGiB,EAA8D,CAAC,OAAOA,CAAC,CAAwCwD,CAAGxD,GAAG,aAAaoD,YAAYK,YAAYF,EAAEtD,EAAE,CAAC,MAAMyD,GAAG5B,EAAE,0CAA0C4B,KAAKR,EAAGQ,EAAE,CAAC,CAC1G,MAAMC,EAAGC,KAAK,aAAa,WAAAC,CAAY7D,GAAG8D,KAAKC,QAAQ,gCAAgC/D,KAAK8D,KAAKjD,OAAOb,CAAC,EAAE,IAAIgE,EAAGhE,IAAI,KAAK,EAAEA,EAAEiE,QAAQjE,EAAEkE,OAAFlE,CAAUhB,EAAC,EAAGmF,EAAG,GAAGC,EAAG,GAAGC,EAAG,KAAK,IAAIrE,EAAEhB,EAAEsF,OAAOJ,QAAQE,EAAGG,KAAKvE,EAAC,EAAGwE,GAAG,EAAG,MAAMC,EAAG,WAAAZ,CAAY7D,GAAG8D,KAAKY,EAAE1E,EAAE,EAAE,EACxe,IAAW2E,EAAE3E,IAAIA,KAAK,EAAE,IAAI,IAAIC,EAAE,KAAK,CAAC,IAAIsD,EAAElC,EAAErB,MAAM,GAAG,IAAIuD,EAAE,OAAOtD,EAAEA,GAAG2E,OAAOC,aAAatB,EAAE,GAAGuB,EAAE,CAAA,EAAGC,EAAE,GAAGC,EAAG,CAAA,EAAGC,EAAE,cAAcrE,MAAM,WAAAiD,CAAY7D,GAAGkF,MAAMlF,GAAG8D,KAAKF,KAAK,cAAc,GAC7L,SAASuB,EAAEnF,EAAEC,EAAEsD,EAAE,CAAA,GAAI,OAD2K,SAAYvD,EAAEC,EAAEsD,EAAE,CAAA,GAAI,IAAIG,EAAEzD,EAAE2D,KAAK,IAAI5D,EAAE,MAAM,IAAIiF,EAAE,SAASvB,kDAAkD,GAAGqB,EAAEK,eAAepF,GAAG,CAAC,GAAGuD,EAAEI,GAAG,OAAO,MAAM,IAAIsB,EAAE,yBAAyBvB,WAAY,CAACqB,EAAE/E,GAAGC,SAAS+E,EAAGhF,GAAG8E,EAAEM,eAAepF,KAAKC,EAAE6E,EAAE9E,UAAU8E,EAAE9E,GAAGC,EAAEoF,SAAQC,GAAGA,MAAK,CAC5bC,CAAGvF,EAAEC,EAAEsD,EAAE,CAClC,IAACiC,EAAG,CAACxF,EAAEC,EAAEsD,KAAK,OAAOtD,GAAG,KAAK,EAAE,OAAOsD,EAAEG,GAAGtC,EAAGsC,IAAI,GAAGA,GAAGrC,EAAEqC,IAAI,GAAG,KAAK,EAAE,OAAOH,EAAEG,GAAGpC,EAAEoC,IAAI,IAAI,GAAGA,GAAGnC,EAAEmC,IAAI,IAAI,GAAG,KAAK,EAAE,OAAOH,EAAEG,GAAGlC,EAAEkC,IAAI,IAAI,GAAGA,GAAGjC,EAAEiC,IAAI,IAAI,GAAG,KAAK,EAAE,OAAOH,EAAEG,GAAG9B,EAAG8B,IAAI,IAAI,GAAGA,GAAG7B,EAAG6B,IAAI,IAAI,GAAG,QAAQ,MAAM,IAAI+B,UAAU,0BAA0BxF,OAAOD,KAAK,EAAG0F,EAAG1F,IAAI,MAAM,IAAIiF,EAAEjF,EAAE2F,EAAEC,EAAEC,EAAEjC,KAAK,4BAA4B,EAAGkC,GAAG,EAAGC,EAAG,OAAOC,EAAEhG,GAAO,oBAAqBiG,sBAA4BD,EAAE/F,GAAGA,EAAED,IAAE8F,EAAG,IAAIG,sBAAqBhG,OAAIA,EAAEA,EAAE0F,GAAMO,MAAMC,MAAM,IAAIlG,EAAEiG,MAAMC,QAC9elG,EAAEmG,EAAEnG,EAAEf,GAAG+B,GAAGhB,EAAEmG,GAAGnG,EAAE2F,EAAEC,EAAE5E,GAAGhB,EAAEyE,GAAE,IAA0DqB,EAAG9F,IAAI6F,EAAGO,WAAWpG,KAA3E+F,EAAE/F,IAAI,IAAIsD,EAAEtD,EAAE0F,EAA8B,OAA5BpC,EAAE6C,GAAGN,EAAGQ,SAASrG,EAAE,CAAC0F,EAAEpC,GAAGtD,GAAUA,IAAqCD,IAAU,SAASuG,IAAK,CACnJ,IAAIC,EAAG,CAACxG,EAAEC,IAAIwG,OAAOC,eAAezG,EAAE,OAAO,CAACkG,MAAMnG,IAAI2G,EAAG,CAAA,EAAGC,EAAG,CAAC5G,EAAEC,EAAEsD,KAAK,QAAG,IAASvD,EAAEC,GAAG4G,EAAE,CAAC,IAAInD,EAAE1D,EAAEC,GAAGD,EAAEC,GAAG,YAAYqF,GAAG,IAAItF,EAAEC,GAAG4G,EAAEzB,eAAeE,EAAErB,QAAQ,MAAM,IAAIgB,EAAE,aAAa1B,kDAAkD+B,EAAErB,6BAA6BjE,EAAEC,GAAG4G,OAAO,OAAO7G,EAAEC,GAAG4G,EAAEvB,EAAErB,QAAQ6C,MAAMhD,KAAKwB,EAAE,EAAEtF,EAAEC,GAAG4G,EAAE,GAAG7G,EAAEC,GAAG4G,EAAEnD,EAAEqD,IAAIrD,CAAC,GAAGsD,GAAG,CAAChH,EAAEC,EAAEsD,KAAK,GAAGvE,EAAEoG,eAAepF,GAAG,CAAC,QAAG,IAASuD,QAAG,IAASvE,EAAEgB,GAAG6G,QAAG,IAAS7H,EAAEgB,GAAG6G,EAAEtD,GAAG,MAAM,IAAI0B,EAAE,gCAAgCjF,YAAsB,GAAV4G,EAAG5H,EAAEgB,EAAEA,GAAMhB,EAAEgB,GAAG6G,EAAEzB,eAAe7B,GAAG,MAAM,IAAI0B,EAAE,uFAAuF1B,OACnnBvE,EAAEgB,GAAG6G,EAAEtD,GAAGtD,CAAC,MAAMjB,EAAEgB,GAAGC,EAAEjB,EAAEgB,GAAG+G,GAAGxD,CAAA,EAAiG,SAAS0D,GAAGjH,EAAEC,EAAEsD,EAAEG,EAAE4B,EAAE4B,EAAEC,EAAEC,GAAGtD,KAAKF,KAAK5D,EAAE8D,KAAKD,YAAY5D,EAAE6D,KAAK/E,GAAGwE,EAAEO,KAAK7C,GAAGyC,EAAEI,KAAK7E,GAAGqG,EAAExB,KAAKR,GAAG4D,EAAEpD,KAAKpC,GAAGyF,EAAErD,KAAKN,GAAG4D,EAAEtD,KAAKM,GAAG,EAAE,CACnQ,IAAIiD,GAAG,CAACrH,EAAEC,EAAEsD,KAAK,KAAKtD,IAAIsD,GAAG,CAAC,IAAItD,EAAEyB,GAAG,MAAM,IAAIuD,EAAE,gCAAgC1B,EAAEK,4BAA4B3D,EAAE2D,QAAQ5D,EAAEC,EAAEyB,GAAG1B,GAAGC,EAAEA,EAAEhB,EAAE,CAAC,OAAOe,GAAGsH,GAAGtH,IAAI,GAAG,OAAOA,EAAE,MAAM,OAAO,IAAIC,SAASD,EAAE,MAAM,WAAWC,GAAG,UAAUA,GAAG,aAAaA,EAAED,EAAEuH,WAAW,GAAGvH,GACrQ,SAASwH,GAAGxH,EAAEC,GAAG,GAAG,OAAOA,EAAE,CAAC,GAAG6D,KAAK3B,GAAG,MAAM,IAAI8C,EAAE,uBAAuBnB,KAAKF,QAAQ,OAAO,CAAC,CAAC,IAAI3D,EAAE0F,EAAE,MAAM,IAAIV,EAAE,gBAAgBqC,GAAGrH,YAAY6D,KAAKF,QAAQ,IAAI3D,EAAE0F,EAAEjB,EAAE,MAAM,IAAIO,EAAE,mDAAmDnB,KAAKF,QAAQ,OAAOyD,GAAGpH,EAAE0F,EAAEjB,EAAEzE,EAAE0F,EAAEC,EAAEC,EAAE/B,KAAK+B,EAAE,CACvR,SAAS4B,GAAGzH,EAAEC,GAAG,GAAG,OAAOA,EAAE,CAAC,GAAG6D,KAAK3B,GAAG,MAAM,IAAI8C,EAAE,uBAAuBnB,KAAKF,QAAQ,GAAGE,KAAKjC,GAAG,CAAC,IAAI0B,EAAEO,KAAKO,KAAiC,OAA5B,OAAOrE,GAAGA,EAAEuE,KAAKT,KAAK7C,GAAGsC,GAAUA,CAAC,CAAC,OAAO,CAAC,CAAC,IAAItD,IAAIA,EAAE0F,EAAE,MAAM,IAAIV,EAAE,gBAAgBqC,GAAGrH,YAAY6D,KAAKF,QAAQ,IAAI3D,EAAE0F,EAAEjB,EAAE,MAAM,IAAIO,EAAE,mDAAmDnB,KAAKF,QAAQ,IAAIE,KAAKlC,IAAI3B,EAAE0F,EAAEC,EAAEhE,GAAG,MAAM,IAAIqD,EAAE,mCAAmChF,EAAE0F,EAAEzG,GAAGe,EAAE0F,EAAEzG,GAAG0E,KAAK3D,EAAE0F,EAAEC,EAAEhC,0BAA0BE,KAAKF,QAAmC,GAA3BL,EAAE8D,GAAGpH,EAAE0F,EAAEjB,EAAEzE,EAAE0F,EAAEC,EAAEC,EAAE/B,KAAK+B,GAAM/B,KAAKjC,GAAG,CAAC,QAAG,IAC5e5B,EAAE0F,EAAES,EAAE,MAAM,IAAInB,EAAE,mDAAmD,OAAOnB,KAAKW,IAAI,KAAK,EAAE,GAAGxE,EAAE0F,EAAEzG,KAAK4E,KAAkB,MAAM,IAAImB,EAAE,mCAAmChF,EAAE0F,EAAEzG,GAAGe,EAAE0F,EAAEzG,GAAG0E,KAAK3D,EAAE0F,EAAEC,EAAEhC,0BAA0BE,KAAKF,QAApHL,EAAEtD,EAAE0F,EAAES,EAAsH,MAAM,KAAK,EAAE7C,EAAEtD,EAAE0F,EAAES,EAAE,MAAM,KAAK,EAAE,GAAGnG,EAAE0F,EAAEzG,KAAK4E,KAAKP,EAAEtD,EAAE0F,EAAES,MAAM,CAAC,IAAI1C,EAAEzD,EAAEyH,QAAQnE,EAAEO,KAAKU,GAAGjB,EAAEoE,IAAE,IAAIjE,EAAU,YAAM,OAAO1D,GAAGA,EAAEuE,KAAKT,KAAK7C,GAAGsC,EAAE,CAAC,MAAM,QAAQ,MAAM,IAAI0B,EAAE,+BAAgC,CAAC,OAAO1B,CAAC,CAC1b,SAASqE,GAAG5H,EAAEC,GAAG,GAAG,OAAOA,EAAE,CAAC,GAAG6D,KAAK3B,GAAG,MAAM,IAAI8C,EAAE,uBAAuBnB,KAAKF,QAAQ,OAAO,CAAC,CAAC,IAAI3D,EAAE0F,EAAE,MAAM,IAAIV,EAAE,gBAAgBqC,GAAGrH,YAAY6D,KAAKF,QAAQ,IAAI3D,EAAE0F,EAAEjB,EAAE,MAAM,IAAIO,EAAE,mDAAmDnB,KAAKF,QAAQ,GAAG3D,EAAE0F,EAAEC,EAAEhE,GAAG,MAAM,IAAIqD,EAAE,mCAAmChF,EAAE0F,EAAEC,EAAEhC,0BAA0BE,KAAKF,QAAQ,OAAOyD,GAAGpH,EAAE0F,EAAEjB,EAAEzE,EAAE0F,EAAEC,EAAEC,EAAE/B,KAAK+B,EAAE,CAAC,SAASgC,GAAG7H,GAAG,OAAO8D,KAAKgE,EAAErG,EAAEzB,IAAI,IAAI,GAAG,CAC1a,IAAI+H,GAAG,CAAC/H,EAAEC,EAAEsD,IAAQtD,IAAIsD,EAASvD,OAAK,IAASuD,EAAEtE,IAAqC,QAAtBe,EAAE+H,GAAG/H,EAAEC,EAAEsD,EAAEtE,KAAhB,KAAyCsE,EAAEC,GAAGxD,GAAIgI,GAAG,CAAA,EAAiHC,GAAG,cAAcrH,MAAM,WAAAiD,CAAY7D,GAAGkF,MAAMlF,GAAG8D,KAAKF,KAAK,eAAe,GAAGsE,GAAG,CAAClI,EAAEC,KAAK,IAAIA,EAAE2F,IAAI3F,EAAEyE,EAAE,MAAM,IAAIuD,GAAG,4CAA4C,KAAKhI,EAAEf,MAAOe,EAAEmG,EAAE,MAAM,IAAI6B,GAAG,oDAAsE,OAAlBhI,EAAEiG,MAAM,CAACC,MAAM,GAAUH,EAAES,OAAO0B,OAAOnI,EAC1f,CAAC2F,EAAE,CAACQ,MAAMlG,EAAEmI,UAAS,KAAK,EAAG,SAASC,GAAGrI,EAAEC,EAAEsD,EAAEG,EAAE4B,EAAE4B,EAAEC,EAAEC,EAAEkB,EAAEC,EAAEC,GAAG1E,KAAKF,KAAK5D,EAAE8D,KAAK+B,EAAE5F,EAAE6D,KAAK3B,GAAGoB,EAAEO,KAAKlC,GAAG8B,EAAEI,KAAKjC,GAAGyD,EAAExB,KAAKK,GAAG+C,EAAEpD,KAAKW,GAAG0C,EAAErD,KAAKZ,GAAGkE,EAAEtD,KAAKO,GAAGiE,EAAExE,KAAKU,GAAG+D,EAAEzE,KAAK7C,GAAGuH,EAAElD,QAAG,IAASrF,EAAEhB,GAAG6E,KAAK2E,EAAEhB,IAAI3D,KAAK2E,EAAE/E,EAAE8D,GAAGI,GAAG9D,KAAK/D,GAAG,KAAK,CACvO,IAA+J2I,GAA3JC,GAAG,CAAC3I,EAAEC,EAAEsD,KAAK,IAAIvE,EAAEoG,eAAepF,GAAG,MAAM,IAAIiI,GAAG,4CAAuC,IAASjJ,EAAEgB,GAAG6G,QAAG,IAAStD,EAAEvE,EAAEgB,GAAG6G,EAAEtD,GAAGtD,GAAGjB,EAAEgB,GAAGC,EAAEjB,EAAEgB,GAAG+G,GAAGxD,EAAC,EAAGqF,GAAG,GAAMC,GAAG7I,IAAI,IAAIC,EAAE2I,GAAG5I,GAA0B,OAAvBC,IAAI2I,GAAG5I,GAAGC,EAAEyI,GAAGI,IAAI9I,IAAWC,GAA0D8I,GAAG,CAAC/I,EAAEC,IAAI,IAAIsD,IAAlE,EAACvD,EAAEC,EAAEsD,EAAE,MAAMtD,EAAE4I,GAAG5I,EAAH4I,IAAStF,GAAS,KAAKvD,EAAE,GAAGC,IAAI,EAAEA,GAAqB+I,CAAGhJ,EAAEC,EAAEsD,GAAG0F,GAAE,CAACjJ,EAAEC,KAAY,IAAIsD,GAAXvD,EAAE2E,EAAE3E,IAAWkJ,SAAS,KAAKH,GAAG/I,EAAEC,GAAG4I,GAAG5I,GAAG,GAAG,mBAAmBsD,EAAE,MAAM,IAAI0B,EAAE,2CAA2CjF,MAAMC,KAAK,OAAOsD,GAAG,MAAM4F,WAAWvI,OACnd,IAAIwI,GAAGpJ,IAAIA,EAAEqJ,GAAGrJ,GAAG,IAAIC,EAAE0E,EAAE3E,GAAQ,OAALsJ,GAAEtJ,GAAUC,GAAG0F,GAAE,CAAC3F,EAAEC,KAA4E,IAAIyD,EAAE,GAAG4B,EAAE,CAAA,EAAgB,MAAbrF,EAAEoF,SAAvF,SAAS9B,EAAE2D,GAAG5B,EAAE4B,IAAInC,EAAEmC,KAAKlC,EAAGkC,GAAGlC,EAAGkC,GAAG7B,QAAQ9B,IAAIG,EAAEa,KAAK2C,GAAG5B,EAAE4B,IAAG,GAAI,IAAkC,IAAIiC,GAAG,GAAGnJ,MAAM0D,EAAE6F,IAAIH,IAAII,KAAK,CAAC,OAAO,EAAG3D,GAAE,CAAC7F,EAAEC,EAAEsD,KAAK,SAASG,EAAE0D,GAAU,IAAPA,EAAE7D,EAAE6D,IAAQnD,SAASjE,EAAEiE,OAAO,MAAM,IAAIgE,GAAG,mCAAmC,IAAI,IAAIK,EAAE,EAAEA,EAAEtI,EAAEiE,SAASqE,EAAEnD,EAAEnF,EAAEsI,GAAGlB,EAAEkB,GAAG,CAACtI,EAAEqF,SAAQ+B,GAAGpC,EAAGoC,GAAGnH,IAAG,IAAIqF,EAAEmE,MAAMxJ,EAAEgE,QAAQiD,EAAE,GAAGC,EAAE,EAAElH,EAAEoF,SAAQ,CAAC+B,EAAEkB,KAAKvD,EAAEK,eAAegC,GAAG9B,EAAEgD,GAAGvD,EAAEqC,IAAIF,EAAE3C,KAAK6C,GAAGtC,EAAEM,eAAegC,KAAKtC,EAAEsC,GAAG,IAAItC,EAAEsC,GAAG7C,MAAK,KACjfe,EAAEgD,GAAGvD,EAAEqC,KAAKD,IAAMD,EAAEjD,QAAQP,EAAE4B,EAAC,IAAG,IAAI,IAAI4B,EAAEjD,QAAQP,EAAE4B,EAAC,EAAGoE,GAAG1J,IAAI,KAAKA,EAAEiE,QAAQ,CAAC,IAAIhE,EAAED,EAAE2J,MAAM3J,EAAE2J,KAAF3J,CAAQC,EAAE,GAC1G,SAAS2J,GAAG5J,EAAEC,EAAEsD,EAAEG,EAAE4B,GAAG,IAAI4B,EAAEjH,EAAEgE,OAAO,GAAG,EAAEiD,EAAE,MAAM,IAAIjC,EAAE,kFAAkF,IAAIkC,EAAE,OAAOlH,EAAE,IAAI,OAAOsD,EAAE6D,EAD1D,SAAYpH,GAAG,IAAI,IAAIC,EAAE,EAAEA,EAAED,EAAEiE,SAAShE,EAAE,GAAG,OAAOD,EAAEC,SAAI,IAASD,EAAEC,GAAGF,GAAG,OAAM,EAAG,OAAM,CAAE,CAChC8J,CAAG5J,GAAGqI,GAAGrI,EAAE,GAAG+D,GAAGuE,EAAErB,EAAE,EAAEsB,EAAEiB,MAAMlB,GAAGuB,EAAE,GAAGC,EAAE,GAAG,OAAOvD,EAAGxG,GAAE,YAAYgK,GAAoC,GAAjCD,EAAE9F,OAAO,EAAE6F,EAAE7F,OAAOkD,EAAE,EAAE,EAAE2C,EAAE,GAAGxE,EAAK6B,EAAE,CAAC,IAAI8C,EAAEhK,EAAE,GAAGwI,EAAEsB,EAAEjG,MAAMgG,EAAE,GAAGG,CAAC,CAAC,IAAI,IAAIC,EAAE,EAAEA,EAAE3B,IAAI2B,EAAE1B,EAAE0B,GAAGjK,EAAEiK,EAAE,GAAGzB,EAAEsB,EAAEC,EAAEE,IAAIJ,EAAEvF,KAAKiE,EAAE0B,IAAc,GAAVF,EAAEtG,KAAKoG,GAAM1C,EAAEsC,GAAGK,QAAQ,IAAIG,EAAE/C,EAAE,EAAE,EAAE+C,EAAEjK,EAAEgE,OAAOiG,IAAI,CAAC,IAAIC,EAAE,IAAID,EAAED,EAAEzB,EAAE0B,EAAE,GAAG,OAAOjK,EAAEiK,GAAGnK,IAAIE,EAAEiK,GAAGnK,GAAGoK,EAAE,CAAsB,OAArBF,EAAE3B,EAAErI,EAAE,GAAG6H,EAAEkC,QAAG,CAAe,GAAE,CAC/e,IAAII,GAAG,CAACpK,EAAEC,KAAK,IAAI,IAAIsD,EAAE,GAAGG,EAAE,EAAEA,EAAE1D,EAAE0D,IAAIH,EAAEgB,KAAK9C,EAAExB,EAAE,EAAEyD,IAAI,IAAI,IAAI,OAAOH,GAAG8G,GAAGrK,IAAe,MAAMC,GAAjBD,EAAEA,EAAEsK,QAAiBC,QAAQ,KAAK,OAAM,IAAKtK,EAAED,EAAEA,EAAEwK,MAAM,EAAEvK,EAAC,EAAGwK,GAAG,CAACzK,EAAEC,EAAEsD,KAAK,KAAKvD,aAAayG,QAAQ,MAAM,IAAIxB,EAAE,GAAG1B,0BAA0BvD,KAAK,KAAKA,aAAaC,EAAE4F,EAAEhC,aAAa,MAAM,IAAIoB,EAAE,GAAG1B,sCAAsCvD,EAAE6D,YAAYD,QAAQ,IAAI5D,EAAE2F,EAAEjB,EAAE,MAAM,IAAIO,EAAE,yCAAyC1B,uBAAuB,OAAO8D,GAAGrH,EAAE2F,EAAEjB,EAAE1E,EAAE2F,EAAEC,EAAEC,EAAE5F,EAAE4F,EAAC,EAAG6E,GAAG,GAAGhG,GAAE,CAAC,EAAE,EAAC,CAAE,EAAE,KAAK,GAAE,EAAG,GAAE,EAAG,GACve,SAASiG,GAAG3K,GAAU,GAAPA,KAAK,IAAO,KAAM0E,GAAE1E,EAAE,KAAK0E,GAAE1E,QAAG,EAAO0K,GAAGnG,KAAKvE,GAAG,CACjE,IAOqJ4K,GAPjJ9C,GAAE9H,IAAI,IAAIA,EAAE,MAAM,IAAIiF,EAAE,oCAAoCjF,KAAK,OAAO0E,GAAE1E,EAAC,EAAG2H,GAAE3H,IAAI,OAAOA,GAAG,UAAK,EAAO,OAAO,EAAE,KAAK,KAAK,OAAO,EAAE,KAAK,EAAG,OAAO,EAAE,KAAK,EAAG,OAAO,EAAE,QAAQ,MAAMC,EAAEyK,GAAGf,OAAOjF,GAAET,OAAuB,OAAhBS,GAAEzE,GAAGD,EAAE0E,GAAEzE,EAAE,GAAG,EAASA,EAAC,EAAG4K,GAAG,CAACjH,KAAK,kBAAkBkE,EAAE9H,IAAI,IAAIC,EAAE6H,GAAE9H,GAAS,OAAN2K,GAAG3K,GAAUC,GAAGwI,EAAE,CAACzI,EAAEC,IAAI0H,GAAE1H,GAAGnB,GAAG+I,GAAG9H,GAAG,MAAM+K,GAAG,CAAC9K,EAAEC,EAAEsD,KAAK,OAAOtD,GAAG,KAAK,EAAE,OAAOsD,EAAE,SAASG,GAAG,OAAOI,KAAKgE,EAAE1G,EAAGsC,IAAI,GAAG,EAAE,SAASA,GAAG,OAAOI,KAAKgE,EAAEzG,EAAEqC,IAAI,GAAG,EAAE,KAAK,EAAE,OAAOH,EAAE,SAASG,GAAG,OAAOI,KAAKgE,EAAExG,EAAEoC,IAAI,IAAI,GAAG,EAAE,SAASA,GAAG,OAAOI,KAAKgE,EAAEvG,EAAEmC,IAC1gB,IAAI,GAAG,EAAE,KAAK,EAAE,OAAOH,EAAE,SAASG,GAAG,OAAOI,KAAKgE,EAAEtG,EAAEkC,IAAI,IAAI,GAAG,EAAE,SAASA,GAAG,OAAOI,KAAKgE,EAAErG,EAAEiC,IAAI,IAAI,GAAG,EAAE,QAAQ,MAAM,IAAI+B,UAAU,0BAA0BxF,OAAOD,KAAK,EAAG+K,GAAG,CAAC/K,EAAEC,KAAK,IAAIsD,EAAEwB,EAAE/E,GAAG,QAAG,IAASuD,EAAE,MAAMvD,EAAE,GAAGC,sBAAsBmJ,GAAGpJ,KAAK,IAAIiF,EAAEjF,GAAG,OAAOuD,GAAGyH,GAAG,CAAChL,EAAEC,KAAK,OAAOA,GAAG,KAAK,EAAE,OAAO,SAASsD,GAAG,OAAOO,KAAKgE,EAAEpG,EAAG6B,IAAI,IAAI,GAAG,EAAE,KAAK,EAAE,OAAO,SAASA,GAAG,OAAOO,KAAKgE,EAAEnG,EAAG4B,IAAI,IAAI,GAAG,EAAE,QAAQ,MAAM,IAAIkC,UAAU,wBAAwBxF,OAAOD,KAAK,EAAGiL,GAAGxE,OAAOyE,OAAO,CAACC,UAAS,GACnfN,IAAIjF,GAAE,CAAC5F,EAAEC,EAAEsD,KAAK,IAAIG,EAAErC,EAAS,KAAK,EAAEkC,GAAG,OAAO,EAAE,IAAI+B,EAA9BrF,KAAK,EAA6BsD,EAAEtD,EAAEsD,EAAE,EAAE,IAAI,IAAI2D,EAAE,EAAEA,EAAElH,EAAEiE,SAASiD,EAAE,CAAC,IAAIC,EAAEnH,EAAEoL,YAAYlE,GAAG,GAAG,KAAKC,EAAE,CAAC,GAAGlH,GAAGsD,EAAE,MAAMG,EAAEzD,MAAM,GAAGkH,CAAC,MAAM,GAAG,MAAMA,EAAE,CAAC,GAAGlH,EAAE,GAAGsD,EAAE,MAAMG,EAAEzD,MAAM,GAAG,IAAIkH,GAAG,EAAEzD,EAAEzD,MAAM,GAAG,IAAM,GAAFkH,CAAI,MAAM,GAAG,OAAOA,EAAE,CAAC,GAAGlH,EAAE,GAAGsD,EAAE,MAAMG,EAAEzD,MAAM,GAAG,IAAIkH,GAAG,GAAGzD,EAAEzD,MAAM,GAAG,IAAIkH,GAAG,EAAE,GAAGzD,EAAEzD,MAAM,GAAG,IAAM,GAAFkH,CAAI,KAAK,CAAC,GAAGlH,EAAE,GAAGsD,EAAE,MAAMG,EAAEzD,MAAM,GAAG,IAAIkH,GAAG,GAAGzD,EAAEzD,MAAM,GAAG,IAAIkH,GAAG,GAAG,GAAGzD,EAAEzD,MAAM,GAAG,IAAIkH,GAAG,EAAE,GAAGzD,EAAEzD,MAAM,GAAG,IAAM,GAAFkH,EAAKD,GAAG,CAAC,CAAY,OAAXxD,EAAEzD,IAAI,GAAG,EAASA,EAAEqF,GAAG+F,GAAGrL,IAAI,IAAI,IAAIC,EAAE,EAAEsD,EAAE,EAAEA,EAAEvD,EAAEiE,SAASV,EAAE,CAAC,IAAIG,EAC1f1D,EAAEsL,WAAW/H,GAAG,KAAKG,EAAEzD,IAAI,MAAMyD,EAAEzD,GAAG,EAAE,OAAOyD,GAAG,OAAOA,GAAGzD,GAAG,IAAIsD,GAAGtD,GAAG,CAAC,CAAC,OAAOA,GAAGsL,GAAG,oBAAoBC,YAAY,IAAIA,iBAAY,EAAOC,GAAG,CAACzL,EAAEC,EAAEsD,EAAEG,KAAW,GAANH,EAAEtD,EAAEsD,EAAKG,EAAE,OAAOH,EAAE,KAAKvD,EAAEC,MAAMA,GAAGsD,MAAMtD,EAAE,OAAOA,GACtEyL,GAAG,oBAAoBF,YAAY,IAAIA,YAAY,iBAAY,EAAOG,GAAG,CAAC3L,EAAEC,EAAEsD,KAA4B,GAAG,IAAnBtD,EAAEwL,GAAGlK,EAAZvB,KAAK,EAAWC,EAAE,EAAEsD,IAAWvD,GAAG0L,GAAG,OAAOA,GAAGE,OAAOrK,EAAEsK,SAAS7L,IAAI,EAAEC,IAAI,IAAI,IAAIsD,EAAE,GAAGvD,EAAEC,IAAID,EAAEuD,GAAGqB,OAAOC,aAAatD,EAAEvB,IAAI,IAAI,OAAOuD,GAAGuI,GAAG,CAAC9L,EAAEC,EAAEsD,KAAoB,GAAfA,IAAI,WAAc,EAAEA,EAAE,OAAO,EAAO,IAAIG,EAAEzD,EAAEsD,GAAbA,GAAG,GAAc,EAAEvD,EAAEiE,OAAOV,EAAE,EAAEvD,EAAEiE,OAAO,IAAI,IAAIqB,EAAE,EAAEA,EAAE/B,IAAI+B,EAAEhE,EAAErB,IAAI,IAAI,GAAGD,EAAEsL,WAAWhG,GAAGrF,GAAG,EACze,OAD2eqB,EAAErB,IACtf,IAAI,GAAG,EAASA,EAAEyD,GAAGqI,GAAG/L,GAAG,EAAEA,EAAEiE,OAAO+H,GAAG,CAAChM,EAAEC,EAAEsD,KAAK,IAAIG,EAAE,GAAG1D,KAAK,EAAE,IAAI,IAAIsF,EAAE,IAAIA,GAAGrF,EAAE,GAAGqF,IAAI,CAAC,IAAI4B,EAAEzF,EAAEzB,EAAEsF,IAAI,GAAG,IAAI4B,IAAI3D,EAAE,MAAMG,GAAGkB,OAAOqH,cAAc/E,EAAE,CAAC,OAAOxD,GAAGwI,GAAG,CAAClM,EAAEC,EAAEsD,KAA2B,GAAtBtD,KAAK,EAAEsD,IAAI,WAAc,EAAEA,EAAE,OAAO,EAAE,IAAIG,EAAEzD,EAAEsD,EAAEG,EAAEH,EAAE,EAAE,IAAI,IAAI+B,EAAE,EAAEA,EAAEtF,EAAEiE,SAASqB,EAAE,CAAC,IAAI4B,EAAElH,EAAEoL,YAAY9F,GAAoC,GAAjC,MAAM4B,GAAG5B,IAAI9D,EAAEvB,IAAI,IAAI,GAAGiH,GAAEjH,GAAG,GAAO,EAAEsD,EAAE,KAAK,CAAgB,OAAf/B,EAAEvB,IAAI,IAAI,GAAG,EAASA,EAAEyD,GAAGyI,GAAGnM,IAAI,IAAI,IAAIC,EAAE,EAAEsD,EAAE,EAAEA,EAAEvD,EAAEiE,SAASV,EAAE,MAAMvD,EAAEoL,YAAY7H,IAAIA,IAAItD,GAAG,EAAE,OAAOA,GAAGmM,GAAG,EAAEC,GAAG,GACzWC,GAAG,CAAA,EAAGC,GAAGvM,IAAI,IAAIC,EAAEqM,GAAGtM,GAAG,YAAO,IAASC,EAAE0E,EAAE3E,GAAGC,GAAG4G,GAAE,CAAA,EAAG2F,GAAGxM,IAAI,KAAKA,aAAa2D,GAAI,UAAU3D,GAAG,MAAMA,CAAC,EAAGyM,GAAGzM,IAAuC,MAAnCgB,EAAEhB,EAAEwE,GAAI,EAAE4H,KAAKpN,EAAE0N,SAAS1M,GAAGkC,GAAE,GAAU,IAAIyB,EAAG3D,EAAE,EAAwF2M,GAAG,CAAA,EAAGC,GAAG,KAAK,IAAIhC,GAAG,CAAC,IAClU3K,EADsUD,EAAE,CAAC6M,KAAK,WAAWC,QAAQ,WAAWC,KAAK,IAAIC,IAAI,IAAIC,KAAK,iBAAiBC,MAAM,iBAAiBC,WAAWA,UAAUC,UAAU,KAAKC,QAAQ,IAC5f,KAAK,SAASC,EAAErO,GAAI,kBAAoB,IAAIgB,KAAK0M,YAAYA,GAAG1M,UAAUD,EAAEC,GAAGD,EAAEC,GAAG0M,GAAG1M,GAAG,IAAIsD,EAAE,GAAG,IAAItD,KAAKD,EAAEuD,EAAEgB,KAAK,GAAGtE,KAAKD,EAAEC,MAAM2K,GAAGrH,CAAC,CAAC,OAAOqH,IAA2C2C,GAAGvN,KAAKuN,GAArCvN,GAAGwN,OAAOC,gBAAgBzN,IAAoBA,EAAC,EAC9M,MAAM,IAAIA,EAAEuG,EAAGmH,UAAUjH,OAAOyE,OAAOlL,EAAE,CAAC2N,UAAU,SAASpK,GAAG,KAAKO,gBAAgByC,GAAIhD,aAAagD,GAAI,OAAM,EAAG,IAAI7C,EAAEI,KAAK6B,EAAEC,EAAEC,EAAEP,EAAExB,KAAK6B,EAAEjB,EAAEnB,EAAEoC,EAAEpC,EAAEoC,EAAE,IAAIuB,EAAE3D,EAAEoC,EAAEC,EAAEC,EAAE,IAAItC,EAAEA,EAAEoC,EAAEjB,EAAEhB,EAAEzE,IAAIqG,EAAE5B,EAAEhC,GAAG4D,GAAG5B,EAAEA,EAAEzE,GAAG,KAAKiI,EAAEjI,IAAIsE,EAAE2D,EAAExF,GAAG6B,GAAG2D,EAAEA,EAAEjI,GAAG,OAAOyE,IAAIwD,GAAG5B,IAAI/B,CAAC,EAAEmE,MAAM,WAA8B,GAAnB5D,KAAK6B,EAAEjB,GAAGgB,EAAG5B,MAASA,KAAK6B,EAAEvE,GAAG,OAAO0C,KAAK6B,EAAEO,MAAMC,OAAO,EAAErC,KAAK,IAAIP,EAAEyC,EAAEtC,EAAE+C,OAAOnB,EAAE5B,EAAEyE,OAAOjB,EAAET,OAAOmH,eAAe9J,MAAMqD,EAAErD,KAAK6B,EACjY,OADmYpC,EAAEA,EAAE+B,EAAEuI,KAAKnK,EAAEwD,EAAE,CAACvB,EAAE,CAACQ,MAAM,CAACD,MAAMiB,EAAEjB,MAAM/E,GAAGgG,EAAEhG,GAAGC,GAAG+F,EAAE/F,GAAGsD,EAAEyC,EAAEzC,EAAEkB,EAAEuB,EAAEvB,EAAEQ,EAAEe,EAAEf,EAAElH,GAAGiI,EAAEjI,SAAUyG,EAAEO,MAAMC,OAChf,EAAE5C,EAAEoC,EAAExE,IAAG,EAAUoC,CAAC,EAAE,MAAC,GAA+B,GAAnBO,KAAK6B,EAAEjB,GAAGgB,EAAG5B,MAASA,KAAK6B,EAAExE,KAAK2C,KAAK6B,EAAEvE,GAAG,MAAM,IAAI6D,EAAE,yCAAyCc,EAAGjC,MAAM,IAAIP,EAAEO,KAAK6B,IAAIpC,EAAE2C,MAAMC,MAAM,IAAI5C,EAAE2C,MAAMC,QAAQ5C,EAAE6C,EAAE7C,EAAErE,GAAG+B,GAAGsC,EAAE6C,GAAG7C,EAAEqC,EAAEC,EAAE5E,GAAGsC,EAAEmB,IAAIZ,KAAK6B,EAAEvE,KAAK0C,KAAK6B,EAAES,OAAE,EAAOtC,KAAK6B,EAAEjB,OAAE,EAAO,EAAEoJ,UAAU,WAAW,OAAOhK,KAAK6B,EAAEjB,CAAC,EAAEqJ,YAAY,WAA8B,GAAnBjK,KAAK6B,EAAEjB,GAAGgB,EAAG5B,MAASA,KAAK6B,EAAExE,KAAK2C,KAAK6B,EAAEvE,GAAG,MAAM,IAAI6D,EAAE,yCAAoE,OAAbnB,KAAK6B,EAAExE,IAAG,EAAU2C,IAAI,IAAI,MAAM7D,EAAE+N,OAAOC,QAAQhO,IAAID,EAAEC,GAAGD,EAAU,OAAG,EADjgB,GAEAyG,OAAOyE,OAAO7C,GAAGqF,UAAU,CAAC,EAAAQ,CAAGlO,GAA2B,OAAxB8D,KAAKZ,KAAKlD,EAAE8D,KAAKZ,GAAGlD,IAAWA,CAAC,EAAE,EAAAoC,CAAGpC,GAAG8D,KAAK7C,KAAKjB,EAAE,EAAElB,GAAG+I,GAAGC,EAAE,SAAS9H,GAAG,SAASC,IAAI,OAAO6D,KAAKjC,GAAGqG,GAAGpE,KAAK+B,EAAE9G,GAAG,CAAC6G,EAAE9B,KAAKK,GAAGO,EAAEnB,EAAErE,GAAG4E,KAAKsC,EAAEpG,IAAIkI,GAAGpE,KAAK+B,EAAE9G,GAAG,CAAC6G,EAAE9B,KAAKY,EAAE1E,GAAG,CAAC,IAAIuD,EAAEO,KAAKoK,GAAGlO,GAAG,IAAIuD,EAAE,OAAOO,KAAK1B,GAAGpC,GAAG,KAAK,IAAI0D,EAlBzI,EAAC1D,EAAEC,KAAK,QAAG,IAASA,EAAE,MAAM,IAAIgF,EAAE,+BAA+B,KAAKjF,EAAEf,IAAIgB,EAAED,EAAE0B,GAAGzB,GAAGD,EAAEA,EAAEf,GAAG,OAAO+I,GAAG/H,EAAC,EAkBmCkO,CAAGrK,KAAK+B,EAAEtC,GAAG,QAAG,IAASG,EAAG,OAAG,IAAIA,EAAEiC,EAAEO,MAAMC,OAAazC,EAAEiC,EAAEjB,EAAEnB,EAAEG,EAAEiC,EAAES,EAAEpG,EAAE0D,EAAEgE,UAAQhE,EAAEA,EAAEgE,QAAQ5D,KAAK1B,GAAGpC,GAAU0D,GAAyB,GAAvBA,EAAEI,KAAK+B,EAAEvC,GAAGC,KAAGG,EAAEiD,EAAGjD,IAAS,OAAOzD,EAAE4N,KAAK/J,MAAMJ,EAAEI,KAAKlC,GAAG8B,EAAEX,GAAGW,EAAE0K,YAAY,IAAI9I,EAAEyC,GAAGxE,EAAEO,KAAK+B,EAAEnC,EAAEmC,GAAG,OAAO,OAAOP,EAAErF,EAAE4N,KAAK/J,MACjfA,KAAKjC,GAAGqG,GAAGxE,EAAEmC,EAAE9G,GAAG,CAAC6G,EAAElC,EAAEgB,EAAEY,EAAEpG,GAAG4E,KAAKsC,EAAEpG,IAAIkI,GAAGxE,EAAEmC,EAAE9G,GAAG,CAAC6G,EAAElC,EAAEgB,EAAEY,GAAG,IAAItG,EAAEqP,gBAAgB7J,EAAGxF,EAAEqP,eAAerP,EAAEsP,WAAWxM,EAAE9C,EAAEsP,UAAUtP,EAAEuP,aAAaxN,EAAE/B,EAAEuP,YAAYvP,EAAEwP,cAAcvP,EAAGD,EAAEwP,aACtL,IAAIC,GAAGpF,GAAGqF,GAAGC,GAAGrF,GAAEsF,GAAG,CAAC3O,EAAE,SAASD,EAAEC,EAAEsD,GAAU,IAAIG,EAAE,IAAIe,EAAjBzE,KAAK,GAA8F,MAA5EyB,EAAEiC,EAAEgB,EAAE,KAAK,IAAI,GAAG,EAAEjD,EAAEiC,EAAEgB,EAAE,IAAI,IAAI,GAAGzE,IAAI,EAAEwB,EAAEiC,EAAEgB,EAAE,IAAI,IAAI,GAAGnB,IAAI,EAAKvD,CAAgB,EAAE8E,EAAE,IAAI5B,EAAG,IAAInC,EAAE,SAASf,EAAEC,EAAEsD,EAAEG,EAAE4B,GAAGtF,KAAK,EAAEuD,KAAK,EAAEtD,EAAE0E,EAAE1E,IAAI,GAAY,IAAIiH,EAAEC,GAAGA,EAAE,GAApBzD,EAAE,KAAKA,EAAkB,CAAC,MAAMyD,EAAE,EAAE5D,EAAE2D,EAAEE,GAAGyH,OAAOC,QAAQ3H,EAAEC,GAAG9B,EAAE4B,EAAE5B,EAAE,CAACH,EAAEnF,EAAE,CAAC4D,KAAK3D,EAAE6H,EAAEZ,EAAEuB,EAAE,CAACtB,EAAEC,KAAK,iBAAiBA,IAAIA,EAAEyH,OAAOzH,IAAWA,GAAGtI,GAAG0G,EAAGvF,EAAEsD,GAAGG,GAAG3D,GAAG,MAAM,EAAEgP,EAAE,SAAS/O,EAAEC,EAAEsD,EAAEG,GAAcyB,EAAEnF,IAAI,EAAE,CAAC4D,KAApB3D,EAAE0E,EAAE1E,IAAI,GAAmB6H,EAAE,SAASxC,GAAG,QAAQA,CAAC,EAAEmD,EAAE,SAASnD,EAAE4B,GAAG,OAAOA,EAAE3D,EAAEG,CAAC,EAAE5E,GAAG,SAASwG,GAAG,OAAOxB,KAAKgE,EAAEzG,EAAEiE,IAC5f,GAAG,EAAEvF,GAAG,MAAM,EAAEoH,EAAE,SAASnH,EAAEC,EAAEsD,EAAEG,EAAE4B,EAAE4B,EAAEC,EAAEC,EAAEkB,EAAEC,EAAEC,EAAEsB,EAAEC,GAAG/J,KAAK,EAAEC,KAAK,EAAEsD,KAAK,EAAEG,KAAK,EAAEwD,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEkB,KAAK,EAAEC,KAAK,EAASuB,KAAK,EAAEC,KAAK,EAAEvB,EAAE7D,EAAvB6D,KAAK,GAAuBtB,EAAE+B,GAAE3D,IAAI,EAAE4B,GAAGE,IAAI6B,GAAE9B,EAAEC,GAAGmB,IAAIU,GAAEX,EAAEC,GAAGwB,EAAEd,GAAEa,EAAEC,GAAG,IAAIC,EA3B3JhK,KAAsC,IAAIC,GAAtCD,EAAEA,EAAEqN,QAAQ,iBAAiB,MAAa/B,WAAW,GAAG,OAAO,IAAIrL,GAAG,IAAIA,EAAE,IAAID,IAAIA,GA2BqEgP,CAAGxG,GAAGxB,GAAGgD,GAAE,WAAWrE,GAAE,oBAAoB6C,yBAAyB,CAAC9E,GAAG,IAAGmC,GAAE,CAAC7F,EAAEC,EAAEsD,GAAGG,EAAE,CAACA,GAAG,IAAGuG,IAAW,GAAPA,EAAEA,EAAE,GAAMvG,EAAG,IAAIwG,EAAED,EAAEpE,EAAMsE,EAAED,EAAEnL,QAAQoL,EAAE5D,EAAGmH,UAAUzD,EAAEzD,EAAGgC,GAAE,YAAYyG,GAAI,GAAGxI,OAAOmH,eAAe9J,QAAQoL,EAAE,MAAM,IAAIjK,EAAE,0BAA0BuD,KAAK,QAAG,IAAS2G,EAAEjO,GAAG,MAAM,IAAI+D,EAAE,GAAGuD,mCACje,IAAI4G,EAAGD,EAAEjO,GAAG+N,EAAGhL,QAAQ,QAAG,IAASmL,EAAG,MAAM,IAAInK,EAAE,2BAA2BuD,wCAAwCyG,EAAGhL,uBAAuBwC,OAAO4I,KAAKF,EAAEjO,IAAIqG,mCAAmC,OAAO6H,EAAGtI,MAAMhD,KAAKmL,EAAG,IAAG,IAAIC,EAAEzI,OAAO0B,OAAOgC,EAAE,CAACtG,YAAY,CAACsC,MAAM8D,KAAKA,EAAEyD,UAAUwB,EAAE,IAA2CH,EAAvCI,EAAE,IAAIlI,GAAGuB,EAAEyB,EAAEiF,EAAEnF,EAAEG,EAAEhD,EAAEE,EAAEmB,GAAM4G,EAAElQ,MAAW8P,EAAEI,EAAElQ,IAAI0C,KAAKoN,EAAEpN,GAAG,IAAIwN,EAAElQ,GAAG0C,GAAG4C,KAAK4K,IAAyH,OAAtHjF,EAAE,IAAI7B,GAAGG,EAAE2G,GAAE,GAAG,GAAG,GAAIJ,EAAE,IAAI1G,GAAGG,EAAE,IAAI2G,GAAE,GAAG,GAAG,GAAIhF,EAAE,IAAI9B,GAAGG,EAAE,UAAU2G,GAAE,GAAG,GAAG,GAAIxI,EAAG3G,GAAG,CAACoO,YAAYW,EAAEhM,GAAGoH,GAAGxB,GAAGqB,EAAEC,GAAS,CAACC,EAAE6E,EAAE5E,EAAC,GAAG,EACrfJ,EAAE,SAAS/J,EAAEC,EAAEsD,EAAEG,EAAE4B,EAAE4B,EAAEC,GAAGnH,KAAK,EAAEC,KAAK,EAAEqF,KAAK,EAAE4B,KAAK,EAAEC,KAAK,EAAE,IAAIC,EAAEgD,GAAG7G,EAAEG,IAAI,GAAGzD,EAAE0E,EAAE1E,GAAGA,EAAEoK,GAAGpK,GAAGiH,EAAE+B,GAAE3D,EAAE4B,GAAGrB,GAAE,GAAG,CAAC7F,IAAGsI,IAAI,SAASC,IAAI5C,GAAE,eAAe6C,yBAAyBpB,EAAE,CAAQ,IAAIoB,EAAE,IAAbF,EAAEA,EAAE,IAAc1E,QAAQ3D,IAAIA,EAAEqP,WAAW,QAAQrP,EAAE+N,OAAO/N,EAAEsP,UAAU,KAAK,IAAIzF,EAAExB,EAAEzC,EAAEhC,YACrO,YADiP,IAASiG,EAAE7J,IAAIsI,EAAExB,GAAGxD,EAAE,EAAEuG,EAAE7J,GAAGsI,IAAI3B,EAAGkD,EAAE7J,EAAEuI,GAAGsB,EAAE7J,GAAG4G,EAAEtD,EAAE,GAAGgF,GAAG1C,GAAE,GAAGuB,GAAE2C,IAAoG,GAAhGA,EAAEH,GAAGpB,EAAE,CAACuB,EAAE,GAAG,MAAMyF,OAAOzF,EAAES,MAAM,IAAI,KAAKtD,EAAEC,QAAG,IAAS2C,EAAE7J,GAAG4G,GAAGkD,EAAEhD,GAAGxD,EAAE,EAAEuG,EAAE7J,GAAG8J,GAAGD,EAAE7J,GAAG4G,EAAEtD,EAAE,GAAGwG,EAAKzB,EAAEzC,EAAElE,GAAG,IAAI,MAAMqI,KAAK1B,EAAEzC,EAAElE,GAAGqI,EAAEnG,YAAYuB,eAAenF,KAClf+J,EAAEnG,YAAY5D,GAAG8J,GAAG,MAAM,EAAA,IAAW,EAAA,GAAI,EAAEG,EAAE,SAASlK,EAAEC,EAAEsD,EAAEG,EAAE4B,EAAE4B,EAAEC,EAAEC,GAAGpH,KAAK,EAASuD,KAAK,EAAEG,KAAK,EAAEwD,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEnH,EAAE0E,EAA5C1E,KAAK,GAA4CiH,EAAE+B,GAAE3D,IAAI,EAAE4B,GAAGrB,GAAE,GAAG,CAAC7F,IAAGsI,IAAW,IAAIC,EAAE,IAAbD,EAAEA,EAAE,IAAc1E,QAAQ3D,IAAIuI,EAAE,CAAC,GAAAM,GAAMnD,GAAE,iBAAiB4C,yBAAyB,CAAChF,GAAG,EAAEkM,YAAW,EAAGC,cAAa,GACxK,OAD4KlH,EAAEmH,IAAIvI,EAAE,KAAKzB,GAAE,iBAAiB4C,yBAAyB,CAAChF,GAAE,EAAG,KAAK,MAAM,IAAI0B,EAAE,GAAGsD,4BAA4B,EAAG9B,OAAOC,eAAe4B,EAAEzC,EAAEhC,YAAY5D,EAAEuI,GAAG3C,GAAE,GAAG,CAACtC,IAAGuG,IAAIA,EAAEA,EAAE,GAAG,IAAIC,EAAE,CAACjB,IAAG,IAAUgB,EAAEhC,EAAEZ,EAAExD,IAAK+L,YAAW,GAClZ,OADsZrI,IAAIA,EACrf6B,GAAE9B,EAAEC,GAAG2C,EAAE4F,IAAI3F,IAAI,IAAIC,EAAE,GAAG7C,EAAE1D,EAAEoG,EAAErB,EAAEwB,EAAED,IAAIN,GAAGO,KAAKxD,OAAOC,eAAe4B,EAAEzC,EAAEhC,YAAY5D,EAAE8J,GAAS,EAAA,IAAW,KAAI,EAAE3C,EAAE,SAASpH,EAAEC,EAAEsD,EAAEG,EAAE4B,EAAE4B,GAAGlH,KAAK,EAAE0D,KAAK,EAAE4B,KAAK,EAAE4B,KAAK,EAAE,IAAIC,EAAEiD,GAAGnK,EAAEsD,IAAI,GAAG+B,EAAE2D,GAAEvF,EAAE4B,GAAGO,GAAE,GAAG,CAAC7F,IAAGoH,IAAW,IAAIkB,EAAE,gBAAblB,EAAEA,EAAE,IAA0BxD,OAAoC,QAA7B,IAASwD,EAAEvB,EAAE3E,KAAKkG,EAAEvB,EAAE3E,GAAG,SAAO,IAASkG,EAAEvB,EAAE3E,GAAGjB,EAAE,GAAG,MAAM,IAAIgF,EAAE,8EAA8EhF,EAAE,iBAAiBmH,EAAExD,2GACxQ,OAA/IwD,EAAEvB,EAAE3E,GAAGjB,EAAE,GAAG,KAAK0F,GAAE,oBAAoByB,EAAExD,4BAA4BuD,EAAC,EAAGtB,GAAE,GAAGsB,GAAEoB,IAAIA,EAAEqH,OAAO,EAAE,EAAE,MAAMxI,EAAEvB,EAAE3E,GAAGjB,EAAE,GAAG2J,GAAGtB,EAAEC,EAAE,KAAKjD,EAAE4B,GAAS,MAAW,EAAA,GAAI,EAAElH,EAAE,SAASA,EAAEC,EAAEsD,EAAEG,EAAE4B,EAAE4B,EAAEC,EAAEC,GAAGpH,KAAK,EAAEC,KAAK,EAAEqF,KAAK,EAAE4B,KAAK,EAAEC,KAAK,EAAE,IAAImB,EAAE8B,GAAG7G,EAAEG,IAAI,GAAGzD,EAAE0E,EAAE1E,GAAGA,EAAEoK,GAAGpK,GAAGiH,EAAE+B,GAAE3D,EAAE4B,GAAGrB,GAAE,GAAG,CAAC7F,IAAGuI,IAAI,SAASC,IAAI7C,GAAE,eAAemE,yBAAyBxB,EAAE,CAAQ,IAAIwB,EAAE,IAAbvB,EAAEA,EAAE,IAAc3E,QAAQ3D,IAAIA,EAAEqP,WAAW,QAAQrP,EAAE+N,OAAO/N,EAAEsP,UAAU,KAAKnI,GAAGmB,EAAE1C,EAAEzB,GAAGG,KAAKtE,GAAG,IAAI8J,EAAExB,EAAE1C,EAAE9G,GAAGiL,EAAED,EAAE9J,GAClS,YADqS,IAAS+J,QAAG,IAASA,EAAEnD,GAAGmD,EAAE6F,YAAYtH,EAAE3E,MAAMoG,EAAEjD,KAChfxD,EAAE,GAAGiF,EAAEzB,GAAGxD,EAAE,EAAEiF,EAAEqH,UAAUtH,EAAE3E,KAAKmG,EAAE9J,GAAGuI,IAAI5B,EAAGmD,EAAE9J,EAAE6J,GAAGC,EAAE9J,GAAG4G,EAAEtD,EAAE,GAAGiF,GAAG3C,GAAE,GAAGyC,GAAE2B,IAAIA,EAAEL,GAAGE,EAAEG,EAAE1B,EAAErB,EAAEC,QAAG,IAAS4C,EAAE9J,GAAG4G,GAAGoD,EAAElD,GAAGxD,EAAE,EAAEwG,EAAE9J,GAAGgK,GAAGF,EAAE9J,GAAG4G,EAAEtD,EAAE,GAAG0G,EAAQ,MAAW,KAAI,EAAEH,EAAE,SAAS9J,EAAEC,EAAEsD,EAAEG,EAAE4B,EAAE4B,EAAEC,EAAEC,EAAEkB,EAAEC,GAAGvI,KAAK,EAASuD,KAAK,EAAE+B,KAAK,EAAE4B,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEkB,KAAK,EAAEC,KAAK,EAAEtI,EAAE0E,EAA1D1E,KAAK,GAA0DqF,EAAE2D,GAAEvF,IAAI,EAAE4B,GAAGO,GAAE,GAAG,CAAC7F,IAAGwI,IAAW,IAAIsB,EAAE,IAAbtB,EAAEA,EAAE,IAAc5E,QAAQ3D,IAAI8J,EAAE,CAAC,GAAAjB,GAAMnD,GAAE,iBAAiBmE,yBAAyB,CAACvG,EAAE4D,GAAG,EAAEsI,YAAW,EAAGC,cAAa,GAC5H,OADgI3F,EAAE4F,IAAIrH,EAAE,IAAI3C,GAAE,iBAAiBmE,yBAAyB,CAACvG,EAAE4D,IAAI,KAAK,MAAM,IAAIlC,EAAE6E,EAAE,2BAA2B,EAC1gBrD,OAAOC,eAAe8B,EAAE3C,EAAE9G,GAAGkB,EAAE8J,GAAGlE,GAAE,GAAGyC,EAAE,CAAC/E,EAAE4D,GAAG,CAAC5D,IAAGyG,IAAI,IAAIC,EAAED,EAAE,GAAGE,EAAE,CAAC,GAAApB,GAAM,IAAIoG,EAAEzE,GAAG3G,KAAK0E,EAAEsB,EAAE,WAAW,OAAOG,EAAEnC,EAAExC,EAAE4B,EAAEgI,GAAG,EAAEO,YAAW,GAAI,GAAGnH,EAAE,CAACA,EAAEW,GAAE7B,EAAEkB,GAAG,IAAI6B,EAAEH,EAAE,GAAGE,EAAEyF,IAAI,SAAST,GAAG,IAAIC,EAAE1E,GAAG3G,KAAK0E,EAAEsB,EAAE,WAAWiF,EAAE,GAAGzG,EAAEC,EAAE4G,EAAEhF,EAAE1B,EAAEsG,EAAEG,IAAIxF,GAAGqF,EAAE,CAAC,CAAmC,OAAlCtI,OAAOC,eAAe8B,EAAE3C,EAAE9G,GAAGkB,EAAEiK,GAAS,EAAA,IAAW,KAAI,EAAEzI,EAAE,SAASzB,GAAG,OAAOmF,EAAEnF,IAAI,EAAE6K,GAAG,EAAEZ,EAAE,SAASjK,EAAEC,EAAEsD,EAAEG,GAAG,SAAS4B,IAAI,CAACrF,EAAE0E,EAAE1E,IAAI,GAAGqF,EAAEwK,OAAO,CAAA,EAAG3K,EAAEnF,IAAI,EAAE,CAAC4D,KAAK3D,EAAE4D,YAAYyB,EAAEwC,EAAE,SAASZ,GAAG,OAAOpD,KAAKD,YAAYiM,OAAO5I,EAAE,EAAEuB,EAAE,CAACvB,EAAEC,IAAIA,EAAEhB,MAAMrH,GAAGgM,GAAG7K,EAAEsD,IAAI,EAAEG,GACpf3D,GAAG,OAAOiH,GAAG/G,EAAEqF,EAAE,EAAExD,EAAE,SAAS9B,EAAEC,EAAEsD,GAAGtD,KAAK,EAAE,IAAIyD,EAAEqH,GAAG/K,IAAI,EAAE,QAAQC,EAAE0E,EAAE1E,GAAGD,EAAE0D,EAAEG,YAAYH,EAAE+C,OAAO0B,OAAOzE,EAAEG,YAAY6J,UAAU,CAACvH,MAAM,CAACA,MAAM5C,GAAGM,YAAY,CAACsC,MAAMK,EAAG,GAAG9C,EAAEE,QAAQ3D,KAAI,WAAW,OAAMD,EAAE8P,OAAOvM,GAAGG,EAAE1D,EAAEC,GAAGyD,CAAC,EAAEsG,EAAE,SAAShK,EAAEC,EAAEsD,GAAc4B,EAAEnF,IAAI,EAAE,CAAC4D,KAApB3D,EAAE0E,EAAE1E,IAAI,GAAmB6H,EAAEpE,GAAGA,EAAE+E,EAAE,CAAC/E,EAAE4B,IAAIA,EAAExG,GAAGkM,GAAG/K,EAAEsD,IAAI,GAAGxD,GAAG,MAAM,EAAEyI,EAAE,SAASxI,EAAEC,EAAEsD,EAAEG,EAAE4B,EAAE4B,GAAGlH,KAAK,EAAE0D,KAAK,EAAE4B,KAAK,EAAE4B,KAAK,EAAE,IAAIC,EAAEiD,GAAGnK,EAAEsD,IAAI,GAAGvD,EAAE2E,EAAE3E,GAAGA,EAAEqK,GAAGrK,GAAGsF,EAAE2D,GAAEvF,EAAE4B,GAAG0B,GAAGhH,GAAE,WAAW2F,GAAE,eAAe3F,yBAAyBmH,EAAE,GAAElH,EAAE,GAAG4F,GAAE,GAAGsB,GAAEC,IAAIuB,GAAG3I,EAAE4J,GAAG5J,EAAE,CAACoH,EAAE,GACnf,MAAMoI,OAAOpI,EAAEoD,MAAM,IAAI,KAAKlF,EAAE4B,GAAGjH,EAAE,GAAS,KAAI,EAAEsI,EAAE,SAASvI,EAAEC,EAAEsD,EAAEG,EAAE4B,GAAGtF,KAAK,EAAEuD,KAAK,EAAEtD,EAAE0E,EAAE1E,IAAI,GAAG,IAAIiH,EAAEE,GAAGA,EAAE,GAAG,IAAI1D,EAAE,CAAC,IAAIyD,EAAE,GAAG,EAAE5D,EAAE2D,EAAEE,GAAGA,GAAGD,IAAIA,EAAE7B,EAAE4B,EAAE5B,EAAE,CAACH,EAAEnF,EAAE,CAAC4D,KAAK3D,EAAE6H,EAAEZ,EAAEuB,EAAE,CAACrB,EAAEkB,IAAIA,EAAExJ,GAAG0G,EAAGvF,EAAEsD,EAAE,IAAIG,GAAG3D,GAAG,MAAM,EAAEf,EAAE,SAASgB,EAAEC,EAAEsD,GAAG,SAASG,EAAEwD,GAAG,OAAO,IAAI5B,EAAElE,EAAGiB,OAAOZ,EAAEyF,EAAE,IAAI,IAAI,GAAGzF,EAAEyF,IAAI,IAAI,GAAG,CAAC,IAAI5B,EAAE,CAAChD,UAAUhC,WAAWiC,WAAWC,YAAYC,WAAWC,YAAYC,aAAaC,aAAaC,cAAcC,gBAAgB7C,GAAckF,EAAEnF,IAAI,EAAE,CAAC4D,KAApBL,EAAEoB,EAAEpB,IAAI,GAAmBuE,EAAEpE,EAAE5E,GAAG4E,GAAG,CAACC,IAAG,GAAI,EAAEoM,EAAE,SAAS/P,GAAGmF,EAAEnF,IAAI,EAAEiL,GAAG,EAAEjI,EAAE,SAAShD,EAC/fC,GAAckF,EAAEnF,IAAI,EAAE,CAAC4D,KAApB3D,EAAE0E,EAAE1E,IAAI,GAAmB,CAAA6H,CAAEvE,GAAG,IAAIG,GAAGA,EAAEH,EAAE,IAAI,GApBqK,EAACvD,EAAE,EAAEC,KAAK,IAAIsD,EAAElC,EAAwB,GAAG,IAAlBpB,EAAEwL,GAAGlI,EAAZvD,KAAK,EAAWC,GAAE,IAAYD,GAAGuD,EAAElB,QAAQkJ,GAAG,OAAOA,GAAGK,OAAOrI,EAAEsI,SAAS7L,EAAEC,IAAI,IAAI,IAAIyD,EAAE,GAAG1D,EAAEC,GAAG,CAAC,IAAIqF,EAAE/B,EAAEvD,KAAK,GAAK,IAAFsF,EAAM,CAAC,IAAI4B,EAAS,GAAP3D,EAAEvD,KAAQ,GAAG,MAAQ,IAAFsF,GAAO5B,GAAGkB,OAAOC,cAAgB,GAAFS,IAAO,EAAE4B,OAAO,CAAC,IAAIC,EAAS,GAAP5D,EAAEvD,KACjb,OADybsF,EAAE,MAAQ,IAAFA,IAAU,GAAFA,IAAO,GAAG4B,GAAG,EAAEC,GAAK,EAAF7B,IAAM,GAAG4B,GAAG,GAAGC,GAAG,EAChf,GADkf5D,EAAEvD,MACze0D,GAAGkB,OAAOC,aAAaS,IAAIA,GAAG,MAAM5B,GAAGkB,OAAOC,aAAa,MAAMS,GAAG,GAAG,MAAQ,KAAFA,GAAQ,CAAC,MAAM5B,GAAGkB,OAAOC,aAAaS,EAAE,CAAC,OAAO5B,GAmBnFsM,CAAGtM,EAAEjC,EAAE8B,IAAI,IAAI,IAAI,GAAQ,OAAL+F,GAAE/F,GAAUG,CAAC,EAAE,CAAA+E,CAAElF,EAAEG,GAAGA,aAAauM,cAAcvM,EAAE,IAAIpD,WAAWoD,IAAI,IAAI4B,EAAE,iBAAiB5B,EAAE,KAAK4B,GAAG2K,YAAYC,OAAOxM,IAAI,GAAGA,EAAEyM,mBAAmB,MAAM,IAAIlL,EAAE,yCAAyC,IAAIiC,EAAE5B,EAAE+F,GAAG3H,GAAGA,EAAEO,OAAWkD,EAAEwH,GAAG,EAAEzH,EAAE,GAAGE,EAAED,EAAE,EAAmE,OAAjE1F,EAAE0F,IAAI,IAAI,GAAGD,EAAE5B,EAAEM,GAAElC,EAAE0D,EAAEF,EAAE,GAAG7F,EAAEsO,IAAIjM,EAAE0D,IAAI,GAAG,OAAO7D,GAAGA,EAAEgB,KAAK+E,GAAEnC,GAAUA,CAAC,EAAErI,GAAG+I,GAAG,EAAA9H,CAAGwD,GAAG+F,GAAE/F,EAAE,GAAG,EAAE6M,EAAE,SAASpQ,EAAEC,EAAEsD,GAAwB,GAArBtD,KAAK,EAASsD,EAAEoB,EAATpB,KAAK,GAAY,IAAItD,EAAG,IAAIyD,EAAEiI,GAAOrG,EAAEwG,GAAO5E,EAAE6E,QAAQrI,EACpfsI,GAAG1G,EAAE4G,GAAGhF,EAAEiF,GAAGhH,EAAEnF,IAAI,EAAE,CAAC4D,KAAKL,EAAEuE,EAAEX,IAAI,IAAIC,EAAE1D,EAAEyD,EAAE,EAAE1F,EAAE0F,IAAI,IAAI,GAAGlH,GAAE,GAAS,OAALqJ,GAAEnC,GAAUC,GAAGqB,EAAE,CAACtB,EAAEC,KAAK,GAAG,iBAAiBA,EAAE,MAAM,IAAInC,EAAE,6CAA6C1B,KAAK,IAAI+E,EAAEpB,EAAEE,GAAGmB,EAAEoG,GAAG,EAAErG,EAAErI,GAAuD,OAApDwB,EAAE8G,IAAI,IAAI,GAAGD,EAAErI,EAAEqF,EAAE8B,EAAEmB,EAAE,EAAED,EAAErI,GAAG,OAAOkH,GAAGA,EAAE5C,KAAK+E,GAAEf,GAAUA,GAAGzJ,GAAG+I,GAAG,EAAA9H,CAAGoH,GAAGmC,GAAEnC,EAAE,GAAG,EAAElE,EAAE,SAASjD,EAAEC,GAAckF,EAAEnF,IAAI,EAAE,CAACgE,IAAG,EAAGJ,KAA1B3D,EAAE0E,EAAE1E,IAAI,GAAyB6H,EAAE,OAAOW,EAAE,QAAQ,EAAE0G,EAAE,KAAK3K,GAAG,EAAG4H,GAAG,CAAA,EAAG7I,EAAE,SAASvD,EAAEC,EAAEsD,GAAG,IAAKG,KAAK4B,GAnBkG,EAACtF,EAAEC,KAClf,IAAI,IAAIsD,EAAEkG,MAAMzJ,GAAG0D,EAAE,EAAEA,EAAE1D,IAAI0D,EAAEH,EAAEG,GAAGqH,GAAGtJ,EAAExB,EAAE,EAAEyD,IAAI,IAAI,GAAG,aAAaA,KAAK,OAAOH,GAkB+T8M,CAAGrQ,EAAEC,IAAI,GAAGiH,EAAExD,EAAE+E,EAAExG,KAAKyB,GAAGyD,EAAE7B,EAAEiE,KAAIjB,GAAGA,EAAExJ,GAAGmD,KAAKqG,KAAItI,IAAI,IAAIoH,EAAEqC,MAAMzJ,GACpd,OADudC,EAAE,iBAAiBqF,EAAEiE,KAAIjB,GAAGA,EAAE1E,cAAaF,EAAEE,QAnBhE5D,KAAI,IAAIC,EAAEoM,GAAGpI,OAAkB,OAAXoI,GAAG9H,KAAKvE,GAAUC,GAoBneqQ,CAAG9J,EAAGvG,GAAE,CAACqI,EAAEC,EAAEC,EAAEsB,KAAK,IAAI,IAAIC,EAAE,EAAEC,EAAE,EAAEA,EAAEhK,IAAIgK,EAAE5C,EAAE4C,GAAG7C,EAAE6C,GAAGF,EAAEC,GAAGA,GAAG,EAAE,OAAOxG,GAAG,KAAK,EAAE,IAAI0G,EAAEnC,GAAEQ,GAAGxB,MAAM,KAAKM,GAAG,MAAM,KAAK,EAAE6C,EAAEsG,QAAQC,UAAU1I,GAAEQ,GAAGlB,GAAG,MAAM,KAAK,EAAE6C,EAAE7C,EAAE,GAAG,MAAM,KAAK,EAAE6C,EAAEnC,GAAEQ,GAAGiE,GAAGhE,OAAOnB,GAA+C,OAAvC6C,EAAE/C,EAAPoB,EAAE,GAAS2B,GAAG3B,EAAErE,SAASxC,EAAE+G,IAAI,IAAI,GAAGb,GAAEW,IAAW2B,KAAI,EAAE/C,EAAEyD,GAAG8F,EAAE,SAASzQ,EAAEC,GAA4B,OAAzBA,KAAK,EAAED,EAAE8H,GAAE9H,IAAI,GAAGC,EAAE6H,GAAE7H,GAAU0H,GAAE3H,EAAEC,GAAG,EAAEyQ,EAAE,SAAS1Q,GAAU,GAAPA,KAAK,KAAQ0E,GAAE1E,EAAE,IAAI,EAAE,EAAEsF,EAAE,SAAStF,EAAEC,EAAEsD,EAAEG,EAAE4B,GAAG,OAAO+G,GAAGrM,IAAI,GAAGC,IAAI,EAAEsD,IAAI,EAAEG,IAAI,EAAE4B,IAAI,EAAE,EAAE9D,EAAE,WAAW,OAAOmG,GAAE,GAAG,EAAEW,EAAE,SAAStI,GAAG,OAAO2H,GAAE4E,GAAGvM,IAAI,GAAG,EAAE0D,EAAE,SAAS1D,GACrf,IAAIC,EAAE6H,GADkf9H,KAC1f,GAAa0J,GAAGzJ,GAAG0K,GAAG3K,EAAE,EAAEuB,EAAE,CAACvB,EAAEC,KAA+C,GAA1C4G,GAAE7G,KAAK2Q,aAAa9J,GAAE7G,GAAG4Q,WAAW/J,GAAE7G,KAAQC,EAAE,OAAO,EAAE,IAAIsD,EAAEsN,YAAW,YAAYhK,GAAE7G,GApBoIA,KAAI,IAAIkC,EAAE,IAAI,GAAGlC,MAAMwE,GAAI,EAAE4H,IAAI,IAAIpL,EAAEhB,EAAEgB,EAAEyL,GAAGzM,EAAE,CAAC,MAAMC,GAAGuM,GAAGvM,EAAE,CAAC,CAAC,MAAMA,GAAGuM,GAAGvM,EAAE,GAoBhN6Q,EAAG,IAAIpC,GAAG1O,EAAE+Q,YAAYC,QAAM,GAAG/Q,GAAoB,OAAjB4G,GAAE7G,GAAG,CAAC4Q,GAAGrN,EAAE0N,GAAGhR,GAAU,GAAGe,EAAE,SAAShB,EAAEC,EAAEsD,EAAEG,GAAGH,KAAK,EAAEG,KAAK,EAAE,IAAI4B,GAAE,IAAK4L,MAAMC,cAAcjK,EAAE,IAAKgK,KAAK5L,EAAE,EAAE,GAAI8L,oBAAoB9L,EAAE,IAAK4L,KAAK5L,EAAE,EAAE,GAAI8L,oBAAoB3P,EAAEzB,IAAI,IAAI,IAAI,GAAG,GAAGqR,KAAKC,IAAIpK,EAAE5B,GAAG9D,EAAEvB,IAAI,IAAI,IAAI,GAAGsR,OAAOrK,GAAG5B,GACrXtF,GADwXC,EAAEkH,IAAI,IAAIC,EAAEiK,KAAKG,IAAIrK,GAAG,MAAM,MAAM,GAAGA,EAAE,IAAI,MAAMvC,OAAOyM,KAAKI,MAAMrK,EAAE,KAAKsK,SAAS,EAAE,OAAO9M,OAAOwC,EACpf,IAAIsK,SAAS,EAAE,MAAI,GAAQxK,GAAGjH,EAAEA,EAAEqF,GAAGA,EAAE4B,GAAGtB,GAAE5F,EAAEuD,EAAE,IAAIqC,GAAE3F,EAAEyD,EAAE,MAAMkC,GAAE5F,EAAE0D,EAAE,IAAIkC,GAAE3F,EAAEsD,EAAE,IAAI,EAAEoB,EAAE,SAAS3E,GAAGA,KAAK,EAAE,IAAIC,EAAEoB,EAAE4C,OAAO,GAAG,WAAWjE,EAAE,OAAM,EAAG,IAAI,IAAIuD,EAAE,EAAE,GAAGA,EAAEA,GAAG,EAAE,CAAC,IAAIG,EAAEzD,GAAG,EAAE,GAAGsD,GAAGG,EAAE2N,KAAKM,IAAIjO,EAAE1D,EAAE,WAAWC,EAAE,CAACyD,GAAG2N,KAAKM,IAAI,WAAW,MAAMN,KAAKO,KAAKP,KAAKC,IAAItR,EAAE0D,GAAG,QAAQvC,EAAGkB,OAAOwP,WAAW,OAAO,MAAM,EAAE,IAAI1Q,EAAG2Q,KAAKpO,GAAGtB,IAAK,IAAIkD,EAAE,EAAE,MAAMrF,CAAC,CAAC,MAAMiH,GAAG,CAAC5B,OAAE,CAAM,CAAC,GAAGA,EAAE,QAAQ,CAAC,OAAM,CAAE,EAAEjE,EAAE,SAASrB,EAAEC,GAAGD,KAAK,EAAEC,KAAK,EAAE,IAAYqF,EAAR/B,EAAE,EAAEG,EAAE,EAAI,IAAI4B,KAAKsH,KAAK,CAAC,IAAI1F,EAAEjH,EAAEsD,EAAE9B,EAAEzB,EAAE0D,IAAI,IAAI,GAAGwD,EAAE3D,GAAGqC,GAAEN,EAAE4B,EAAE6K,KAAU,EAAErO,GACnf,CAAC,CAAC,OAAO,CAAC,EAAEyG,EAAE,SAASnK,EAAEC,GAAGD,KAAK,EAAEC,KAAK,EAAE,IAAIsD,EAAEqJ,KAA+B,IAAI,IAAIlJ,KAAlCjC,EAAEzB,IAAI,IAAI,GAAGuD,EAAEU,OAAOjE,EAAE,EAAeuD,GAAEvD,GAAGqL,GAAG3H,GAAG,EAAiB,OAAfjC,EAAExB,IAAI,IAAI,GAAGD,EAAS,CAAC,EAAEsB,EAAEmL,GAAGvK,EAAE,SAASlC,EAAEC,GAA8C,OAA3CD,KAAK,EAAEuN,GAAGlM,EAAEwK,SAAS7L,IAAI,EAAEA,GAAGC,IAAI,KAAK,IAAW,CAAC,GAAGmG,SAASzH,iBAAiB,SAASqB,EAAEuD,GAAmJ,OAAhJ6C,GAAE7C,EAAEyO,QAAQ5L,GACb,WAAc,IAAIpG,EAAEoG,GAAEpG,EAAEyG,OAAOyE,OAAO,GAAGlL,GAAG,IAAIC,EAAEsD,GAAGG,GAAGH,EAAEG,KAAK,EAA+J,OAA7J1D,EAAEmF,EAAElF,EAAED,EAAEmF,GAAGnF,EAAE2H,EAAE1H,EAAED,EAAE2H,GAAG3H,EAAEiS,wBAAwBhS,EAAED,EAAEiS,yBAAyBjS,EAAEkS,6BAA6B,CAAC3O,GAAG,IAAIA,MAAM,EAAd,CAAiBvD,EAAEkS,8BAAqClS,CAAC,CADvNmS,GAAKhR,EAAGiF,GAAErB,EAAE3C,IAAKsG,GAAGtC,GAAEkD,EAAE/F,EAAE6C,GAAEpH,EAAEoT,MAAM3D,GAAGlL,EAAE0B,EAAEoE,GAAG9F,EAAE4B,EAAEuJ,GAAGnL,EAAEyC,EAAE2I,GAAGpL,EAAEoE,EAAE2B,GAAE/F,EAAE0F,EAAEjG,IAAIhE,EAAEqT,yBAAyBrP,GAAG,GAAGA,GAAGC,IAAIM,EAAEN,EAAEA,EAAE,KAAKM,KAAY6C,EAAC,CAACpD,IAAIhE,EAAEqT,yBAAyBrP,GAAG,IAAI/C,EAAE,CAACA,EAAE2O,IAAI,OAAG5P,EAAEsT,gBAAuB,IAAIC,SAAQhP,IAAIvE,EAAEsT,gBAAgBrS,GAC3f,CAACyD,EAAE4B,KAAK/B,EAAEvD,EAAE0D,GAAI,GAAE,KAAIX,IAAK/D,EAAEwT,WAAWxT,EAAEwT,WAAWxT,EAAEwT,WAAW,kCAAkCzS,GAAIA,EAAG,kCAAkC,IAAKF,IAAI,kCAAkC,oBAAAV,UAAA,oBAAAC,SAAAC,QAAA,OAAAC,cAAAC,YAAAC,KAAA,oBAAAL,SAAAC,SAAAI,KAAAC,GAAA,WAAAA,EAAAC,QAAAC,eAAAF,EAAAG,KAAA,IAAAC,IAAA,+BAAAV,SAAAW,SAAAN,MAAkBA,KAAYQ,SAjDtNrB,eAAkBqB,GAAG,IAAIC,EAAE8C,EAAG,IAAIhC,EAAE,IAAI,IAAIwC,EAAE/C,MAAMP,EAAE,CAACQ,YAAY,gBAAgB,aAAa2C,YAAYqP,qBAAqBlP,EAAEvD,EAAE,CAAC,MAAM0D,GAAG5B,EAAE,kCAAkC4B,KAAK5B,EAAE,4CAA4C,CAAC,OAAOwB,EAAGrD,EAAED,EAAE,CAiDtBkO,CAAGjO,IAAIyS,UAAS,CADhC,GAG9L,GAAG1T,EAAE2T,QAAQ,IAAI,mBAAmB3T,EAAE2T,UAAU3T,EAAE2T,QAAQ,CAAC3T,EAAE2T,UAAU,EAAE3T,EAAE2T,QAAQ1O,QAAQjF,EAAE2T,QAAQzO,OAAVlF,GAC3G,OAFD,SAAS4T,IAAK,SAAS5S,IAAmB,GAAfhB,EAAE6T,WAAU,GAAO3Q,EAAE,CAAgD,GAA/CC,GAAG,EAAGiE,GAAE8I,IAAIjO,IAAKjC,GAAGA,EAAE8T,0BAA6B9T,EAAE+T,aAAa,CAAC,IAAI9S,EAAEwO,GAAG,IAAI,IAAIlL,EAAEtD,EAAE,EAAE,GAAGe,EAAEuC,EAAEkJ,GAAGlJ,EAAE,CAAC,MAAMG,GAAG8I,GAAG9I,EAAE,CAAC,CAAC,GAAG1E,EAAEgU,QAAQ,IAAI,mBAAmBhU,EAAEgU,UAAUhU,EAAEgU,QAAQ,CAAChU,EAAEgU,UAAUhU,EAAEgU,QAAQ/O,QAAQhE,EAAEjB,EAAEgU,QAAQ9O,QAAQC,EAAGI,KAAKtE,GAAG+D,EAAGG,EAAG,CAAC,CAAC,GAAG,EAAEnB,EAAEC,EAAE2P,MAAO,CAAC,GAAG5T,EAAEsF,OAAO,IAAI,mBAAmBtF,EAAEsF,SAAStF,EAAEsF,OAAO,CAACtF,EAAEsF,SAAStF,EAAEsF,OAAOL,QAAQI,IAAKL,EAAGI,GAAI,EAAEpB,EAAEC,EAAE2P,EAAG5T,EAAEiU,WAAWjU,EAAEiU,UAAU,cAAcpC,YAAW,KAAKA,YAAW,IAAI7R,EAAEiU,UAAU,KACpf,GAAGjT,GAAC,GAAI,IAAIA,GAAG,CAAC,CAAgH4S,GAAKzQ,EAAanD,EAAY,IAAIuT,SAAQ,CAACvS,EAAEC,KAAKgB,EAAGjB,EAAEkB,EAAGjB,CAAA,GACzK,CCvDV,MACMiT,EAA0B,0BCiDvC,MAAMC,EAAiB,IA1CvB,MAIE,WAAAtP,GAHQC,KAAAsP,cACNC,EAGoC,oBAAzBpN,uBACTnC,KAAKsP,SAAW,IAAInN,sBAAyCqN,IAC3D,IACEA,EAAMC,SAASC,QACjB,CAAE,MAAOxR,GAET,KAGN,CAEA,QAAAsE,CAAuCmN,EAAgBF,GACrD,IAAKzP,KAAKsP,SACR,MAAO,CAAE/M,WAAY,OAAUqN,WAAY,QAG7C,MAAMC,EAAQF,EACRH,EAA0B,CAAEC,YAIlC,OAFAzP,KAAKsP,SAAS9M,SAASmN,EAAQH,EAAOK,GAE/B,CACLtN,WAAY,KACVvC,KAAKsP,UAAU/M,WAAWsN,EAAM,EAGlCD,WAAaE,IACX9P,KAAKsP,UAAU/M,WAAWsN,GAC1B,MAAME,EAA6B,CACjCN,SAAUK,GAEZ9P,KAAKsP,UAAU9M,SAASmN,EAAQI,EAAUF,EAAM,EAGtD,GAKI,SAAUG,EACdL,EACAF,GAEA,OAAOJ,EAAe7M,SAASmN,EAAQF,EACzC,CCDA,MA8QaQ,EAAmB,EAC9BC,YA9QA,CAACC,GACD,EACEC,YACAC,mBACAC,YACAC,YAEDC,IACC,MAAMC,EAAcN,EAAQO,aAC5B,IAAIC,EACJ,IACEA,EAAY,IAAIF,EAAYD,EAAQ5B,SACtC,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CAQA,MAAMqP,EAAqB,CASzB,YAAIjC,GACF,OAAO+B,CACT,EAUA,YAAAG,CAAalC,GACXiC,EAAKnB,SACLiB,EAAY/B,EACZmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EA2BA,MAAAyB,CACEC,EACAC,GAEA,IACE,GAAID,EAAMlR,cAAgBpB,WAAY,CACpC,GAAIuS,EAEF,YADAP,EAAUK,OAAOC,EAAOC,EAAUtC,SAAU,SAG9C,MAAMuC,EAAQb,IAEd,OADAK,EAAUK,OAAOC,EAAOE,EAAMvC,SAAU,SACjCuC,CACT,CAEA,GAAIF,EAAMlR,cAAgBnB,YAAa,CACrC,GAAIsS,EAEF,YADAP,EAAUK,OAAOC,EAAOC,EAAUtC,SAAU,UAG9C,MAAMuC,EAAQb,IAEd,OADAK,EAAUK,OAAOC,EAAOE,EAAMvC,SAAU,UACjCuC,CACT,CAEA,GAAIF,EAAMlR,cAAgBhB,cAAe,CAEvC,MAAMqS,EAAcH,EAAMxN,WAAW4N,MAAM,KAC3C,GAAIH,EAEF,YADAP,EAAUK,OAAOI,EAAaF,EAAUtC,SAAU,SAGpD,MAAMuC,EAAQb,IAEd,OADAK,EAAUK,OAAOI,EAAaD,EAAMvC,SAAU,SACvCuC,CACT,CAEA,GAAIF,EAAMlR,cAAgBf,eAAgB,CAExC,MAAMoS,EAAcH,EAAMxN,WAAW4N,MAAM,KAC3C,GAAIH,EAEF,YADAP,EAAUK,OAAOI,EAAaF,EAAUtC,SAAU,UAGpD,MAAMuC,EAAQb,IAEd,OADAK,EAAUK,OAAOI,EAAaD,EAAMvC,SAAU,UACvCuC,CACT,CAEA,MAAM,IAAIrU,MFhMlB,6GEiMM,CAAE,MAAO0E,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EA4BA,MAAAsG,CACEoJ,EACAI,GAAS,EACTC,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAIF,EAAQ,CACV,MAAMG,EAAWlB,IACX3B,EAAW+B,EAAUe,YAAYR,EAAUtC,SAAU2C,GAC3DE,EAASX,aAAalC,GACtB6C,EAASE,QAAQ,cACjB,MAAMC,EAAUH,EAASI,UAEzB,OADAJ,EAAS/B,SACFkC,CACT,CACA,MAAMH,EAAWlB,IACX3B,EAAW+B,EAAUmB,aAAaZ,EAAUtC,SAAU2C,GAC5DE,EAASX,aAAalC,GACtB6C,EAASE,QAAQ,eACjB,MAAMC,EAAUH,EAASI,UAEzB,OADAJ,EAAS/B,SACFkC,CACT,CAAE,MAAOpQ,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EA8BA,YAAAuQ,CACEb,EACAI,GAAS,EACTC,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAIF,EAAQ,CACV,MAAM1C,EAAW+B,EAAUoB,aACzBb,EAAUtC,UACV,EACA2C,GAEF,OAAOxS,cAAciT,KAAKpD,EAC5B,CACA,MAAMA,EAAW+B,EAAUoB,aACzBb,EAAUtC,UACV,EACA2C,GAEF,OAAOvS,eAAegT,KAAKpD,EAC7B,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EASA,aAAIyQ,GACF,OAAOtB,EAAUsB,WACnB,GAGIlB,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAONqB,CADkBhC,EAAOC,SC9Q5BgC,EACHhC,GACD,EACEC,YACAgC,gBACAC,cACAhC,mBACAE,YAEF,CAAC+B,EAAsC,CAAA,KAErC,MAAM7B,EAAcN,EAAQoC,WAC5B,IAAI5B,EAEJ,SAAmB6B,EAA+C,IAChE,MAAMhC,QACJA,EAAOiC,QACPA,EAAOC,aACPA,EAAYnB,KACZA,EAAOlB,EAAiBmB,QACtBgB,EAEJ,IACE,GAAKhC,GAAYiC,QAA4BlD,IAAjBmD,EAErB,IAAIlC,IAAYiC,QAA4BlD,IAAjBmD,EAChC,OAAO,IAAIjC,EAAYD,EAAQ5B,SAAU2C,GACpC,GAAIf,GAAWiC,QAA4BlD,IAAjBmD,EAC/B,OAAO,IAAIjC,EAAYD,EAAQ5B,SAAU6D,EAAQ7D,SAAU2C,GACtD,GAAIf,GAAWiC,QAA4BlD,IAAjBmD,EAC/B,OAAO,IAAIjC,EACTD,EAAQ5B,SACR6D,EAAQ7D,SACR8D,EACAnB,GAGF,MAAM,IAAIzU,MHrFlB,oFGsFM,CAdE,OAAO,IAAI2T,EAAYc,EAe3B,CAAE,MAAO/P,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,CA9BgBkL,CAAU4F,GAsC1B,MAAMzB,EAAmB,CASvB,YAAIjC,GACF,OAAO+B,CACT,EAUA,YAAAG,CAAalC,GACXiC,EAAKnB,SACLiB,EAAY/B,EACZmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EAYA,OAAAoD,CAAQnC,EAAkBoC,GACxB,IACE,OAAOjC,EAAUgC,QAAQnC,EAAQ5B,SAAUgE,EAC7C,CAAE,MAAOpR,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAeA,MAAAqR,CAAOC,GACL,IACE,OAAOnC,EAAUkC,OAAOC,EAC1B,CAAE,MAAOtR,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAUA,OAAAuR,GACEpC,EAAUoC,SACZ,EAWA,oBAAIC,GACF,OAAOrC,EAAUqC,kBACnB,EAWA,qBAAIC,GACF,OAAOtC,EAAUsC,mBACnB,EASA,QAAIH,GACF,OAAOnC,EAAUmC,MACnB,EAWA,gBAAIJ,GACF,OAAO/B,EAAU+B,cACnB,EAaA,iBAAIQ,GACF,OAAOvC,EAAUuC,eACnB,EASA,aAAIC,GACF,OAAOxC,EAAUwC,WACnB,EAUA,WAAIV,GACF,MAAMW,EAAQf,IAEd,OADAe,EAAMC,OAAO1C,EAAU8B,WAChBW,CACT,EAWA,SAAIE,GACF,OAAO3C,EAAU2C,OACnB,EAWA,QAAAC,CAASD,GACP3C,EAAU4C,SAASD,EACrB,EASA,QAAI/B,GACF,OAAOZ,EAAUY,MACnB,EAUAiC,KAAI,CAACC,EAA6BrB,EAAcsB,OACvC/C,EAAUgD,aAAaF,GAWhC,SAAAG,CAAUH,EAA6BrB,EAAcsB,MACnD,MAAMjC,EAAWlB,IACX3B,EAAW+B,EAAUkD,YAAYJ,GACvChC,EAASX,aAAalC,GACtB6C,EAASE,QAAQ,cACjB,MAAMC,EAAUH,EAASI,UAEzB,OADAJ,EAAS/B,SACFkC,CACT,EAUA,IAAAkC,CAAKtD,EAAkBuD,GACrB,IACEpD,EAAUqD,eAAexD,EAAQ5B,SAAUmF,EAC7C,CAAE,MAAOvS,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAUA,SAAAyS,CAAUzD,EAAkBS,GAC1B,IACEN,EAAUuD,cAAc1D,EAAQ5B,SAAUqC,EAC5C,CAAE,MAAOzP,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAeA,IAAA2S,CAAKC,GACH,IACEzD,EAAUwD,KAAKC,EAAOxF,SACxB,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAcA,KAAAoC,GACE,IACE,MAAMyQ,EAAiB1D,EAAU/M,QAC3BwQ,EAASjC,EAAsBhC,EAAtBgC,CAA+B,CAC5C/B,YACAgC,gBACAC,cACAhC,mBACAE,UALa4B,GAQf,OADAiC,EAAOtD,aAAauD,GACbD,CACT,CAAE,MAAO5S,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAgBA,IAAA8S,CAAKF,GACH,IACEzD,EAAU2D,KAAKF,EAAOxF,UAItBwF,EAAO1E,QACT,CAAE,MAAOlO,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,GAGIuP,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAGF0D,EAAiB,EAC5BrE,aAEA,MAAMC,EAAmBD,EAAOC,QAChC,OAAOgC,EAAsBhC,EAAQ,EC1Q1BqE,EAAkB,EAC7BtE,YArKA,CAACC,GACD,EACEC,YACAC,mBACAC,YACAC,YAEDC,IACC,MAAMC,EAAcN,EAAQsE,YAC5B,IAAI9D,EACJ,IACEA,EAAY,IAAIF,EAAYD,EAAQ5B,SACtC,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CAQA,MAAMqP,EAAoB,CASxB,YAAIjC,GACF,OAAO+B,CACT,EAUA,YAAAG,CAAalC,GACXiC,EAAKnB,SACLiB,EAAY/B,EACZmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EAuBA,MAAAyB,CACEC,EACAqC,EACApC,EACAK,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAIP,EAAMlR,cAAgBjB,aAAc,CACtC,GAAIoS,EAEF,YADAP,EAAUK,OAAOC,EAAOqC,EAAOpC,EAAUtC,SAAU2C,GAGrD,MAAMJ,EAAQb,IAEd,OADAK,EAAUK,OAAOC,EAAOqC,EAAOnC,EAAMvC,SAAU2C,GACxCJ,CACT,CACE,MAAM,IAAIrU,MJjJpB,gEImJM,CAAE,MAAO0E,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAsBA,MAAAsG,CACEoJ,EACAK,EAAyBlB,EAAiBmB,QAE1C,IACE,MAAMC,EAAWlB,IACX3B,EAAW+B,EAAU+D,aAAaxD,EAAUtC,SAAU2C,GAC5DE,EAASX,aAAalC,GACtB6C,EAASE,QAAQ,gBACjB,MAAMC,EAAUH,EAASI,UAEzB,OADAJ,EAAS/B,SACFkC,CACT,CAAE,MAAOpQ,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EASA,aAAIyQ,GACF,OAAOtB,EAAUsB,WACnB,GAGIlB,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAON8D,CADkBzE,EAAOC,SC5FrByE,EAAmB,EAC9B1E,YAxFA,CAACC,GACD,EACEC,YACAyE,gBACAtE,YAEF,KAEE,MAAMuE,EAAe3E,EAAQ4E,aAAaC,YACpCC,EAAc9E,EAAQ4E,aAAaG,WACnCC,EAAmBhF,EAAQ4E,aAAaK,gBAS9C,MAAO,CAULJ,YAAW,CACT/B,EACAoC,EAA+BR,EAAcS,QAEtCR,EAAa7B,EAAmBoC,GAYzC,UAAAH,CACEjC,EACAoC,EAA+BR,EAAcS,OAE7C,IACE,MAAMC,EAAgBhF,IAChB3B,EAAWqG,EAAYhC,EAAmBoC,GAGhD,OAFAE,EAAczE,aAAalC,GAC3B2G,EAAc5D,QAAQ,WACf4D,CACT,CAAE,MAAO/T,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAYA,MAAAgU,CAAOvC,EAA2BwC,GAChC,IACE,GAAIA,EAAS1V,cAAgBpB,WAC3B,MAAM,IAAI7B,ML3GpB,+DK6GQ,MAAMyY,EAAgBhF,IAChB3B,EAAWuG,EAAiBlC,EAAmBwC,GAGrD,OAFAF,EAAczE,aAAalC,GAC3B2G,EAAc5D,QAAQ,WACf4D,CACT,CAAE,MAAO/T,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EACD,EAOIkU,CADkBxF,EAAOC,SClDrBwF,EAAoB,EAC/BzF,YA7DA,CAACC,GACD,IACA,KAEE,MAAMyF,EAAQzF,EAAQiC,cAAcyD,KAC9BC,EAAQ3F,EAAQiC,cAAc2D,KAC9BC,EAAQ7F,EAAQiC,cAAcsB,KASpC,MAAO,CAQL,QAAImC,GAIF,OAAOD,CACT,EASA,QAAIG,GAIF,OAAOD,CACT,EASA,QAAIpC,GAIF,OAAOsC,CACT,EACD,EAOIC,CADkB/F,EAAOC,SCuLrB+F,EAAc,EAAGhG,YAzN5B,CAACC,GACD,EACEkC,cACA8D,cACAtB,mBAEF,CACEuB,EACAC,GAAiB,EACjBhB,EAAgBR,EAAcS,SAK9B,IAAI3E,EAAY,IAAIF,EAFAN,EAAQmG,aAG1BF,EAAiBxH,SACjByH,EACAhB,GAUF,MAAMxE,EAAgB,CASpB,YAAIjC,GACF,OAAO+B,CACT,EAUA,YAAAG,CAAalC,GACXiC,EAAKnB,SACLiB,EAAY/B,EACZmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EAUAgH,QAAO,IACE5F,EAAU4F,UAanB,cAAAC,CAAe/D,GACb,MAAM7D,EAAW+B,EAAU6F,eAAe/D,EAAQ7D,UAC5C6H,EAAcN,IAEpB,OADAM,EAAY3F,aAAalC,GAClB6H,CACT,EASA,kBAAIC,GACF,MAAM9H,EAAW+B,EAAU+F,iBACrBD,EAAcN,IAEpB,OADAM,EAAY3F,aAAalC,GAClB6H,CACT,EASA,oBAAIE,GACF,MAAM/H,EAAW+B,EAAUgG,mBACrBF,EAAcN,IAEpB,OADAM,EAAY3F,aAAalC,GAClB6H,CACT,EASA,mBAAIG,GACF,MAAMhI,EAAW+B,EAAUiG,kBACrBH,EAAcN,IAEpB,OADAM,EAAY3F,aAAalC,GAClB6H,CACT,EAUAI,cAAa,IACJlG,EAAUkG,gBAUnB,cAAIC,GACF,MAAMlI,EAAW+B,EAAUmG,aACrBrE,EAAUJ,IAEhB,OADAI,EAAQY,OAAOzE,GACR6D,CACT,EASA,gBAAIsE,GACF,MAAMnI,EAAW+B,EAAUoG,eACrBtE,EAAUJ,IAEhB,OADAI,EAAQY,OAAOzE,GACR6D,CACT,EASA,eAAIuE,GACF,MAAMpI,EAAW+B,EAAUqG,cACrBvE,EAAUJ,IAEhB,OADAI,EAAQY,OAAOzE,GACR6D,CACT,EAaA,qBAAIwE,GACF,OAAOtG,EAAUsG,mBACnB,GAGIlG,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAKNqG,CADkBhH,EAAOC,SC1N5BgH,EACHhH,GACD,EACEC,YACAgH,uBACA/E,cACAgF,mCAEF,KACE,IAAI1G,EAQJ,MAAME,EAAoB,CASxB,YAAIjC,GACF,OAAO+B,CACT,EAUA,YAAAG,CAAalC,GACXiC,EAAKnB,SACLiB,EAAY/B,EACZmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EASA,SAAI6D,GACF,MAAMxE,EAAW+B,EAAUyC,QACrBkE,EAAuBF,IAE7B,OADAE,EAAqBxG,aAAalC,GAC3B0I,CACT,EASA,WAAI7E,GACF,MAAMW,EAAQf,IAEd,OADAe,EAAMC,OAAO1C,EAAU8B,WAChBW,CACT,EAYA,cAAImE,GACF,MAAMC,EAAoBH,IAE1B,OADAG,EAAkB1G,aAAaH,EAAU4G,cAClCC,CACT,EASA,6BAAIC,GACF,OAAO9G,EAAU8G,2BACnB,EAWA,mBAAIC,GACF,MAAMC,EAAUR,IAAgC,CAC9C/G,YACAgH,uBACA/E,cACAgF,iCAJcF,GAOhB,OADAQ,EAAQ7G,aAAaH,EAAU+G,mBACxBC,CACT,EAWA,mBAAIC,GACF,MAAMD,EAAUR,IAAgC,CAC9C/G,YACAgH,uBACA/E,cACAgF,iCAJcF,GAOhB,OADAQ,EAAQ7G,aAAaH,EAAUiH,mBACxBD,CACT,EAUA,cAAIE,GACF,OAAOlH,EAAUkH,YACnB,GAGI9G,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAGFiH,EAAkB,EAC7B5H,aAEyBA,EAAOC,QACzBgH,KChEIY,EAAgB,EAC3B7H,YA5HA,CAACC,GACD,EACEC,YACAE,eAEF,CAACE,EAASwH,KACR,MAAMvH,EAAcN,EAAQ8H,UAC5B,IAAItH,EACJ,IACEA,EAAY,IAAIF,EAAYD,EAAQ5B,SAAUoJ,EAAUpJ,SAC1D,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CAQA,MAAMqP,EAAkB,CAStB,YAAIjC,GACF,OAAO+B,CACT,EAUA,YAAAG,CAAalC,GACXiC,EAAKnB,SACLiB,EAAY/B,EACZmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EAYA,OAAA2I,CAAQC,EAAwBjH,GAC9B,IACE,GAAIA,EAEF,YADAP,EAAUuH,QAAQC,EAAWvJ,SAAUsC,EAAUtC,UAGnD,MAAMuC,EAAQb,IAEd,OADAK,EAAUuH,QAAQC,EAAWvJ,SAAUuC,EAAMvC,UACtCuC,CACT,CAAE,MAAO3P,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAwBA,oBAAA4W,CAAqBD,GACnB,IACE,OAAOxH,EAAUyH,qBAAqBD,EAAWvJ,SACnD,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,GAEIuP,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAONwH,CADkBnI,EAAOC,SCgCrBmI,EACX,IAxKA,IACA,KACE,IAAI3H,EAQJ,MAAME,EAAsC,CAS1C,YAAIjC,GACF,OAAO+B,CACT,EAUA,YAAAG,CAAalC,GACXiC,EAAKnB,SACLiB,EAAY/B,EACZmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EAUAsH,cAAa,IACJlG,EAAUkG,gBAgBnB,YAAI0B,GACF,OAAO5H,EAAU4H,QACnB,EAgBA,YAAIC,GACF,OAAO7H,EAAU6H,QACnB,EAiBA,iBAAIC,GACF,OAAO9H,EAAU8H,aACnB,EAcA,sBAAIC,GACF,OAAO/H,EAAU+H,kBACnB,EAWA,+BAAIC,GACF,OAAOhI,EAAUgI,2BACnB,EAUA,iBAAItD,GACF,OAAO1E,EAAU0E,aACnB,GAGItE,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,ECqHF+H,EAA2B,EACtC1I,YAlQA,CAACC,GACD,EACEC,YACAgC,gBACAyG,UACAC,aACAzG,cACA9B,YAEF,CAACwI,EAAyBD,EAAWjD,QAEnC,IAAIlF,EAAY,IAAIF,EADAN,EAAQiH,sBACI2B,GAShC,MAAMlI,EAA6B,CASjC,YAAIjC,GACF,OAAO+B,CACT,EAUA,YAAAG,CAAalC,GACXiC,EAAKnB,SACLiB,EAAY/B,EACZmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EAcA,oBAAAyJ,CAAqB/F,GACnB,IACEtC,EAAUqI,qBAAqB/F,EACjC,CAAE,MAAOzR,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAeA,eAAAyX,CAAgBC,GACd,IACEvI,EAAUsI,gBAAgBC,EAAatK,SACzC,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAeA,eAAA2X,CAAgBC,GACd,IACEzI,EAAUwI,gBAAgBC,EAAaxK,SACzC,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EASA,UAAI6X,GACF,OAAO1I,EAAU0I,QACnB,EASA,qBAAIpG,GACF,OAAOtC,EAAUsC,mBACnB,EASA,gBAAIiG,GACF,MAAMzH,EAAWlB,IACX3B,EAAW+B,EAAUuI,eAC3BzH,EAASX,aAAalC,GACtB6C,EAASE,QAAQ,WACjB,MAAMC,EAAUH,EAASI,UAEzB,OADAJ,EAAS/B,SACFkC,CACT,EASA,gBAAIwH,GACF,MAAMxK,EAAW+B,EAAUyI,eACrBE,EAAeT,EAAQ9N,OAAO,IAEpC,OADAuO,EAAajG,OAAOzE,GACb0K,CACT,EASA,WAAI7G,GACF,MAAMW,EAAQf,IAEd,OADAe,EAAMC,OAAO1C,EAAU8B,WAChBW,CACT,EAUAI,KAAI,CAACC,EAA6BrB,EAAcsB,OACvC/C,EAAUgD,aAAaF,GAWhC,SAAAG,CAAUH,EAA6BrB,EAAcsB,MACnD,MAAMjC,EAAWlB,IACX3B,EAAW+B,EAAUkD,YAAYJ,GACvChC,EAASX,aAAalC,GACtB6C,EAASE,QAAQ,cACjB,MAAMC,EAAUH,EAASI,UAEzB,OADAJ,EAAS/B,SACFkC,CACT,EASA,IAAAkC,CAAKC,GACH,IACEpD,EAAUqD,eAAeD,EAC3B,CAAE,MAAOvS,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EASA,SAAAyS,CAAUhD,GACR,IACEN,EAAUuD,cAAcjD,EAC1B,CAAE,MAAOzP,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,GAEIuP,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAON0I,CADkBrJ,EAAOC,SCmCrBqJ,EAAgB,EAC3BtJ,YA9RA,CAACC,GACD,EACEC,YACAC,mBACAoJ,aACAC,kBAEF,CAAClJ,EAASmJ,EAAW3B,KACnB,MAAMvH,EAAcN,EAAQyJ,UAC5B,IAAIjJ,EAEJ,SACEH,EACAmJ,EACA3B,GAEA,IACE,OAAIA,EACK,IAAIvH,EACTD,EAAQ5B,SACR+K,EAAU/K,SACVoJ,EAAUpJ,UAGP,IAAI6B,EAAYD,EAAQ5B,SAAU+K,EAAU/K,SACrD,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,CAnBgBqY,CAAkBrJ,EAASmJ,EAAW3B,GA2BtD,MAAMnH,EAAkB,CAStB,YAAIjC,GACF,OAAO+B,CACT,EAUA,YAAAG,CAAalC,GACXiC,EAAKnB,SACLiB,EAAY/B,EACZmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EAeA,OAAAuK,CACE5I,EACAiH,EACA5G,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAI2G,EAEF,YADAxH,EAAUmJ,QAAQ5I,EAAUtC,SAAUuJ,EAAWvJ,SAAU2C,GAG7D,MAAM6C,EAASqF,IAEf,OADA9I,EAAUmJ,QAAQ5I,EAAUtC,SAAUwF,EAAOxF,SAAU2C,GAChD6C,CACT,CAAE,MAAO5S,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAaA,mBAAAuY,CACE7I,EACAK,EAAyBlB,EAAiBmB,QAE1C,IACE,MAAMwI,EAAON,IACP9K,EAAW+B,EAAUoJ,oBACzB7I,EAAUtC,SACV2C,GAGF,OADAyI,EAAKlJ,aAAalC,GACXoL,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAqBA,gBAAAyY,CACE/I,EACAiH,EACA5G,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAI2G,EAMF,YALAxH,EAAUsJ,iBACR/I,EAAUtC,SACVuJ,EAAWvJ,SACX2C,GAIJ,MAAM6C,EAASqF,IAEf,OADA9I,EAAUsJ,iBAAiB/I,EAAUtC,SAAUwF,EAAOxF,SAAU2C,GACzD6C,CACT,CAAE,MAAO5S,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAwBA,4BAAA0Y,CACEhJ,EACAK,EAAyBlB,EAAiBmB,QAE1C,IACE,MAAM2I,EAAaT,IACb9K,EAAW+B,EAAUuJ,6BACzBhJ,EAAUtC,SACV2C,GAGF,OADA4I,EAAWrJ,aAAalC,GACjBuL,CACT,CAAE,MAAO3Y,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAkBA,WAAA4Y,CACEjC,EACA5G,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAI2G,EAEF,YADAxH,EAAUyJ,YAAYjC,EAAWvJ,SAAU2C,GAG7C,MAAM6C,EAASqF,IAEf,OADA9I,EAAUyJ,YAAYhG,EAAOxF,SAAU2C,GAChC6C,CACT,CAAE,MAAO5S,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAgBA,uBAAA6Y,CACE9I,EAAyBlB,EAAiBmB,QAE1C,IACE,MAAM2I,EAAaT,IACb9K,EAAW+B,EAAU0J,wBAAwB9I,GAEnD,OADA4I,EAAWrJ,aAAalC,GACjBuL,CACT,CAAE,MAAO3Y,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,GAGIuP,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAONyJ,CADkBpK,EAAOC,SCw2CrBoK,EAAgB,EAC3BrK,YAt/CA,CAACC,GACD,EACEC,YACAC,mBACAoJ,aACAnJ,eAEDE,IACC,MAAMC,EAAcN,EAAQqK,UAC5B,IAAI7J,EACJ,IACEA,EAAY,IAAIF,EAAYD,EAAQ5B,SACtC,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CAQA,MAAMqP,EAAkB,CAStB,YAAIjC,GACF,OAAO+B,CACT,EAUA,YAAAG,CAAalC,GACXiC,EAAKnB,SACLiB,EAAY/B,EACZmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EAkBA,MAAAkL,CACEC,EACAC,GAEA,IACE,GAAIA,EAEF,YADAhK,EAAU8J,OAAOC,EAAU9L,SAAU+L,EAAY/L,UAGnD,MAAMoL,EAAOP,IAEb,OADA9I,EAAU8J,OAAOC,EAAU9L,SAAUoL,EAAKpL,UACnCoL,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAqBA,GAAAoZ,CACEze,EACAD,EACAye,GAEA,IACE,GAAIA,EAEF,YADAhK,EAAUiK,IAAIze,EAAEyS,SAAU1S,EAAE0S,SAAU+L,EAAY/L,UAGpD,MAAMoL,EAAOP,IAEb,OADA9I,EAAUiK,IAAIze,EAAEyS,SAAU1S,EAAE0S,SAAUoL,EAAKpL,UACpCoL,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAqBA,GAAAqZ,CACE1e,EACAD,EACAye,GAEA,IACE,GAAIA,EAEF,YADAhK,EAAUkK,IAAI1e,EAAEyS,SAAU1S,EAAE0S,SAAU+L,EAAY/L,UAGpD,MAAMoL,EAAOP,IAEb,OADA9I,EAAUkK,IAAI1e,EAAEyS,SAAU1S,EAAE0S,SAAUoL,EAAKpL,UACpCoL,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAwBA,QAAAsZ,CACE3e,EACAD,EACAye,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAOF,YANAhK,EAAUmK,SACR3e,EAAEyS,SACF1S,EAAE0S,SACF+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAEb,OADA9I,EAAUmK,SAAS3e,EAAEyS,SAAU1S,EAAE0S,SAAUoL,EAAKpL,SAAU2C,GACnDyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAsBA,MAAAuZ,CACEL,EACAC,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAEF,YADAhK,EAAUoK,OAAOL,EAAU9L,SAAU+L,EAAY/L,SAAU2C,GAG7D,MAAMyI,EAAOP,IAEb,OADA9I,EAAUoK,OAAOL,EAAU9L,SAAUoL,EAAKpL,SAAU2C,GAC7CyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAyBA,WAAAwZ,CACEN,EACAO,EACAN,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAOF,YANAhK,EAAUqK,YACRN,EAAU9L,SACVqM,EAAUrM,SACV+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAOb,OANA9I,EAAUqK,YACRN,EAAU9L,SACVqM,EAAUrM,SACVoL,EAAKpL,SACL2C,GAEKyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAsBA,qBAAA0Z,CACER,EACAC,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAMF,YALAhK,EAAUuK,sBACRR,EAAU9L,SACV+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAMb,OALA9I,EAAUuK,sBACRR,EAAU9L,SACVoL,EAAKpL,SACL2C,GAEKyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAyBA,iBAAA2Z,CACET,EACAjI,EACAkI,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAOF,YANAhK,EAAUwK,kBACRT,EAAU9L,SACV6D,EAAQ7D,SACR+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAOb,OANA9I,EAAUwK,kBACRT,EAAU9L,SACV6D,EAAQ7D,SACRoL,EAAKpL,SACL2C,GAEKyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAmBA,oBAAA4Z,CACEjK,EACAwJ,GAEA,IACE,GAAIA,EAEF,YADAhK,EAAUyK,qBAAqBjK,EAAMvC,SAAU+L,EAAY/L,UAG7D,MAAMoL,EAAO1J,IAEb,OADAK,EAAUyK,qBAAqBjK,EAAMvC,SAAUoL,EAAKpL,UAC7CoL,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAuBA,gBAAA6Z,CACElK,EACAsB,EACAkI,GAEA,IACE,GAAIA,EAMF,YALAhK,EAAU0K,iBACRlK,EAAMvC,SACN6D,EAAQ7D,SACR+L,EAAY/L,UAIhB,MAAMoL,EAAO1J,IAMb,OALAK,EAAU0K,iBACRlK,EAAMvC,SACN6D,EAAQ7D,SACRoL,EAAKpL,UAEAoL,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAuBA,aAAA8Z,CACEZ,EACAC,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAMF,YALAhK,EAAU2K,cACRZ,EAAU9L,SACV+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAEb,OADA9I,EAAU2K,cAAcZ,EAAU9L,SAAUoL,EAAKpL,SAAU2C,GACpDyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EA0BA,SAAA+Z,CACEb,EACAjI,EACAkI,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAOF,YANAhK,EAAU4K,UACRb,EAAU9L,SACV6D,EAAQ7D,SACR+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAOb,OANA9I,EAAU4K,UACRb,EAAU9L,SACV6D,EAAQ7D,SACRoL,EAAKpL,SACL2C,GAEKyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EA0BA,eAAAga,CACEd,EACAC,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAMF,YALAhK,EAAU6K,gBACRd,EAAU9L,SACV+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAEb,OADA9I,EAAU6K,gBAAgBd,EAAU9L,SAAUoL,EAAKpL,SAAU2C,GACtDyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EA6BA,WAAAia,CACEf,EACAjI,EACAkI,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAOF,YANAhK,EAAU8K,YACRf,EAAU9L,SACV6D,EAAQ7D,SACR+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAOb,OANA9I,EAAU8K,YACRf,EAAU9L,SACV6D,EAAQ7D,SACRoL,EAAKpL,SACL2C,GAEKyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EA2BA,YAAAka,CACEhB,EACAiB,EACAV,EACAN,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAQF,YAPAhK,EAAU+K,aACRhB,EAAU9L,SACV+M,EACAV,EAAUrM,SACV+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAQb,OAPA9I,EAAU+K,aACRhB,EAAU9L,SACV+M,EACAV,EAAUrM,SACVoL,EAAKpL,SACL2C,GAEKyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAuBA,QAAAoa,CACElB,EACAvJ,EACAwJ,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAOF,YANAhK,EAAUiL,SACRlB,EAAU9L,SACVuC,EAAMvC,SACN+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAOb,OANA9I,EAAUiL,SACRlB,EAAU9L,SACVuC,EAAMvC,SACNoL,EAAKpL,SACL2C,GAEKyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAuBA,QAAAqa,CACEnB,EACAvJ,EACAwJ,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAOF,YANAhK,EAAUkL,SACRnB,EAAU9L,SACVuC,EAAMvC,SACN+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAOb,OANA9I,EAAUkL,SACRnB,EAAU9L,SACVuC,EAAMvC,SACNoL,EAAKpL,SACL2C,GAEKyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAyBA,aAAAsa,CACEpB,EACAvJ,EACAwJ,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAOF,YANAhK,EAAUmL,cACRpB,EAAU9L,SACVuC,EAAMvC,SACN+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAOb,OANA9I,EAAUmL,cACRpB,EAAU9L,SACVuC,EAAMvC,SACNoL,EAAKpL,SACL2C,GAEKyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAgCA,mBAAAua,CACE5K,EACAsB,EACAuJ,EACAzK,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAIwK,EAOF,YANArL,EAAUoL,oBACR5K,EAAMvC,SACN6D,EAAQ7D,SACRoN,EAAepN,SACf2C,GAIJ,MAAMyI,EAAO1J,IAOb,OANAK,EAAUoL,oBACR5K,EAAMvC,SACN6D,EAAQ7D,SACRoL,EAAKpL,SACL2C,GAEKyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAoBA,oBAAAya,CACEvB,EACAsB,GAEA,IACE,GAAIA,EAKF,YAJArL,EAAUsL,qBACRvB,EAAU9L,SACVoN,EAAepN,UAInB,MAAMoL,EAAOP,IAEb,OADA9I,EAAUsL,qBAAqBvB,EAAU9L,SAAUoL,EAAKpL,UACjDoL,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAmBA,sBAAA0a,CACEC,EACAxB,GAEA,IACE,GAAIA,EAKF,YAJAhK,EAAUuL,uBACRC,EAAavN,SACb+L,EAAY/L,UAIhB,MAAMoL,EAAOP,IAEb,OADA9I,EAAUuL,uBAAuBC,EAAavN,SAAUoL,EAAKpL,UACtDoL,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAoCA,WAAA4a,CACE1B,EACA2B,EACAC,EACA3B,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAQF,YAPAhK,EAAUyL,YACR1B,EAAU9L,SACVyN,EACAC,EAAW1N,SACX+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAQb,OAPA9I,EAAUyL,YACR1B,EAAU9L,SACVyN,EACAC,EAAW1N,SACXoL,EAAKpL,SACL2C,GAEKyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EA6BA,UAAA+a,CACE7B,EACA8B,EACAF,EACA3B,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAQF,YAPAhK,EAAU4L,WACR7B,EAAU9L,SACV4N,EACAF,EAAW1N,SACX+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAQb,OAPA9I,EAAU4L,WACR7B,EAAU9L,SACV4N,EACAF,EAAW1N,SACXoL,EAAKpL,SACL2C,GAEKyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EA2BA,aAAAib,CACE/B,EACA4B,EACA3B,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAOF,YANAhK,EAAU8L,cACR/B,EAAU9L,SACV0N,EAAW1N,SACX+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAOb,OANA9I,EAAU8L,cACR/B,EAAU9L,SACV0N,EAAW1N,SACXoL,EAAKpL,SACL2C,GAEKyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EA4BA,YAAAkb,CACEhC,EACA8B,EACAF,EACA3B,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAQF,YAPAhK,EAAU+L,aACRhC,EAAU9L,SACV4N,EACAF,EAAW1N,SACX+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAQb,OAPA9I,EAAU+L,aACRhC,EAAU9L,SACV4N,EACAF,EAAW1N,SACXoL,EAAKpL,SACL2C,GAEKyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAyBA,gBAAAmb,CACEjC,EACA4B,EACA3B,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAOF,YANAhK,EAAUgM,iBACRjC,EAAU9L,SACV0N,EAAW1N,SACX+L,EAAY/L,SACZ2C,GAIJ,MAAMyI,EAAOP,IAOb,OANA9I,EAAUgM,iBACRjC,EAAU9L,SACV0N,EAAW1N,SACXoL,EAAKpL,SACL2C,GAEKyI,CACT,CAAE,MAAOxY,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAsBA,WAAAob,CACElC,EACA4B,EACAjD,EACAsB,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAQF,YAPAhK,EAAUiM,YACRlC,EAAU9L,SACV0N,EAAW1N,SACXyK,EACAsB,EAAY/L,SACZ2C,GAKJ,MAAMsL,EAAUpD,IAQhB,OAPA9I,EAAUiM,YACRlC,EAAU9L,SACV0N,EAAW1N,SACXyK,EACAwD,EAAQjO,SACR2C,GAEKsL,CACT,CAAE,MAAOrb,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EA2BA,UAAAsb,CACE3gB,EACAD,EACA+e,EACAqB,EACAjD,EACAsB,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAoBF,OAnBAhK,EAAUmK,SACR3e,EAAEyS,SACF1S,EAAE0S,SACF+L,EAAY/L,SACZ2C,GAEFZ,EAAUqK,YACRL,EAAY/L,SACZqM,EAAUrM,SACV+L,EAAY/L,SACZ2C,QAEFZ,EAAUiM,YACRjC,EAAY/L,SACZ0N,EAAW1N,SACXyK,EACAsB,EAAY/L,SACZ2C,GAKJ,MAAMsL,EAAUpD,IAehB,OAdA9I,EAAUmK,SAAS3e,EAAEyS,SAAU1S,EAAE0S,SAAUiO,EAAQjO,SAAU2C,GAC7DZ,EAAUqK,YACR6B,EAAQjO,SACRqM,EAAUrM,SACViO,EAAQjO,SACR2C,GAEFZ,EAAUiM,YACRC,EAAQjO,SACR0N,EAAW1N,SACXyK,EACAwD,EAAQjO,SACR2C,GAEKsL,CACT,CAAE,MAAOrb,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAyBA,eAAAub,CACE5gB,EACAD,EACAogB,EACAjD,EACAsB,EACApJ,EAAyBlB,EAAiBmB,QAE1C,IACE,GAAImJ,EAcF,OAbAhK,EAAUmL,cACR3f,EAAEyS,SACF1S,EAAE0S,SACF+L,EAAY/L,SACZ2C,QAEFZ,EAAUiM,YACRjC,EAAY/L,SACZ0N,EAAW1N,SACXyK,EACAsB,EAAY/L,SACZ2C,GAKJ,MAAMsL,EAAUpD,IAchB,OAbA9I,EAAUmL,cACR3f,EAAEyS,SACF1S,EAAE0S,SACFiO,EAAQjO,SACR2C,GAEFZ,EAAUiM,YACRC,EAAQjO,SACR0N,EAAW1N,SACXyK,EACAwD,EAAQjO,SACR2C,GAEKsL,CACT,CAAE,MAAOrb,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,GAGIuP,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAONmM,CADkB9M,EAAOC,SCppDrB8M,EAAgB,EAC3B/M,YApCA,CAACC,GACD,IACA,KAEE,MAAM+M,EAAgB/M,EAAQgN,aAS9B,MAAO,CASLvM,KAAK1S,GACkB,iBAAVA,EACF,IAAIpB,MAAMogB,EAAchf,IAG7BA,aAAiBpB,MACZoB,EAEF,IAAIpB,MAAMoB,GAAS,kBAE7B,EAOIkf,CADkBlN,EAAOC,SCd5BkN,EACHlN,GACD,EACEC,YACAgC,gBACA7B,YAEF,KACE,MAAME,EAAcN,EAAQmN,WAC5B,IAAI3M,EAAY,IAAIF,EASpB,MAAMI,EAAmB,CASvB,YAAIjC,GACF,OAAO+B,CACT,EAUA,MAAA0C,CAAOzE,GACLiC,EAAKnB,SACLiB,EAAY,IAAIF,EAAY7B,GAC5BmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EAUA,QAAIuD,GACF,OAAOnC,EAAUmC,MACnB,EAYA,QAAAyK,CAASlB,GACP,IACE,OAAO1L,EAAU4M,SAASlB,EAC5B,CAAE,MAAO7a,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAUA,MAAAgc,CAAOnB,GACL,IACE,OAAO1L,EAAU6M,OAAOnB,EAC1B,CAAE,MAAO7a,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EASA,IAAAgS,CAAKC,EAA6BrB,EAAcsB,MAC9C,IACE,OAAO/C,EAAUgD,aAAaF,EAChC,CAAE,MAAOjS,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAUA,SAAAoS,CAAUH,EAA6BrB,EAAcsB,MACnD,MAAMjC,EAAWlB,IACX3B,EAAW+B,EAAUkD,YAAYJ,GACvChC,EAASX,aAAalC,GACtB6C,EAASE,QAAQ,cACjB,MAAMC,EAAUH,EAASI,UAEzB,OADAJ,EAAS/B,SACFkC,CACT,EAUA,IAAAkC,CAAKtD,EAAkBuD,GACrB,IACEpD,EAAUqD,eAAexD,EAAQ5B,SAAUmF,EAC7C,CAAE,MAAOvS,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAUA,SAAAyS,CAAUzD,EAAkBS,GAC1B,IACEN,EAAUuD,cAAc1D,EAAQ5B,SAAUqC,EAC5C,CAAE,MAAOzP,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAcA,IAAA2S,CAAKsJ,GACH,IACE9M,EAAUwD,KAAKsJ,EAAI7O,SACrB,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAaA,KAAAoC,GACE,IACE,MAAMyQ,EAAiB1D,EAAU/M,QAC3B6Z,EAAMJ,EAAsBlN,EAAtBkN,CAA+B,CACzCjN,YACAgC,gBACA7B,UAHU8M,GAMZ,OADAI,EAAIpK,OAAOgB,GACJoJ,CACT,CAAE,MAAOjc,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAeA,IAAA8S,CAAKmJ,GACH,IACE9M,EAAU2D,KAAKmJ,EAAI7O,UAInB6O,EAAI/N,QACN,CAAE,MAAOlO,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,GAGIuP,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAGF6M,EAAiB,EAC5BxN,aAEA,MAAMC,EAAmBD,EAAOC,QAChC,OAAOkN,EAAsBlN,EAAQ,EChB1BwN,EAAmB,EAC9BzN,YAxOA,CAACC,GACD,EACEC,YACAwN,YACAC,YACAC,YACAR,aACA5D,kBAEF,CAAClJ,EAASwH,KACR,MAAMvH,EAAcN,EAAQ4N,aAC5B,IAAIpN,EAEJ,SAA2BH,EAAkBwH,GAC3C,IACE,OAAIA,EACK,IAAIvH,EAAYD,EAAQ5B,SAAUoJ,EAAUpJ,UAE9C,IAAI6B,EAAYD,EAAQ5B,SACjC,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,CAXgBqY,CAAkBrJ,EAASwH,GAmB3C,MAAMnH,EAAqB,CASzB,YAAIjC,GACF,OAAO+B,CACT,EAUA,YAAAG,CAAalC,GACXiC,EAAKnB,SACLiB,EAAY/B,EACZmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EASA,SAAAyI,GACE,IACE,MAAMyF,EAAMI,IACNjP,EAAW+B,EAAUqH,YAE3B,OADAyF,EAAIpK,OAAOzE,GACJ6O,CACT,CAAE,MAAOjc,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EASA,eAAAwc,GACE,IACE,MAAMP,EAAMG,IAEZ,OADAjN,EAAUqN,gBAAgBP,EAAI7O,UACvB6O,CACT,CAAE,MAAOjc,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EASA,2BAAAyc,GACE,IACE,MAAM9D,EAAaT,IACb9K,EAAW+B,EAAUsN,8BAE3B,OADA9D,EAAWrJ,aAAalC,GACjBuL,CACT,CAAE,MAAO3Y,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAWA,eAAA0c,GACE,IACE,MAAM3S,EAAOuS,IAEb,OADAnN,EAAUuN,gBAAgB3S,EAAKqD,UACxBrD,CACT,CAAE,MAAO/J,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAeA,2BAAA2c,GACE,IACE,MAAMhE,EAAaT,IACb9K,EAAW+B,EAAUwN,8BAE3B,OADAhE,EAAWrJ,aAAalC,GACjBuL,CACT,CAAE,MAAO3Y,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAgBA,gBAAA4c,CAAiB5B,EAAoB7d,WAAWqT,KAAK,KACnD,IACE,MAAMzG,EAAO+R,IAEb,OADA3M,EAAUyN,iBAAiB5B,EAAOjR,EAAKqD,UAChCrD,CACT,CAAE,MAAO/J,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAoBA,4BAAA6c,CACE7B,EAAoB7d,WAAWqT,KAAK,KAEpC,IACE,MAAMmI,EAAaT,IACb9K,EAAW+B,EAAU0N,6BAA6B7B,GAExD,OADArC,EAAWrJ,aAAalC,GACjBuL,CACT,CAAE,MAAO3Y,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,GAGIuP,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAONyN,CADkBpO,EAAOC,SC7NrBoO,EAAuB,EAClCrO,YA9CA,CAACC,GACD,IACA,KAEE,MAAMqO,EAAUrO,EAAQE,iBAAiBoO,uBACnCC,EAAevO,EAAQE,iBAAiBsO,4BAS9C,MAAO,CAQL,UAAInN,GAIF,OAAOgN,GACT,EASA,eAAII,GAIF,OAAOF,GACT,EACD,EAOIG,CADkB3O,EAAOC,SC+KrB2O,EAAc,EAAG5O,YAvM5B,CAACC,GACD,EACEC,YACAgC,gBACA7B,YAEDlO,IAEC,MAAMoO,EAAcN,EAAQ0I,QAE5B,IAAIlI,EAEJ,SAAuBtO,GACrB,IACE,MAAM0c,EAAO,IAAItO,EAEjB,OADAsO,EAAKC,SAAS3c,EAAMoB,YACbsb,CACT,CAAE,MAAOvd,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,CAVgByd,CAAc5c,GAmB9B,MAAMwO,EAAgB,CASpB,YAAIjC,GACF,OAAO+B,CACT,EAUA,MAAA0C,CAAOzE,GACLiC,EAAKnB,SACLiB,EAAY,IAAIF,EAAY7B,GAC5BmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EASA,QAAAyP,CAAS3c,GACP,IACEsO,EAAUqO,SAAS3c,EAAMoB,WAC3B,CAAE,MAAOjC,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EASA,SAAIa,GAEF,OAAO0I,OAAO4F,EAAUtO,QAC1B,EASA,YAAI6c,GACF,OAAOvO,EAAUuO,UACnB,EASA,UAAIC,GACF,OAAOxO,EAAUwO,QACnB,EASA,WAAIC,GACF,OAAOzO,EAAUyO,SACnB,EAUA5L,KAAI,CAACC,EAA6BrB,EAAcsB,OACvC/C,EAAUgD,aAAaF,GAWhC,SAAAG,CAAUH,EAA6BrB,EAAcsB,MACnD,MAAMjC,EAAWlB,IACX3B,EAAW+B,EAAUkD,YAAYJ,GACvChC,EAASX,aAAalC,GACtB6C,EAASE,QAAQ,cACjB,MAAMC,EAAUH,EAASI,UAEzB,OADAJ,EAAS/B,SACFkC,CACT,EASA,IAAAkC,CAAKC,GACH,IACEpD,EAAUqD,eAAeD,EAC3B,CAAE,MAAOvS,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EASA,SAAAyS,CAAUhD,GACR,IACEN,EAAUuD,cAAcjD,EAC1B,CAAE,MAAOzP,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,GAGIuP,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAKNwO,CADkBnP,EAAOC,SCtIrBmP,EAAkB,EAC7BpP,YAnFA,CAACC,GACD,EACEC,eAEF,KACE,MAAMK,EAAcN,EAAQkC,YAE5B,IAAI1B,EASJ,MAAME,EAAoB,CASxB,YAAIjC,GACF,OAAO+B,CACT,EAUA,MAAA0C,CAAOzE,GACLiC,EAAKnB,SACLiB,EAAY,IAAIF,EAAY7B,GAC5BmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EASA,UAAIvD,GACF,IACE,MAAM4C,EAAW+B,EAAU3E,SAC3B,OAAOhN,eAAegT,KAAKpD,EAC7B,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,GAGIuP,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAON0O,CADkBrP,EAAOC,SCPrBqP,EAAmB,EAC9BtP,YAvEA,CAACC,GACD,EACEC,YACAyI,UACAtI,YAEF,KAEE,MAAMkP,EAAYtP,EAAQuP,aAAaC,SACjCC,EAAkBzP,EAAQuP,aAAaG,eAS7C,MAAO,CAWL,QAAAF,CAAS1M,EAA2B6M,GAClC,IACE,MAAMC,EAAWlH,EAAQ9N,OAAO,IAEhC,OADAgV,EAAS1M,OAAOoM,EAAUxM,EAAmB6M,IACtCC,CACT,CAAE,MAAOve,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAaA,cAAAqe,CACEG,EACAvK,GAEA,IACE,MAAMwK,EAAe1P,IACrB0P,EAAajO,KAAKyD,GAClB,MAAMyK,EAAON,EACXI,EACAC,EAAarR,UAGf,OADAqR,EAAavQ,SACNwQ,CACT,CAAE,MAAO1e,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EACD,EAOI2e,CADkBjQ,EAAOC,SC5C5BiQ,EACHjQ,GACD,EACEC,YACAgC,gBACAC,cACAhC,mBACAE,YAEF,CAAC+B,EAAqC,CAAA,KAEpC,MAAM7B,EAAcN,EAAQkQ,UAE5B,IAAI1P,EAEJ,SAAmB6B,EAA8C,IAC/D,MAAMI,SACJA,EAAQ0N,WACRA,EAAU/O,KACVA,EAAOlB,EAAiBmB,QACtBgB,EAEJ,IACE,QAAiBjD,IAAbqD,QAAyCrD,IAAf+Q,EAC5B,OAAO,IAAI7P,EAAYc,GAClB,QAAiBhC,IAAbqD,QAAyCrD,IAAf+Q,EACnC,OAAO,IAAI7P,EAAY6P,EAAY/O,GAC9B,QAAiBhC,IAAbqD,QAAyCrD,IAAf+Q,EACnC,OAAO,IAAI7P,EAAYmC,EAAU0N,EAAY/O,GAE7C,MAAM,IAAIzU,MrBlFlB,sDqBoFI,CAAE,MAAO0E,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,CAtBgBkL,CAAU4F,GA8B1B,MAAMzB,EAAkB,CAStB,YAAIjC,GACF,OAAO+B,CACT,EAUA,YAAAG,CAAalC,GACXiC,EAAKnB,SACLiB,EAAY/B,EACZmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EAUA,OAAAoD,CAAQC,GACN,IACE,OAAOjC,EAAUgC,QAAQC,EAC3B,CAAE,MAAOpR,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAWA,WAAA+e,GACE5P,EAAU4P,aACZ,EASA,OAAAxN,GACEpC,EAAUoC,SACZ,EAWA,MAAAF,CAAOyN,GACL,IACE3P,EAAUkC,OAAOyN,EACnB,CAAE,MAAO9e,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAQA,OAAAgf,GACE7P,EAAU6P,SACZ,EASA,UAAIrB,GACF,OAAOxO,EAAUwO,QACnB,EASA,YAAIvM,GACF,OAAOjC,EAAUiC,UACnB,EASA,cAAI0N,GACF,OAAO3P,EAAU2P,YACnB,EASA,yBAAIG,GACF,OAAO9P,EAAU8P,uBACnB,EASA,qBAAIC,GACF,OAAO/P,EAAU+P,mBACnB,EAyBA,YAAAC,GACE,IACE,OAAOhQ,EAAUgQ,cACnB,CAAE,MAAOnf,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EASA,aAAI2R,GACF,OAAOxC,EAAUwC,WACnB,EAYA,WAAIV,GACF,MAAMW,EAAQf,IAEd,OADAe,EAAMC,OAAO1C,EAAU8B,WAChBW,CACT,EAWA,SAAIE,GACF,OAAO3C,EAAU2C,OACnB,EAWA,QAAAC,CAASD,GACP3C,EAAU4C,SAASD,EACrB,EASA,QAAI/B,GACF,OAAOZ,EAAUY,MACnB,EAUAiC,KAAI,CAACC,EAA6BrB,EAAcsB,OACvC/C,EAAUgD,aAAaF,GAWhC,SAAAG,CAAUH,EAA6BrB,EAAcsB,MACnD,MAAMjC,EAAWlB,IACX3B,EAAW+B,EAAUkD,YAAYJ,GACvChC,EAASX,aAAalC,GACtB6C,EAASE,QAAQ,cACjB,MAAMC,EAAUH,EAASI,UAEzB,OADAJ,EAAS/B,SACFkC,CACT,EAUA,IAAAkC,CAAKtD,EAAkBuD,GACrB,IACEpD,EAAUqD,eAAexD,EAAQ5B,SAAUmF,EAC7C,CAAE,MAAOvS,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAUA,SAAAyS,CAAUzD,EAAkBS,GAC1B,IACEN,EAAUuD,cAAc1D,EAAQ5B,SAAUqC,EAC5C,CAAE,MAAOzP,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAeA,IAAA2S,CAAKhD,GACH,IACER,EAAUwD,KAAKhD,EAAMvC,SACvB,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAcA,KAAAoC,GACE,IACE,MAAMyQ,EAAiB1D,EAAU/M,QAC3BuN,EAAQiP,EAAqBjQ,EAArBiQ,CAA8B,CAC1ChQ,YACAgC,gBACAC,cACAhC,mBACAE,UALY6P,GAQd,OADAjP,EAAML,aAAauD,GACZlD,CACT,CAAE,MAAO3P,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAgBA,IAAA8S,CAAKnD,GACH,IACER,EAAU2D,KAAKnD,EAAMvC,UAIrBuC,EAAMzB,QACR,CAAE,MAAOlO,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,GAGIuP,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAGF+P,EAAgB,EAC3B1Q,aAEA,MAAMC,EAAmBD,EAAOC,QAChC,OAAOiQ,EAAqBjQ,EAAQ,EC3dhC0Q,EACH1Q,GACD,EACEC,YACAgC,gBACA7B,YAEF,KACE,MAAME,EAAcN,EAAQyN,UAC5B,IAAIjN,EAAY,IAAIF,EASpB,MAAMI,EAAkB,CAStB,YAAIjC,GACF,OAAO+B,CACT,EAUA,MAAA0C,CAAOzE,GACLiC,EAAKnB,SACLiB,EAAY,IAAIF,EAAY7B,GAC5BmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EAUA,IAAAiE,CAAKC,EAA6BrB,EAAcsB,MAC9C,IACE,OAAO/C,EAAUgD,aAAaF,EAChC,CAAE,MAAOjS,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAUA,SAAAoS,CAAUH,EAA6BrB,EAAcsB,MACnD,MAAMjC,EAAWlB,IACX3B,EAAW+B,EAAUkD,YAAYJ,GACvChC,EAASX,aAAalC,GACtB6C,EAASE,QAAQ,cACjB,MAAMC,EAAUH,EAASI,UAEzB,OADAJ,EAAS/B,SACFkC,CACT,EAUA,IAAAkC,CAAKtD,EAAkBuD,GACrB,IACEpD,EAAUqD,eAAexD,EAAQ5B,SAAUmF,EAC7C,CAAE,MAAOvS,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAUA,SAAAyS,CAAUzD,EAAkBS,GAC1B,IACEN,EAAUuD,cAAc1D,EAAQ5B,SAAUqC,EAC5C,CAAE,MAAOzP,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAcA,IAAA2S,CAAKsJ,GACH,IACE9M,EAAUwD,KAAKsJ,EAAI7O,SACrB,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAaA,KAAAoC,GACE,IACE,MAAMyQ,EAAiB1D,EAAU/M,QAC3B6Z,EAAMoD,EAAqB1Q,EAArB0Q,CAA8B,CACxCzQ,YACAgC,gBACA7B,UAHUsQ,GAMZ,OADApD,EAAIpK,OAAOgB,GACJoJ,CACT,CAAE,MAAOjc,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAeA,IAAA8S,CAAKmJ,GACH,IACE9M,EAAU2D,KAAKmJ,EAAI7O,UAInB6O,EAAI/N,QACN,CAAE,MAAOlO,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,GAGIuP,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAGFiQ,EAAgB,EAC3B5Q,aAEA,MAAMC,EAAmBD,EAAOC,QAChC,OAAO0Q,EAAqB1Q,EAAQ,EC9MhC4Q,EACH5Q,GACD,EACEC,YACAgC,gBACA7B,YAEF,KACE,MAAME,EAAcN,EAAQ2N,UAC5B,IAAInN,EAAY,IAAIF,EASpB,MAAMI,EAAkB,CAStB,YAAIjC,GACF,OAAO+B,CACT,EAUA,MAAA0C,CAAOzE,GACLiC,EAAKnB,SACLiB,EAAY,IAAIF,EAAY7B,GAC5BmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EAUA,QAAIuD,GACF,OAAOnC,EAAUmC,MACnB,EAYA,QAAAyK,CAASyD,GACP,IACE,OAAOrQ,EAAU4M,SAASyD,EAC5B,CAAE,MAAOxf,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAWA,MAAAgc,CAAOwD,GACL,IACE,OAAOrQ,EAAU6M,OAAOwD,EAC1B,CAAE,MAAOxf,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAUA,IAAAgS,CAAKC,EAA6BrB,EAAcsB,MAC9C,IACE,OAAO/C,EAAUgD,aAAaF,EAChC,CAAE,MAAOjS,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAUA,SAAAoS,CAAUH,EAA6BrB,EAAcsB,MACnD,MAAMjC,EAAWlB,IACX3B,EAAW+B,EAAUkD,YAAYJ,GACvChC,EAASX,aAAalC,GACtB6C,EAASE,QAAQ,cACjB,MAAMC,EAAUH,EAASI,UAEzB,OADAJ,EAAS/B,SACFkC,CACT,EAUA,IAAAkC,CAAKtD,EAAkBuD,GACrB,IACEpD,EAAUqD,eAAexD,EAAQ5B,SAAUmF,EAC7C,CAAE,MAAOvS,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAUA,SAAAyS,CAAUzD,EAAkBS,GAC1B,IACEN,EAAUuD,cAAc1D,EAAQ5B,SAAUqC,EAC5C,CAAE,MAAOzP,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAcA,IAAA2S,CAAKsJ,GACH,IACE9M,EAAUwD,KAAKsJ,EAAI7O,SACrB,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAaA,KAAAoC,GACE,IACE,MAAMyQ,EAAiB1D,EAAU/M,QAC3B6Z,EAAMsD,EAAqB5Q,EAArB4Q,CAA8B,CACxC3Q,YACAgC,gBACA7B,UAHUwQ,GAMZ,OADAtD,EAAIpK,OAAOgB,GACJoJ,CACT,CAAE,MAAOjc,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAeA,IAAA8S,CAAKmJ,GACH,IACE9M,EAAU2D,KAAKmJ,EAAI7O,UAInB6O,EAAI/N,QACN,CAAE,MAAOlO,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,GAGIuP,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAGFoQ,EAAgB,EAC3B/Q,aAEA,MAAMC,EAAmBD,EAAOC,QAChC,OAAO4Q,EAAqB5Q,EAAQ,EC5MzB+Q,EAAiB,EAC5BhR,YA5EA,CAACC,GACD,IACA,KAEE,MAAMyF,EAAQzF,EAAQ2I,WAAWjD,KAC3BsL,EAAOhR,EAAQ2I,WAAWsI,IAC1BC,EAAQlR,EAAQ2I,WAAWwI,KAC3BC,EAAOpR,EAAQ2I,WAAW0I,IAShC,MAAO,CAQL,QAAI3L,GAIF,OAAOD,CACT,EASA,OAAIwL,GAIF,OAAOD,CACT,EASA,QAAIG,GAIF,OAAOD,CACT,EASA,OAAIG,GAIF,OAAOD,CACT,EACD,EAOIE,CADkBvR,EAAOC,SCiD3B,MC3GDuR,EACHvR,GACD,EACEC,YACAgC,gBACA7B,YAEF,KACE,MAAME,EAAcN,EAAQ0N,UAC5B,IAAIlN,EAAY,IAAIF,EASpB,MAAMI,EAAkB,CAStB,YAAIjC,GACF,OAAO+B,CACT,EAUA,MAAA0C,CAAOzE,GACLiC,EAAKnB,SACLiB,EAAY,IAAIF,EAAY7B,GAC5BmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EAUA,IAAAiE,CAAKC,EAA6BrB,EAAcsB,MAC9C,IACE,OAAO/C,EAAUgD,aAAaF,EAChC,CAAE,MAAOjS,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAUA,SAAAoS,CAAUH,EAA6BrB,EAAcsB,MACnD,MAAMjC,EAAWlB,IACX3B,EAAW+B,EAAUkD,YAAYJ,GACvChC,EAASX,aAAalC,GACtB6C,EAASE,QAAQ,cACjB,MAAMC,EAAUH,EAASI,UAEzB,OADAJ,EAAS/B,SACFkC,CACT,EAUA,IAAAkC,CAAKtD,EAAkBuD,GACrB,IACEpD,EAAUqD,eAAexD,EAAQ5B,SAAUmF,EAC7C,CAAE,MAAOvS,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAUA,SAAAyS,CAAUzD,EAAkBS,GAC1B,IACEN,EAAUuD,cAAc1D,EAAQ5B,SAAUqC,EAC5C,CAAE,MAAOzP,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAcA,IAAA2S,CAAKsJ,GACH,IACE9M,EAAUwD,KAAKsJ,EAAI7O,SACrB,CAAE,MAAOpN,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAaA,KAAAoC,GACE,IACE,MAAMyQ,EAAiB1D,EAAU/M,QAC3B6Z,EAAMiE,EAAqBvR,EAArBuR,CAA8B,CACxCtR,YACAgC,gBACA7B,UAHUmR,GAMZ,OADAjE,EAAIpK,OAAOgB,GACJoJ,CACT,CAAE,MAAOjc,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAeA,IAAA8S,CAAKmJ,GACH,IACE9M,EAAU2D,KAAKmJ,EAAI7O,UAInB6O,EAAI/N,QACN,CAAE,MAAOlO,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,GAGIuP,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAGF8Q,EAAgB,EAC3BzR,aAEA,MAAMC,EAAmBD,EAAOC,QAChC,OAAOuR,EAAqBvR,EAAQ,EC3JzByR,EAAoB,EAC/B1R,YA3EA,CAACC,GACD,IACA,KAEE,MAAMyF,EAAQzF,EAAQ0R,aAAahM,KAC7BiM,EAAS3R,EAAQ0R,aAAavM,MAC9ByM,EAAS5R,EAAQ0R,aAAaG,MAC9BC,EAAS9R,EAAQ0R,aAAaK,MASpC,MAAO,CAQL,QAAIrM,GAIF,OAAOD,CACT,EASA,SAAIN,GAIF,OAAOwM,CACT,EASA,SAAIE,GAIF,OAAOD,CACT,EASA,SAAIG,GAIF,OAAOD,CACT,EACD,EAMIE,CADkBjS,EAAOC,SCsCrBiS,EAAmB,IAnG9B,EACEhS,YACAG,SACA6B,mBAEF,KACE,IAAIzB,EASJ,MAAME,EAAqB,CASzB,YAAIjC,GACF,OAAO+B,CACT,EAUA,YAAAG,CAAalC,GACXiC,EAAKnB,SACLiB,EAAY/B,EACZmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EAUA,IAAAiE,CAAKC,EAA6BrB,EAAcsB,MAC9C,IACE,OAAO/C,EAAUgD,aAAaF,EAChC,CAAE,MAAOjS,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAUA,SAAAoS,CAAUH,EAA6BrB,EAAcsB,MACnD,MAAMjC,EAAWlB,IACX3B,EAAW+B,EAAUkD,YAAYJ,GACvChC,EAASX,aAAalC,GACtB6C,EAASE,QAAQ,cACjB,MAAMC,EAAUH,EAASI,UAEzB,OADAJ,EAAS/B,SACFkC,CACT,GAGIb,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,ECwIFwR,EAAa,EAAGnS,YA1N3B,CAACC,GACD,EAAGC,eACH,KAEE,MAAMkS,EAAqBnS,EAAQoS,kBAC7BC,EAAsBrS,EAAQsS,mBAC9BC,EAAqBvS,EAAQwS,kBAC7BC,EAAuBzS,EAAQ0S,oBAC/BC,EAAwB3S,EAAQ4S,qBAChCC,EAAyB7S,EAAQ8S,sBACjCC,EAAuB/S,EAAQgT,oBAC/BC,EAAuBjT,EAAQkT,oBAC/BC,EAAwBnT,EAAQoT,qBAChCC,EAAuBrT,EAAQsT,oBAC/BC,EAAyBvT,EAAQwT,sBACjCC,EAA6BzT,EAAQ0T,0BACrCC,EAA8B3T,EAAQ4T,2BACtCC,EAA+B7T,EAAQ8T,4BAE7C,IAAItT,EACAuT,EAQJ,MAAMrT,EAAe,CASnB,YAAIjC,GACF,OAAO+B,CACT,EAUA,YAAAG,CAAalC,GACXiC,EAAKnB,SACLiB,EAAY/B,EACZmC,EAAInB,WAAWe,EACjB,EAUA,SACOA,IAGLI,EAAIxO,aACJoO,EAAUjB,SACViB,OAAYpB,EACd,EAUA,IAAAyC,CAAKf,EAAoBkT,GACvB,IAEE,OADAD,EAAQC,GAAelT,EAAMlR,YAAYD,KACjCokB,GACN,IAAK,aACHvT,EAAY2R,EAAmBrR,GAC/B,MACF,IAAK,aACHN,EAAY+R,EAAmBzR,GAC/B,MACF,IAAK,cACHN,EAAY6R,EAAoBvR,GAChC,MACF,IAAK,eACHN,EAAYiS,EAAqB3R,GACjC,MACF,IAAK,gBACHN,EAAYmS,EAAsB7R,EAAMxN,WAAW4N,MAAM,MACzD,MACF,IAAK,iBACHV,EAAYqS,EAAuB/R,EAAMxN,WAAW4N,MAAM,MAC1D,MACF,IAAK,UACHV,EAAYuS,EAAqBjS,EAAMxN,WAAW4N,MAAM,MACxD,MACF,QACE,MAAM,IAAIvU,MAAMsS,GAEtB,CAAE,MAAO5N,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAQA,QAAI2iB,GACF,OAAOD,CACT,EASA,OAAAvS,CAAQwS,GACND,EAAQC,CACV,EASA,QAAIrR,GACF,OAAOnC,EAAUmC,MACnB,EAUA,QAAAsR,CAASC,GACP,IACE,OAAO1T,EAAU3L,IAAIqf,EACvB,CAAE,MAAO7iB,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAUA,MAAAqR,CAAOC,EAAcwR,GACnB,IACE3T,EAAUkC,OAAOC,EAAMwR,EACzB,CAAE,MAAO9iB,GACP,MAAM4O,EAAUQ,KAAKpP,EACvB,CACF,EAaA,OAAAqQ,GACE,IAAKlB,EACH,MAAM,IAAI7T,M7B9OY,wB6BgPxB,OAAQonB,GACN,IAAK,aACH,OAAO1nB,WAAWwV,KAAKoR,EAAqBzS,IAC9C,IAAK,aACH,OAAOhS,WAAWqT,KAAKwR,EAAqB7S,IAC9C,IAAK,cACH,OAAO/R,YAAYoT,KAAKsR,EAAsB3S,IAChD,IAAK,eACH,OAAO7R,aAAakT,KAAK0R,EAAuB/S,IAClD,IAAK,gBACH,OAAO5R,cAAciT,KAAK4R,EAA2BjT,IACvD,IAAK,iBACH,OAAO3R,eAAegT,KAAK8R,EAA4BnT,IACzD,IAAK,UACH,OAAO3R,eAAegT,KAAKgS,EAA6BrT,IAC1D,QACE,MAAM,IAAI7T,MAAMsS,GAEtB,GAGI2B,EAAMf,EAAaa,EAAMF,GAE/B,OAAOE,CAAI,EAKN0T,CADkBrU,EAAOC,gBCpQnBtV,MAAO4P,IACpB,MAAM0F,QAAgBqU,EAAY,CAChC,eAAAhW,CACEiW,EACArgB,GAGAA,EADiB,IAAI9E,YAAYolB,SAASja,EAAYga,GACzCha,EACf,IAEF,MCgBkB5P,OAClB8pB,IAEA,MAAMzU,QAAeyU,IACrB,MN4G6B,GAC7BjU,eACA+I,aACAhF,cACAM,eACA3C,gBACA+D,cACAyO,UACA3M,YACAZ,gCACAD,uBACAwC,YACAY,YACApK,YACAkN,aACAS,eACA1N,mBACAwI,UACAxG,cACA/B,YACAoP,eACA9B,YACAE,YACAhF,aACA+E,YACAhJ,gBACA6E,eACAnJ,aAMA,MAAMsU,EAAYzU,MACZ0U,EAAgB1S,MAChB2S,EAAmB1U,MACnBgF,EAAgBR,MAChBkE,EAAaD,MAGbkM,EAASzU,EAAO,CAAEH,UAAWyU,IAC7B3L,EAAenE,EAAa,CAChC3E,UAAWyU,EACXhQ,cAAeQ,EACf9E,OAAQyU,GAHWjQ,GAKfkQ,EAAUpM,EAAQ,CACtBzI,UAAWyU,EACXzS,cAAe0S,EACfvU,OAAQyU,IAEJ5L,EAAesG,EAAa,CAChCtP,UAAWyU,EACXhM,QAASoM,EACT1U,OAAQyU,GAHWtF,GAKfwF,EAAexL,EAAa,CAChCtJ,UAAWyU,EACXtU,OAAQyU,EACR5S,cAAe0S,IAEXK,EAAc9S,EAAY,CAAEjC,UAAWyU,IACvC3T,EAAYZ,EAAU,CAC1BF,UAAWyU,EACXzS,cAAe0S,EACfzS,YAAa8S,EACb9U,iBAAkB0U,EAClBxU,OAAQyU,IAEJ7M,EAAasB,EAAW,CAC5BrJ,UAAWyU,EACXzS,cAAe0S,EACfzS,YAAa8S,EACb9U,iBAAkB0U,EAClBxU,OAAQyU,IAEJI,EAAe1U,EAAa,CAChCN,UAAWyU,EACXxU,iBAAkB0U,EAClBzU,UAAWY,EACXX,OAAQyU,IAEJK,EAAc5Q,EAAY,CAC9BrE,UAAWyU,EACXxU,iBAAkB0U,EAClBzU,UAAWY,EACXX,OAAQyU,IAEJM,EAAgCjO,IAChCC,EAAuBF,EAAqB,CAChDhH,UAAWyU,EACXzS,cAAe0S,EACfjM,QAASoM,EACTnM,WAAYC,EACZ1G,YAAa8S,EACb5U,OAAQyU,IAEJvO,EAAcN,EAAY,CAC9B/F,UAAWyU,EACXzN,qBAAsBE,EACtBjF,YAAa8S,EACb9N,8BAA+BiO,IAE3B9U,EAAUoU,EAAQ,CACtBvS,YAAa8S,EACbhP,YAAaM,EACb5B,cAAeQ,IAEXkQ,EAAYtN,EAAU,CAC1B7H,UAAWyU,EACXvU,UAAWY,IAEPsU,EAAY5L,EAAU,CAC1BxJ,UAAWyU,EACXxU,iBAAkB0U,EAClBtL,WAAYtB,EACZuB,aAAcwL,IAEVO,EAAYjL,EAAU,CAC1BpK,UAAWyU,EACXxU,iBAAkB0U,EAClBtL,WAAYtB,EACZ7H,UAAWY,IAEPyI,EAAYiE,EAAU,CAC1BxN,UAAWyU,EACXzS,cAAe0S,EACfvU,OAAQyU,IAEJhN,EAAY6F,EAAU,CAC1BzN,UAAWyU,EACXzS,cAAe0S,EACfvU,OAAQyU,IAEJ/J,EAAY6C,EAAU,CAC1B1N,UAAWyU,EACXzS,cAAe0S,EACfvU,OAAQyU,IAEJ1I,EAAagB,EAAW,CAC5BlN,UAAWyU,EACXzS,cAAe0S,EACfvU,OAAQyU,IAcV,MAAO,CACLtU,aAAc0U,EACd3L,WAAYtB,EACZ1D,YAAa4Q,EACbtQ,aAAcmE,EACd9G,cAAe0S,EACf3O,YAAaM,EACbmO,QAASpU,EACTyH,UAAWsN,EACXlO,8BAA+BiO,EAC/BlO,qBAAsBE,EACtBsC,UAAW4L,EACXhL,UAAWiL,EACXrV,UAAWyU,EACXvH,WAAYhB,EACZyB,aA3BmBA,EAAa,CAChC3N,UAAWyU,EACXjH,UAAWjE,EACXkE,UAAW7F,EACX8F,UAAW7C,EACXqC,WAAYhB,EACZ5C,aAAcwL,IAsBd7U,iBAAkB0U,EAClBlM,QAASoM,EACT5S,YAAa8S,EACb7U,UAAWY,EACXwO,aAActG,EACdwE,UAAWjE,EACXmE,UAAW7C,EACXnC,WAAYC,EACZ8E,UAAW7F,EACXnD,cAAeQ,EACfqE,aAAcwL,EACd3U,OAAQyU,EACRU,gBACD,EMrSMC,CAAgB,CACrBjV,aAAcT,EAAiB,CAC7BC,WAEFuJ,WAAYlF,EAAe,CACzBrE,WAEFuE,YAAaD,EAAgB,CAC3BtE,WAEF6E,aAAcH,EAAiB,CAC7B1E,WAEFkC,cAAeuD,EAAkB,CAC/BzF,WAEFiG,YAAa2B,EAAgB,CAC3B5H,WAEF0U,QAAS1O,EAAY,CACnBhG,WAEF+H,UAAWF,EAAc,CACvB7H,WAEFmH,8BAA+BiB,IAC/BlB,qBAAsBwB,EAAyB,CAC7C1I,WAEF0J,UAAWJ,EAAc,CACvBtJ,WAEFsK,UAAWD,EAAc,CACvBrK,WAEFE,UAAW6M,EAAc,CACvB/M,WAEFoN,WAAYI,EAAe,CACzBxN,WAEF6N,aAAcJ,EAAiB,CAC7BzN,WAEFG,iBAAkBkO,EAAqB,CACrCrO,WAEF2I,QAASiG,EAAY,CACnB5O,WAEFmC,YAAaiN,EAAgB,CAC3BpP,WAEFI,UAAWsQ,EAAc,CACvB1Q,WAEFwP,aAAcF,EAAiB,CAC7BtP,WAEF0N,UAAWkD,EAAc,CACvB5Q,WAEF4N,UAAWmD,EAAc,CACvB/Q,WAEF4I,WAAYoI,EAAe,CACzBhR,WAEF2N,UAAW8D,EAAc,CACvBzR,WAEF2E,cAAe+M,EAAkB,CAC/B1R,WAEFwJ,aAAc0I,IACd7R,OAAQ8R,EAAW,CACjBnS,YAEF,EDlGK0V,EAAK/qB,UAAA,CAAesV,aAAW"}